<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1 plus MathML 2.0//EN" "http://www.w3.org/Math/DTD/mathml2/xhtml-math11-f.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta name="GENERATOR" content="LyX 2.3.6.1" />
<meta http-equiv="Content-type" content="text/html;charset=UTF-8" />
<title>EDMA (Effective Data Model Abstraction)</title>
<style type='text/css'>
/* LyX Provided Styles */
div.bibtexentry { margin-left: 2em; text-indent: -2em; }
span.bibtexlabel:before{ content: "["; }
span.bibtexlabel:after{ content: "] "; }

/* Layout-provided Styles */
h1.title {
font-size: x-large;
margin-bottom: 1ex;
text-align: center;

}
div.author {
font-size: large;
margin-top: 1.3ex;
margin-bottom: 0.7ex;
text-align: center;

}
div.date {
font-size: large;
margin-top: 0.9ex;
margin-bottom: 0.5ex;
text-align: center;

}
div.standard {
	margin-bottom: 2ex;
}
div.abstract {
font-size: small;
margin-top: 0.7ex;
margin-bottom: 0.7ex;
margin-left: 3ex;
margin-right: 3ex;
text-align: left;

}
span.abstract_label {
font-weight: bold;
font-size: large;
text-align: center;

}

div.abstract {
	margin: 4ex;
}
div.abstract_item {
	font-size: small;
	padding-top: 1ex;
}
div.abstract_label {
	font-weight: bold;
}
h2.section {
font-weight: bold;
font-size: x-large;
margin-top: 1.3ex;
margin-bottom: 0.7ex;
text-align: left;

}
ul.itemize {
margin-top: 0.7ex;
margin-bottom: 0.7ex;
margin-left: 3ex;
text-align: left;

}
h3.subsection {
font-weight: bold;
font-size: large;
margin-top: 0.9ex;
margin-bottom: 0.5ex;
text-align: left;

}
h5.paragraph {
font-weight: bold;
font-size: medium;
margin-top: 0.4ex;
text-align: left;

}
h6.subparagraph {
font-weight: bold;
font-size: medium;
margin-top: 0.4ex;
margin-left: 2ex;
text-align: left;

}
dl.description dt { font-weight: bold; }
h4.subsubsection {
font-weight: bold;
font-size: medium;
margin-top: 0.7ex;
margin-bottom: 0.4ex;
text-align: left;

}
ol.enumerate {
margin-top: 0.7ex;
margin-bottom: 0.7ex;
margin-left: 3ex;
text-align: left;

}
blockquote.quotation {
margin-top: 0.5ex;
margin-bottom: 0.5ex;
margin-left: 3ex;
margin-right: 3ex;
text-align: left;

}
h5.paragraph_ {
font-weight: bold;
font-size: medium;
margin-top: 0.4ex;
text-align: left;

}
div.plain_layout {
text-align: left;

}
ol.lyxlist {
	list-style-type: none;
}
li.labeling_item {
	text-indent: -5em;
	margin-left: 5em;
}
span.lyxlist {
	margin-right: 1em;
}
div.toc {
  margin: 2em 0em;
  border-style: solid;
  border-width: 2px 0px;
  padding: 1em 0em;
}
h2.tochead { font-size: x-large; font-weight: bold; }
div.lyxtoc-0 {
  margin: 2em 0em 0em 0em;
  font-size: xx-large;
  font-weight: bold;
}
div.lyxtoc-1 {
  margin: 1em 0em 0em 0em;
  font-size: x-large;
  font-weight: bold;
}
div.lyxtoc-2 {
  margin: 0em 0.1em 0em 1em;
  font-size: large;
  font-weight: normal;
}
div.lyxtoc-3 { margin: 0em 0.1em 0em 0.5em; font-size: medium; }
div.lyxtoc-4 { margin: 0em 0.1em 0em 0.5em; }
div.lyxtoc-5 { margin: 0em 0.1em 0em 0.5em; }
div.lyxtoc-6 { margin: 0em 0.1em 0em 0.5em; }
a.tocentry {
  text-decoration: none;
  color: black;
}
a.tocentry:visited { color: black; }
div.float-listings {
	border: 2px solid black;
	padding: 1ex;
	margin: 1ex;
}
div.listings-caption {
	text-align: center;
	border: 2px solid black;
	padding: 1ex;
	margin: 1ex;
	}
div.float {
	border: 2px solid black;
	text-align: center;
}
div.float-caption {
	text-align: center;
	border: 2px solid black;
	padding: 1ex;
	margin: 1ex;
}


</style>
</head>
<body dir="auto">
<h1 class="title" id='magicparlabel-1'>EDMA (Effective Data Model Abstraction)</h1>
<div class="author" id='magicparlabel-2'>Tobias Grundtvig &amp; Martin Vestergaard
<br />

Supervisor: Philippe Bonnet</div>
<div class="date" id='magicparlabel-3'>June 1st 2012</div>

<div class="abstract" id='magicparlabel-6'><span class="abstract_label">Abstract</span>
<div class="abstract_item">In this thesis work, we design and implement a software tool to assist the process of getting from an abstract data model defined in an arbitrary domain to a thread safe, implementation in java that supports automated durable persistence and seamless remote access without the need of an external database. We provide a convenient method to create domain specific fine grained data types that can be used in the definition of the abstract model. By using model driven development techniques we automatically gdefinition and a java code generation tool that automatically generates an object oriented representation of the defined model. The generated object oriented model binds to a general runtime interface</div>
<div class="abstract_item">We do this by designing and implementing a Java-based runtime, consisting of a transaction module, a persistence module and an execution module, all operating on a run-time meta-model, representing the user's data model. The user's data model is defined in a data definition language designed for the purpose, and compiled to object oriented Java-code, utilizing the runtime.</div>
<div class="abstract_item">By doing this, we have created a viable alternative to using relational databases from an object-oriented language. The solution is different from traditional object-relational mapping solutions, in that it keeps the whole data model centralized. </div>
</div>


<div class="standard" id='magicparlabel-9'><br />
</div>


<div class='toc'><h2 class='tochead section'>Table of Contents</h2>


<div class='lyxtoc-1'><div class='lyxtoc-2'><a href='#magicparlabel-14' class='tocentry'>1 Introduction</a>


<div class='lyxtoc-3'><a href='#magicparlabel-29' class='tocentry'>1.1 Example Conceptual Data Model</a>
</div>
</div>

<div class='lyxtoc-2'><a href='#magicparlabel-50' class='tocentry'>2 Background</a>


<div class='lyxtoc-3'><a href='#magicparlabel-53' class='tocentry'>2.1 Object Models</a>
</div>

<div class='lyxtoc-3'><a href='#magicparlabel-78' class='tocentry'>2.2 Relational Databases</a>
</div>

<div class='lyxtoc-3'><a href='#magicparlabel-222' class='tocentry'>2.3 Object Relational Mapping</a>
</div>

<div class='lyxtoc-3'><a href='#magicparlabel-318' class='tocentry'>2.4 Summary</a>
</div>
</div>

<div class='lyxtoc-2'><a href='#magicparlabel-322' class='tocentry'>3 Problem Analysis</a>


<div class='lyxtoc-3'><a href='#magicparlabel-323' class='tocentry'>3.1 Identifying the problem</a>
</div>

<div class='lyxtoc-3'><a href='#magicparlabel-336' class='tocentry'>3.2 Solving the problem</a>
</div>

<div class='lyxtoc-3'><a href='#magicparlabel-363' class='tocentry'>3.3 Related Work</a>
</div>
</div>

<div class='lyxtoc-2'><a href='#magicparlabel-407' class='tocentry'>4 EDMA System Design</a>


<div class='lyxtoc-3'><a href='#magicparlabel-441' class='tocentry'>4.1 Value Domains</a>
</div>

<div class='lyxtoc-3'><a href='#magicparlabel-506' class='tocentry'>4.2 Meta Model</a>
</div>

<div class='lyxtoc-3'><a href='#magicparlabel-644' class='tocentry'>4.3 EDMA Data Definition Language</a>
</div>

<div class='lyxtoc-3'><a href='#magicparlabel-928' class='tocentry'>4.4 Compiler</a>
</div>

<div class='lyxtoc-3'><a href='#magicparlabel-1343' class='tocentry'>4.5 Runtime System</a>
</div>
</div>

<div class='lyxtoc-2'><a href='#magicparlabel-1495' class='tocentry'>5 Evaluation</a>


<div class='lyxtoc-3'><a href='#magicparlabel-1498' class='tocentry'>5.1 Workflow</a>
</div>

<div class='lyxtoc-3'><a href='#magicparlabel-1518' class='tocentry'>5.2 Implementing the Diving School</a>
</div>
</div>

<div class='lyxtoc-2'><a href='#magicparlabel-1525' class='tocentry'>6 Conclusion</a>
</div>

<div class='lyxtoc-2'><a href='#magicparlabel-1547' class='tocentry'>7 Future Work</a>
</div>

<div class='lyxtoc-2'><a href='#magicparlabel-1564' class='tocentry'>A EDMA tutorial</a>


<div class='lyxtoc-3'><a href='#magicparlabel-1573' class='tocentry'>A.1 Set up a new EDMA project</a>
</div>

<div class='lyxtoc-3'><a href='#magicparlabel-1641' class='tocentry'>A.2 Define Global Value Domains</a>
</div>

<div class='lyxtoc-3'><a href='#magicparlabel-1919' class='tocentry'>A.3 Defining the Data Model</a>
</div>

<div class='lyxtoc-3'><a href='#magicparlabel-1936' class='tocentry'>A.4 Kinds</a>
</div>

<div class='lyxtoc-3'><a href='#magicparlabel-1999' class='tocentry'>A.5 Views and Actions</a>
</div>

<div class='lyxtoc-3'><a href='#magicparlabel-2091' class='tocentry'>A.6 Try it out</a>
</div>

<div class='lyxtoc-3'><a href='#magicparlabel-2174' class='tocentry'>A.7 Indexes</a>
</div>

<div class='lyxtoc-3'><a href='#magicparlabel-2239' class='tocentry'>A.8 Relationships</a>
</div>

<div class='lyxtoc-3'><a href='#magicparlabel-2285' class='tocentry'>A.9 Remote Access</a>
</div>
</div>

<div class='lyxtoc-2'><a href='#magicparlabel-2308' class='tocentry'>B EDMA Language Grammar</a>
</div>

<div class='lyxtoc-2'><a href='#magicparlabel-2517' class='tocentry'>C Performance Evaluation</a>


<div class='lyxtoc-3'><a href='#magicparlabel-2530' class='tocentry'>C.1 Memory Consumption</a>
</div>

<div class='lyxtoc-3'><a href='#magicparlabel-2594' class='tocentry'>C.2 Data Insertion Response Time</a>
</div>

<div class='lyxtoc-3'><a href='#magicparlabel-2621' class='tocentry'>C.3 Data Insertion Throughput</a>
</div>

<div class='lyxtoc-3'><a href='#magicparlabel-2651' class='tocentry'>C.4 Data Retrieval Response Time</a>
</div>

<div class='lyxtoc-3'><a href='#magicparlabel-2677' class='tocentry'>C.5 Data Retrieval Throughput</a>
</div>

<div class='lyxtoc-3'><a href='#magicparlabel-2710' class='tocentry'>C.6 Interleaved Actions and Views</a>
</div>

<div class='lyxtoc-3'><a href='#magicparlabel-2746' class='tocentry'>C.7 Scalability</a>
</div>
</div>



</div>
</div>


<div class="standard" id='magicparlabel-11'><br />
</div>

<h2 class="section" id='magicparlabel-14'><span class="section_label">1</span> Introduction</h2>
<div class="standard" id='magicparlabel-15'>Many software development projects use object oriented approaches to solve various problems. The main idea in object oriented development is to use various abstraction levels to overview and understand large and complex systems. An object should encapsulate and hide any internal structure and state from the outside world and provide only an interface for the outside world to see and use. One advantage of doing this, is that the object can then be seen at a higher level of abstraction, since the outside viewer does not have to care about the internal details. Another advantage is that the object could easily be replaced with another object providing the same interface, but with a different implementation.</div>

<div class="standard" id='magicparlabel-16'>In an ideal world, building software would be much like playing with LEGO bricks. Instead of building large specialized programs from scratch, we should rather create a good set of small abstract programs that can be put together in different ways to solve different tasks. There are two properties in which software development is superior to LEGO:</div>

<ul class="itemize" id='magicparlabel-17'><li class="itemize_item">When you need a type of brick that LEGO does not manufacture, it is rather hard to make it yourself. This is not the case in software development. </li>
<li class="itemize_item">You have an unlimited number of each type of brick, so in software development reuse does not mean recycle. You do not have to tear down the beautiful house you build yesterday, because you want to build a robot today.</li>
</ul>
<div class="standard" id='magicparlabel-19'>In a good object oriented design, interfaces are designed at the highest possible level of abstraction to obtain high flexibility and code reuse.</div>

<div class="standard" id='magicparlabel-20'>Here is a very simple example to illustrate the idea of polymorphism through an interface: </div>

<div class="standard" id='magicparlabel-21'>We want to create some Java programs that interacts with a user through a textual interface. This could be written using System.in to receive input from the user and System.out to show a text to the user. But in a good object oriented design we would instead create a terminal interface with a putString and a getString, that our programs would use instead of the System.in and System.out. Then when we could create an implementation of the terminal interface that uses the System.in and System.out. Now we would have the exact same behavior of the program as if we had used System.in and System.out.</div>

<div class="standard" id='magicparlabel-22'>At this point we have done some extra work, but without any real benefit yet. But then one day we want to send the text messages to and from a mobile phone or maybe even pass them through voice generation and recognition to facilitate a blind user. All we have to do then is create new implementations of the terminal interface, leaving the original programs untouched. </div>

<div class="standard" id='magicparlabel-23'>People that play with LEGO bricks often tries to make models of real-world objects like trains, houses, persons, cars cities etc. Sometimes they also try to model objects from fantasy worlds like dragons, goblins, unicorns etc. Software developers also often try to model objects and concepts from real or fantasy worlds (this is especially true for game developers).</div>

<div class="standard" id='magicparlabel-24'>Imagine that you have spent an entire day building a large LEGO city. Then you get tired and go to bed. Next morning when you wake up, the city is still there exactly as you left it.</div>

<div class="standard" id='magicparlabel-25'>Unfortunately this does NOT work in a typical object oriented language. When you turn off the computer, all objects disappear and you have to start all over next time you start the computer. We would actually like to have this as an optional feature for our LEGO bricks, so if we pushed a button, all bricks would automatically be returned to their starting position in the drawer.</div>

<div class="standard" id='magicparlabel-26'>With LEGO bricks persistence is build in as a standard, but it takes quite some work to reset everything. In a typical object oriented language persistence takes quite some work to get, but resetting is easy.</div>

<div class="standard" id='magicparlabel-27'>In this thesis we will analyze various methods of abstraction that could make software developing faster and even more like playing with LEGO bricks.</div>

<div class="standard" id='magicparlabel-28'>We will analyze methods to <em>shorten the path from an idea of a model to a functional prototype</em>. We will use ideas from various domains: Object oriented programming, model driven development, modular programming, interface based programming, entity-relationships and LEGO.</div>
<h3 class="subsection" id='magicparlabel-29'><span class="subsection_label">1.1</span> Example Conceptual Data Model</h3>
<div class="standard" id='magicparlabel-30'>Throughout this report, we will concretize the discussed concepts using a small, structured data model representing a course registration system for a fictive diving school. </div>

<div class="standard" id='magicparlabel-31'>The school offers different diving courses and some of these courses are dependent on one or more other courses. For example it is only possible to take the course &ldquo;Shark riding&rdquo; if you have already passed the course &ldquo;Shark taming&rdquo;. The system must keep track of the different course types and their dependencies. It must also keep track of the students and which course types they have passed and which courses they are enrolled on. The system should also keep track of the teachers, which course types they are able to teach and which courses they are signed up to teach.</div>

<div class="standard" id='magicparlabel-32'>The diver school recruits their teachers from the best of the students and they can start teaching the basic courses even before they have finished all the advanced courses. Therefore, it must be possible for the same person to be both a teacher and a student at the same time.</div>

<div class="standard" id='magicparlabel-33'>Each person in the system must also have an amount of credit associated, which will be used by the students to pay for the courses they sign up for and the teachers salary will be paid out to their credit account. In a real world scenario we would keep track of all transactions on the credit account, but to keep our example simple we will only save the current balance. See figure  for a graphical representation of the diving schools conceptual data model.</div>




<h2 class="section" id='magicparlabel-50'><span class="section_label">2</span> <a id="sec_DatabaseProgramming" />
Background</h2>
<div class="standard" id='magicparlabel-51'>In this section, we describe some of the different approaches to working with structured, persisted data models. We base the following sections on our running example model of a diving school.</div>

<div class="standard" id='magicparlabel-52'>In the following present some of the problems that must be overcome, when implementing the model in a purely object oriented manner, using relational databases, and using object relational mapping.</div>
<h3 class="subsection" id='magicparlabel-53'><span class="subsection_label">2.1</span> Object Models</h3>
<div class="standard" id='magicparlabel-54'>Coding the diving school data model in a purely object oriented fashion requires going through the following steps.</div>

<ul class="itemize" id='magicparlabel-55'><li class="itemize_item">Create a class for each entity kind (Student, Teacher, Course, etc.)</li>
<li class="itemize_item">For each one-to-one relation, create an reference going from each class to the other.</li>
<li class="itemize_item">For each one-to-many relation, e.g. going from Teacher to Course, create a set of references to Course in Teacher, and a single reference to Teacher in Course.</li>
<li class="itemize_item">For each many-to-many relation, e.g. going from Student to Course, create a set of references to Course in Student, and vice versa.</li>
<li class="itemize_item">For each is-a relation (e.g. Student is an Person), let Student inherit from Person.</li>
</ul>
<div class="standard" id='magicparlabel-60'>Creating the diving school model will follow roughly these steps, but there are some pitfalls.</div>
<h5 class="paragraph" id='magicparlabel-61'><span class="paragraph_label"></span> Relations</h5>
<div class="standard" id='magicparlabel-62'>In object oriented languages, only one-way associations are directly supported, in the form of object references. Having two-way associations requires carefully hooking up objects to each other, for example by adding methods in all participants for adding and deleting mutual connections. For example, if a relation between Teacher and Course exists (one-to-many), whenever a teacher is put on a course, two actions must happen:</div>

<ul class="itemize" id='magicparlabel-63'><li class="itemize_item">The <em>teacher</em> reference in the course must be set to point at the teacher.</li>
<li class="itemize_item">The <em>course</em> must be added to the teacher's set of courses.</li>
</ul>
<div class="standard" id='magicparlabel-65'>This book-keeping requires careful maintenance, and the connections must only be changed through dedicated methods. If, for example, another object gets hold of the teacher instance's set of courses, the set might be manipulated without the teacher instance knowing. Or the teacher-reference in the course instance might get changed, without the teacher-instance being noticed of the association change.</div>

<div class="standard" id='magicparlabel-66'>This problem may be manageable in relatively simple data models, but requires more boilerplate-code for maintaining these relationships must be created, making it a time consuming and error prone process.</div>
<h5 class="paragraph" id='magicparlabel-67'><span class="paragraph_label"></span> Indexes</h5>
<div class="standard" id='magicparlabel-68'>In systems with structured data, there is often a need to be able to search for data pertaining to certain criteria. For example, it might be desirable to be able to search for a set of students with a certain name. It might be sufficient to perform these searches by simple filtering. However, if performance is important, it might be desirable to create an index on the student names.</div>

<div class="standard" id='magicparlabel-69'>In some cases, the criteria can be more complicated. For example it might be desirable to get a set of all courses that a specific student can attend. It could be done by the following procedure:</div>

<ul class="itemize" id='magicparlabel-70'><li class="itemize_item">For the specific student, get all passed course types (<em>passed_course_types</em>).</li>
<li class="itemize_item">Create an empty result course set (<em>res_course</em>).</li>
<li class="itemize_item">For each course type, if the course type is not in <em>passed_course_types</em>, and all of its dependencies are in the <em>passed_course_types</em>, add all instances of the course type, with correct state and date, to <em>res_course</em>.</li>
</ul>
<div class="standard" id='magicparlabel-73'>This is a tedious procedure to program.</div>
<h5 class="paragraph" id='magicparlabel-74'><span class="paragraph_label"></span> Extension</h5>
<div class="standard" id='magicparlabel-75'>In the diving school data model, a person can be both a Student and a Teacher at the same time. Therefore, we cannot use normal object oriented inheritance to model the relationships between Person, Student and Teacher. Instead, we can use composition, so a Student and a Teacher contains a reference to a Person. Since we know the full data model at compile time, it makes sense to add downwards references from Person to Student and Teacher. It would then be possible to examine whether a Person is also a Student and/or a Teacher.</div>
<h5 class="paragraph" id='magicparlabel-76'><span class="paragraph_label"></span> Persistence</h5>
<div class="standard" id='magicparlabel-77'>Another issue with the object oriented data model, is that of persistence. If a user wants to persist the data model, without mapping it to a database, this has to be coded manually, using the available serialization mechanism of the language. </div>
<h3 class="subsection" id='magicparlabel-78'><span class="subsection_label">2.2</span> Relational Databases</h3>
<div class="standard" id='magicparlabel-79'>Relational databases play an important role in many different kinds of applications today. With the emergence of object oriented languages, and the availability of free and highly advanced database systems, the number of applications utilizing databases has exploded.</div>

<div class="standard" id='magicparlabel-80'>In many relational database systems, the actual data manipulation logic is performed in a <em>Database Management System</em> (DBMS). Data is manipulated and retrieved using SQL (Structured Query Language), a declarative language, which lets the user express a prepositional truth about the wanted result. The DBMS consists of a number of subsystems, for example for managing user access rights, receiving query strings, compiling query expressions, and managing catalogs and indexes. </div>

<div class="standard" id='magicparlabel-81'>There are several ways to communicate with the DBMS. One way is to embed SQL into the host language program, and precompile the program before the final compilation. Another approach is to use a Call Level Interface – an interface to call the DBMS directly, from inside the host language.</div>
<h5 class="paragraph" id='magicparlabel-82'><span class="paragraph_label"></span> Embedded/Static SQL</h5>
<div class="standard" id='magicparlabel-83'>The principle in using <em>embedded SQL</em> (also known as <em>static SQL</em>), is to write the necessary SQL queries inside the host language, delimited by a special pair of tags. The source code is then run through a precompiler, which looks for the special tags, and starts parsing the SQL queries. Here, the SQL queries can contain references to variables in the host language, nicely integrating the two quite differently purposed languages. The precompiler turns the SQL code into calls to library routines, accessing the DBMS.</div>


<h5 class="paragraph" id='magicparlabel-94'><span class="paragraph_label"></span> Call Level Interface</h5>
<div class="standard" id='magicparlabel-95'>Another way of communicating with the DBMS from within the host programming language, is via an implementation of a <em>call level interface</em> (CLI). A call level interface is a definition of which commands can be sent to the DBMS, and how the DBMS should answer. Having a CLI means that there is a standard way of talking to the DMBS, regardless of the vendor[<a href='#LyXCite-venkatrao1995sql'><span class="bib-label">12</span></a>]. The CLI guarantees that there is a standardized way of doing low-level communication, such as opening connections, issuing queries, and scanning through results.</div>

<div class="standard" id='magicparlabel-96'>The CLI contains functions for connections, diagnostics, functionality for pulling out meta data, processing statements, pulling out attributes, and allocating handles (connection, environment and statement handles).</div>

<div class="standard" id='magicparlabel-97'>Using CLI in practice is mostly done implicitly, by using a driver that builds on the CLI. An example of such a driver is the ODBC (Open DataBase Connectivity) driver, which lets a host program interact transparantly with a wide variety of databases. In different environments, different derivatives of the ODBC standard has been constructed – for example JDBC for Java.</div>
<h5 class="paragraph" id='magicparlabel-98'><span class="paragraph_label"></span> JDBC</h5>
<div class="standard" id='magicparlabel-99'>Using a JDBC, the developer is given a &ldquo;connector&rdquo;, with which to connect to the database. Then, using &ldquo;statement&rdquo; objects, the user writes queries as strings, which get sent to the database.</div>

<div class="standard" id='magicparlabel-100'>The package <span style='font-family:monospace;'>java.sql</span> contains interfaces for communicating with JDBC drivers. The first step in doing so, is to open a connection, which is done by invoking a connect-method in a Connection interface. The Connection interface also provides means for closing the connection again, obtaining statement-objects, preparing statements, rolling back or committing transactions. The code example shown in Listing&nbsp; shows the opening of a connection to a MySQL database in Java, followed by the execution of a query.</div>

<div class="standard" id='magicparlabel-105'>The Connection object can be stored as a field in the class and reused, until the program terminates. Before the final termination of the program, the connection should be properly closed (so that the database system doesn't have to wait for time out). The Statement object is used for issuing queries to the database. With each Statement object, there is a ResultSet object associated – when a query has been executed, a ResultSet can be retrieved. The ResultSet object functions as a cursor, and resembles a traditional iterator-object, that makes it possible to sequentially iterate over the results. </div>
<h6 class="subparagraph" id='magicparlabel-116'><span class="subparagraph_label"></span> Prepared Statements</h6>
<div class="standard" id='magicparlabel-117'>There are a couple of problems with the approach used in the code shown in Listing&nbsp;. First, there is a security issue, in that the <span style='font-family:monospace;'>name</span> variable can contain any text, making the application vulnerable to injection attacks. Secondly, what happens when the DBMS receives the query, is that it will compile the query, and create an optimized query plan. If we issue the same query multiple times, but with a different value for <span style='font-family:monospace;'>name</span>, the query gets compiled from scratch every single time. Even if the name is missing, the query can be pre- compiled, resulting in what is known as a <em>prepared statement</em>. </div>

<div class="standard" id='magicparlabel-122'>Here, a '<span style='font-family:monospace;'>?</span>' is used to indicate the parameter to be substituted, and the call <span style='font-family:monospace;'>setString</span> on stmt sets the parameter to the wanted value. Now, a query plan is produced only once, and the query can be run multiple times without the time penalty of the compilation. </div>
<h6 class="subparagraph" id='magicparlabel-133'><span class="subparagraph_label"></span> Retrieving Results</h6>
<div class="standard" id='magicparlabel-134'>After executing a statement (prepared or not), a <span style='font-family:monospace;'>ResultSet</span> object is obtained. The resulting tuples are retrieved by sequentially iterating through the <span style='font-family:monospace;'>ResultSet</span> object, as shown in Listing&nbsp;. </div>

<div class="standard" id='magicparlabel-139'>The actual data for the result is retrieved by asking the ResultSet object for the value lying at a certain position in the tuple (like <span style='font-family:monospace;'>getInt(1)</span> or <span style='font-family:monospace;'>getString(2)</span>), or by asking for the value that is stored for the attribute of a given name (like <span style='font-family:monospace;'>getInt(&ldquo;age&rdquo;)</span> or <span style='font-family:monospace;'>getString(&ldquo;name&rdquo;)</span>). Calling the <span style='font-family:monospace;'>next</span> method on the <span style='font-family:monospace;'>ResultSet</span> advances the cursor once, and returns true if hasn't reached the end. The first time <span style='font-family:monospace;'>next()</span> is called, the cursor is moved from before the first row to the first now.</div>
<h6 class="subparagraph" id='magicparlabel-151'><span class="subparagraph_label"></span> Transactions</h6>
<div class="standard" id='magicparlabel-152'>In some cases, the user has to issue a series of commands, which must be processed as one atomic group of commands – if one of them fails, the rest has to fail as well. </div>

<div class="standard" id='magicparlabel-153'>Transactions can be controlled by first disabling auto-commit on the connection-object, which is on by default. This is done by calling a specific method on the JDBC, which then tells the DBMS that each query shouldn't be committed instantly. After disabling auto-commit, it is up to the user to call a <span style='font-family:monospace;'>commit</span> function on the JDBC, after the necessary queries has been issued, or <span style='font-family:monospace;'>rollback.</span></div>
<h6 class="subparagraph" id='magicparlabel-154'><span class="subparagraph_label"></span> Stored Procedures</h6>
<div class="standard" id='magicparlabel-155'>There are two ways to utilize stored procedures, when coupling Java with a relational database. Either the stored procedure can be written in Java, and called from there as a traditional Java class, or it can be written in SQL.</div>

<div class="standard" id='magicparlabel-156'>Creating a stored procedure in Java is done by creating a static method, which fetches a connection to the database, creates a statement, and executes queries. The example in Listing&nbsp; shows a stored procedure implemented in Java, which creates a course with a given name, and puts a teacher with the given id on the course.</div>



<div class="standard" id='magicparlabel-194'>Another way of defining stored procedures, is by using an extension of the SQL language, known as SQL/PSM (Persistent Stored Modules). SQL/PSM extends SQL with variables, conditions, loops and signals. Extending SQL with at least variables and conditional branching. Although a standard has been proposed by ANSI, many of the big commercial database vendors have developed their own extensions for their flavor of SQL. </div>

<div class="standard" id='magicparlabel-195'>When writing SQL/PSM, the procedures are stored in the database management system. This is convenient, since most applications have a limited set of queries that are repeated over and over, only with different parameters. Having to send only a short command and a list of parameters, is shorter than sending possibly a long sequence of queries. This is both more secure, like prepared statements, and it reduces traffic between the application server and the database server. </div>

<div class="standard" id='magicparlabel-200'>Stored procedures need to be given parameters, like regular functions, but it distinguishes between three modes of parameters: input (IN), output (OUT), or mixed (INOUT).</div>

<dl class='description' id='magicparlabel-201'><dt class="description_label">IN</dt>
<dd class="description_item"> Parameters marked <span style='font-family:monospace;'>IN</span> are placeholders for the values that were given, when the procedure was called. Therefore, they are read-only from within the stored procedure, thus acting as constants.</dd>
<dt class="description_label">OUT</dt>
<dd class="description_item"> Parameters marked <span style='font-family:monospace;'>OUT</span> are those that are returned, when the stored procedure finishes. </dd>
<dt class="description_label">INOUT</dt>
<dd class="description_item"> Parameters marked <span style='font-family:monospace;'>INOUT</span> are both input and output parameters – they will have a value when the procedure is called, but they can be assigned a new value before the procedure completes. </dd>
</dl>
<div class="standard" id='magicparlabel-204'>Conditionals in SQL/PSM follow a typical syntax of if-then-else statement. Variables can be declared with a <span style='font-family:monospace;'>DECLARE</span> statement, and assigned values with a <span style='font-family:monospace;'>SET</span> statement. Statements can be grouped between <span style='font-family:monospace;'>BEGIN...END</span> statements. Loops can be created with either <span style='font-family:monospace;'>LOOP...END LOOP</span> construct, with a <span style='font-family:monospace;'>WHILE &lt;condition&gt; DO...ENDWHILE</span> or with the <span style='font-family:monospace;'>REPEAT...UNTIL &lt;condition&gt; END REPEAT</span> construct.</div>
<h4 class="subsubsection" id='magicparlabel-205'><span class="subsubsection_label">2.2.1</span> <a id="subsec_UsingRelationalModel" />
Using a Relational Model</h4>
<div class="standard" id='magicparlabel-206'>Relational database systems provide many services and advanced features concerning data storage. Advanced algorithms and data structures provide fast storage of huge amounts of data. Query optimizing utilized to optimize the data retrieval in run-time, depending on the use of the database. Concurrency control mechanisms allow maintaining a high throughput for many concurrent users, and the database system can be tuned to perform optimal in certain scenarios. Further more, the widespread use of database systems has created a large community of users, making it easy to getting started using databases.</div>
<h5 class="paragraph" id='magicparlabel-207'><span class="paragraph_label"></span> Impedance Mismatch</h5>
<div class="standard" id='magicparlabel-208'>However, using a relational database from an object oriented language imposes a different kind of issues, than seen when working with a purely object oriented model. Many of these issues fall under the category known as <em>object-relational impedance mismatch</em>, and are caused by the fact that the two kinds of models are grounded in two different paradigms[<a href='#LyXCite-ireland2009classification'><span class="bib-label">7</span></a>].</div>
<h6 class="subparagraph" id='magicparlabel-209'><span class="subparagraph_label"></span> Classes and Tables</h6>
<div class="standard" id='magicparlabel-210'>First and foremost, it is worth have in mind the difference between object systems and relational systems. The two are two completely different paradigms, i.e. two different ways to view the world. The object oriented model views the world as objects, where an object is an entity having at least the three attributes: identity, behavior and state. An instance of a class is an individual object, and its state is made up of the values of all of its fields. Two classes having the same state might be different identities (residing at different memory locations.) Each class defines a behavior – a set of methods, through which to view or alter its state. Encapsulation secures that the state of an object is only changed by the object itself, or through one of the defined methods. The concept of information hiding lets objects provide a public interface to a hidden implementation, segregating parts of the program implementation from each other. Thus, parts of a program can be changed without other parts of the program ever notices.</div>

<div class="standard" id='magicparlabel-211'>Relational models work differently. Here, tables are named relations of attributes pertaining to a certain type. A relation can be seen as a truth statement, and SQL can be seen as a language for evaluating the state of the universe (e.g. &ldquo;does there exist a user with the first name John, taking the course `Diving for beginners'?&rdquo;)</div>
<h6 class="subparagraph" id='magicparlabel-212'><span class="subparagraph_label"></span> Type System</h6>
<div class="standard" id='magicparlabel-213'>Database systems often has a coarse grained type system, with a few broad types for storing many different kinds of data. For example, <span style='font-family:monospace;'>VARCHAR</span> may be used for strings of any length (although different vendors have different maximum lengths in practice.) The user can store anything that is a string of characters in a <span style='font-family:monospace;'>VARCHAR</span>, whether the column is actually for e-mail addresses or user names. In many applications this is `good enough', as the validity of the strings can be checked by the program that calls the database system, to prevent semantically incorrect data values to be stored. </div>

<div class="standard" id='magicparlabel-214'>Another problem is brought to attention when using an object oriented programming language with arbitrarily complex data types (user defined classes). Since relational databases only allow a small set of primitive types, storing complex data structures requires creating the necessary tables to hold the data. In the host programming language, complex data values must be traversed or unwrapped when constructing a query to persist the object. Likewise, when reading data from the database, data values must be wrapped into an object of the correct type.</div>
<h6 class="subparagraph" id='magicparlabel-215'><span class="subparagraph_label"></span> Performance and Table Design</h6>
<div class="standard" id='magicparlabel-216'>In the article &ldquo;Mapping Objects to Tables – a Pattern Language&rdquo; by Wolfgang Keller [<a href='#LyXCite-keller1997mapping'><span class="bib-label">8</span></a>], it is argued that companies using relational databases over long time, will often meet a need for tuning the database, in order to maximize the performance. Some of this tuning might involve de-normalization of the database schema. Since the overhead lies on the disk search times, not throughput, minimizing the number of accesses to the database increases performance. Such a change could require rewriting a lot of queries in the host program, or the program will need to be redesigned to use dynamic SQL. Depending on the system, it can lead to ripples of changes spreading out, or even changes to legacy code. Further more, it also reduces the maintainability of the database as such.</div>
<h6 class="subparagraph" id='magicparlabel-217'><span class="subparagraph_label"></span> Querying</h6>
<div class="standard" id='magicparlabel-218'>In general, sending queries to a database system from a host language implies sending strings in SQL, which are typically not checked by the host compiler of the host language. This means that errors will be discovered late in the process. Having simple strings means that the user easily can write a malformed query, or misspell a table or column name. The user rarely gets any help from the IDE (for example with resolving names), when writing queries, because it would require an open connection to the database at the time of checking the query. It can lead to work flows where a query is first constructed, then tested in a command line interface, then corrected as needed, before it is inserted into the host program. Further more, even though there is a defined SQL-92 standard, there are different variants of SQL from different database vendors, providing vendor-specific features. This means that it might be difficult to change the database system to one of another vendor.</div>

<div class="standard" id='magicparlabel-219'>However, if embedded SQL is used, a precompiler might be able to check the correctness of queries, and the presence of the tables and attributes given, at compile time.</div>
<h6 class="subparagraph" id='magicparlabel-220'><span class="subparagraph_label"></span> Inheritance</h6>
<div class="standard" id='magicparlabel-221'>Inheritance is one of the most important features of object oriented languages. However, in relational database systems, an inheritance hierarchy has to be modeled over several tables (one table for each class in the inheritance hierarchy.) Each table will then either have all the data of the tables representing super classes, or foreign keys of the table representing its super classes. This leads to the problem of increasing the number of join operations in the database, leading to decreased performance.</div>
<h3 class="subsection" id='magicparlabel-222'><span class="subsection_label">2.3</span> Object Relational Mapping</h3>
<div class="standard" id='magicparlabel-223'>As a mitigation of the problem, <em>object-relational mapping</em> (ORM), seeks to map concepts of one paradigm into concepts of the other paradigm. ORM tools serve to automate parts of this process, mapping classes in the host language to tables in a relational database, objects to rows, and fields to columns. However, it can be argued that ORM only solves part of the problems of impedance mismatch, and that it even creates new problems by its own[<a href='#LyXCite-vietnam2007'><span class="bib-label">1</span></a>].</div>
<h5 class="paragraph" id='magicparlabel-224'><span class="paragraph_label"></span> Implementations</h5>
<div class="standard" id='magicparlabel-225'>There are many implementations of ORM systems, but some of the most well-known are the &ldquo;Entity Data Model&rdquo; from Microsoft, and the open-source project &ldquo;Hibernate&rdquo; for Java[<a href='#LyXCite-o2008object'><span class="bib-label">9</span></a>]. </div>
<h5 class="paragraph" id='magicparlabel-226'><span class="paragraph_label"></span> Entity classes</h5>
<div class="standard" id='magicparlabel-227'>In Hibernate, annotations are used to mark &ldquo;entity classes&rdquo; (also called &ldquo;domain classes&rdquo; or &ldquo;persistent objects&rdquo;). In our example with the diving school, a Person domain class would look somewhat as shown in Listing .</div>

<div class="standard" id='magicparlabel-232'>The <span style='font-family:monospace;'>@Entity</span> and <span style='font-family:monospace;'>@Id </span>annotations are part of the Java Persistence API. In order to let Hibernate recognize the class as a persistence class, an instance of a configuration object must be created, given a reference to <span style='font-family:monospace;'>Person.class</span>. Using reflection, Hibernate will traverse the list of annotations for the class, and communicate with the database, in order for it to create a Person table. An alternative to using annotations is to supply an external mapping file.</div>

<div class="standard" id='magicparlabel-254'>When the class structure is created, it is possible to create one-one, one-many or many-many relationships between classes, by specifying fields, and annotatingg them with names of join columns or tables. In listing , we show how the relationship between Course and Student are created. For the sake of simplicity, the example only show a small part of the full classes. The class Student shows a one-to-one relationship between Student and Person. Both the Student class and the Course class shows a many-to-many relationship with each other, with the specification of a join table and join columns.</div>



<div class="standard" id='magicparlabel-300'>By specifying the classes in this way, standard Java methods are used to retrieve data, simply by &ldquo;dotting&rdquo; through (like for example <span style='font-family:monospace;'>student.getCourses()</span>, or <span style='font-family:monospace;'>courses.getTeacher().getPerson().getName()</span>, etc.)</div>

<div class="standard" id='magicparlabel-301'>New entities are created by creating a new instance of a class, and then saving it using a Session-object, provided by a SessionFactory. Using a Session, the user has to call methods to begin a transaction, to actually save the new data, and to commit the transaction.</div>

<div class="standard" id='magicparlabel-302'>Further more, it is also possible to write standard SQL queries:</div>



<div class="standard" id='magicparlabel-314'>Both Hibernate and Entity Data Model operate with what is called an entity context. It can be seen as an environment, within which transactions are being run. The before mentioned Session class in Hibernate, acts as an entity context. The role of the entity context is to provide a closed environment, within which a thread can operate safely. In Hibernate, a session can be given to each thread that wants to operate on data. The sessions provide a mechanism of caching the recently accessed rows, so access to popular data is sped up, though always persisting data on the database when needed.</div>
<h4 class="subsubsection" id='magicparlabel-315'><span class="subsubsection_label">2.3.1</span> Using ORM</h4>
<div class="standard" id='magicparlabel-316'>Using object-relational mapping imposes many of the problems described in section <a href="#subsec_UsingRelationalModel">2.2.1</a> &ldquo;Using a Relational Model&rdquo;, because the issues are pertaining to the fact that there is a difference in the two paradigms. ORM tools helps automating parts of the solution to some of the problems, but it doesn't make the problems disappear. Some problems that are pointed out in [<a href='#LyXCite-vietnam2007'><span class="bib-label">1</span></a>] relate to maintenance.</div>

<div class="standard" id='magicparlabel-317'>Having both an object-based model and a relational model implies having to maintain two parallel models. Changes in one model, either because of changes in the conceptual model, or changes related to performance optimization, must be reflected in the other model. This makes refactoring and schema updates rather complicated, especially if the relational model is used by many different programs[<a href='#LyXCite-vietnam2007'><span class="bib-label">1</span></a>]. Further more, having to create mapping files or annotate classes complicates the process, if the table design changes often, as a result of being in a prototyping phase, or if business requirements are not fixed.</div>
<h3 class="subsection" id='magicparlabel-318'><span class="subsection_label">2.4</span> Summary</h3>
<div class="standard" id='magicparlabel-319'>Many of today's popular object oriented programming languages (such as Java) are not well suited for creating searchable, persisted data models, and the creation of such a model involves a lot of tedious hand-coding. Using relational models imposes a new category of problems, relating to the mismatch of coupling the two different paradigms. Object oriented languages send string objects, containing queries, to a database management system for data retrieval and manipulation. Not being able to call the storage system like a normal object results in inflexible designs. </div>


<h2 class="section" id='magicparlabel-322'><span class="section_label">3</span> Problem Analysis</h2>
<h3 class="subsection" id='magicparlabel-323'><span class="subsection_label">3.1</span> Identifying the problem</h3>
<div class="standard" id='magicparlabel-324'>An abstract or conceptual data model is often a good place to start, when modeling objects and concepts from real or fantasy worlds. The conceptual data model describes the different kinds of entities in the model and the relations between them.</div>

<div class="standard" id='magicparlabel-325'>From our experience with programming we have noticed, that in the process of moving from a conceptual data model in a specific domain into an actual working implementation of the model, there are a number of hurdles that slows down the process:</div>

<ol class="enumerate" id='magicparlabel-326'><li class="enumerate_item"><b>The amount of code</b>
<br />

The amount of code it takes to implement a conceptual data model in a typical object oriented language is much larger than the description of the conceptual model. Even with the help of copy-paste and modern IDEs with code templates and code completion, it still takes quite some time to write the code.</li>
<li class="enumerate_item"><b>Implementation of bi-directional entity-relationships</b>
<br />

In a conceptual or abstract data model an entity-relationship is a relationship between two entity kinds. e.g. a student can be enrolled on a course. This is a many-to-many relationship, meaning that there can be many different students enrolled on the same course and a student can be enrolled on many different courses.
<br />

This could be implemented by adding a set of students to the course class and create methods to add and remove students. But if you then want the courses that a specific student is enrolled on, you would have to go through all the courses and lists of students. Therefore one would most often also add a set of courses to the student class, and make sure that this set is updated when a student is added to or removed from a course.</li>
<li class="enumerate_item"><b>Accessing instances of the model from remote locations</b>
<br />

Many software systems are distributed on several different machines and thus needs to communicate over the boundaries of different VMs and physical machines. This means that data must be serialized and de-serialized preferably in a seamless manner. Even though there exists tools like Java RMI that can automate some of this process, it still takes time configure and use these tools.</li>
<li class="enumerate_item"><b>Providing user interfaces for data input</b>
<br />

Software systems often interact with humans and must provide interfaces that can give information to and get information from humans.</li>
<li class="enumerate_item"><b>Thread-safe access to the model instances in a multithreaded environment</b>
<br />

The programming of concurrent programs is always an interesting task. Errors occurring from race conditions, dead locks etc. are often hard to detect and can reside in the system undetected for a long time before they suddenly surfaces and cause havoc[<a href='#LyXCite-sutter2007software'><span class="bib-label">11</span></a>].</li>
<li class="enumerate_item"><b>Persistence of the instances of the model (if needed)</b>
<br />

There are many ways to obtain persistence of data models from object oriented languages and most of them involves the installation and use of some sort of external relational database. The mapping between the object oriented model and relational model can either be done by hand or some sort of object relational mapping system can be used.
<br />

However, using a relational database system introduces a number of issues related to the impedance mismatch of the object paradigm and the relational paradigm. The data types in the two types of systems are often incompatible, and difficult to map without imposing a significant overhead[<a href='#LyXCite-ireland2009classification'><span class="bib-label">7</span></a>, <a href='#LyXCite-keller1997mapping'><span class="bib-label">8</span></a>, <a href='#LyXCite-vietnam2007'><span class="bib-label">1</span></a>, <a href='#LyXCite-subramanian1999performance'><span class="bib-label">10</span></a>].</li>
</ol>
<div class="standard" id='magicparlabel-332'>Although all the mentioned hurdles can be overcome, we are lazy programmers and we agree with what Terence Parr, the creator of ANTLR (Another Tool For Language Recognition), has made his guidance principle: </div>

<blockquote class="quotation" id='magicparlabel-333'><div class="quotation_item">Why program by hand in five days what you can spend five years of your life automating?</div>
</blockquote>
<h4 class="subsubsection" id='magicparlabel-334'><span class="subsubsection_label">3.1.1</span> Problem Restrictions</h4>
<div class="standard" id='magicparlabel-335'>This thesis is not about creating a fast and efficient database system that can store large amounts of data. There are already many good solutions to this problem backed by decades of research and development on the market, and we have no intentions of competing with those.</div>
<h3 class="subsection" id='magicparlabel-336'><span class="subsection_label">3.2</span> Solving the problem</h3>
<div class="standard" id='magicparlabel-337'>We intend to solve the problem by building a software system that should take as input:</div>

<ul class="itemize" id='magicparlabel-338'><li class="itemize_item">A definition of a conceptual data model.</li>
<li class="itemize_item">A definition of an interface to the data model.</li>
</ul>
<div class="standard" id='magicparlabel-340'>The system should then generate the following:</div>

<ul class="itemize" id='magicparlabel-341'><li class="itemize_item">Java Interfaces and classes that represents an object oriented representation of the data model.</li>
<li class="itemize_item">A java interface that reflects the defined interface to the data model.</li>
<li class="itemize_item">Java stub classes where the user can implement the domain specific methods of the generated data model interface, by using the generated object oriented representation of the data model.</li>
<li class="itemize_item">A server program and a client proxy that implements the interface to the data model, so the instances of the data model can be accessed seamlessly over a socket connection.</li>
<li class="itemize_item">A text based user interface that lets a human user invoke the methods in the interface to the data model.</li>
</ul>
<div class="standard" id='magicparlabel-346'>When the user have implemented the interface to data model, he should be able to create instances of the data model that obey the following requirements:</div>

<ul class="itemize" id='magicparlabel-347'><li class="itemize_item">They must be thread safe. By this we mean that the instance should act in every respect as if all the methods in the interface where synchronized on the same object.</li>
<li class="itemize_item">Upon the creation of a data model instance it should be possible to choose to have the instance persisted. If this option is chosen, the instance must be automatically persisted in a durable way, meaning that when a call to a method in the data model interface returns successfully the state known by the calling thread immediately before the return should be persisted successfully.</li>
<li class="itemize_item">The methods in the interface to the data model must be executed atomically. By this we mean that when the user implements the methods, he should be given the opportunity to automatically roll back at any point during the execution, if the execution cannot be completed successfully. This should then bring the data model instance back to the same state it had upon the beginning of the execution.</li>
</ul>
<div class="standard" id='magicparlabel-350'>We will call the system Effective Data Model Abstraction (EDMA).</div>

<div class="standard" id='magicparlabel-351'>We will develop the system using a modular interface based design, so the individual parts of the system can easily be replaced with alternative implementations.</div>

<div class="standard" id='magicparlabel-352'>Instead of auto-generating all the code that is needed to implement a specific data model, we will create a general runtime interface that are independent of the specific data models. We will then only auto-generate interfaces and binding code that binds the generated data model specific interfaces to the general runtime interface.</div>

<div class="standard" id='magicparlabel-353'>We will strive to design the runtime interface in a way that gives the maximum possible flexibility in how different implementations handle the defined requirements on the data model instances. In this way we are using our best effort to abstract the data models away from the underlying technology, thus decoupling the data model design and business logic from the applied technology.</div>

<div class="standard" id='magicparlabel-354'>With this design we are still strongly bound to the Java language, since the user must implement the data model interface in Java. One way to get around this, would be to design a language for interacting with a conceptual data model and then have the user implement the interface in this language and translate it to various target languages. But then we could not benefit from the highly specialized Java IDEs that makes coding fun and enjoyable.</div>
<h5 class="paragraph" id='magicparlabel-355'><span class="paragraph_label"></span> Data Values</h5>
<div class="standard" id='magicparlabel-356'>In a data model we have different kinds of entities, each kind of entity defines some attributes that can hold values in an entity instance. These values can be different in each entity instance, but they will have the same meaning and type across all the entity instances. As an example a kind of entity could be Person and have the attribute name of type string. Then all Person instances would have a value of type string. The values could be different in the instances but they would all represent the name of the Person instance. It would not make sense to store an email address or an URL in that value, although the type system would allow it because they are all strings. The type string refer to an underlying representation of the value and is not a very abstract concept. Instead the name of a Person should have the type PersonName and the email address should have the type EmailAddress and it should not be possible to store a persons name in an attribute with the type EmailAddress. This would be a much more fine grained type system.</div>

<div class="standard" id='magicparlabel-357'>As a part of the EDMA System we will define a fine grained data type system for arbitrary complex, but immutable data values, where the user can define his own semantically unique data types with build-in validation for a specific domain. We will call this the value domain system. The value domain system will give us several advantages:</div>

<ul class="itemize" id='magicparlabel-358'><li class="itemize_item">It can be used as an infrastructure for moving data between different applications and data model instances. In this way all mutable state can be contained inside data model instances and everything outside is immutable. This makes it simple to distribute data model instances seamlessly in a distributed system.</li>
<li class="itemize_item">It lets the java compiler find a new category of semantic errors for example if an email is used in the place of a name, because even though they are both strings, they will have different types in the value domain system and thus be represented by different Java classes.</li>
<li class="itemize_item">It adds useful domain specific semantic information to the interfaces of the data models.</li>
<li class="itemize_item">It adds useful domain specific semantic information to the meta model, that a code generator can use to auto generate utility programs that are specialized to work on a specific data model within a specific domain.</li>
</ul>
<div class="standard" id='magicparlabel-362'>We will try to keep the generated and the user written code as separated as possible. When there is a need to embed user written code into a generated file, that file should be kept to a minimum size, merely functioning as a container for the user written code. We will also strive to generate code that looks and feels like well-written, handmade code including javadoc.</div>
<h3 class="subsection" id='magicparlabel-363'><span class="subsection_label">3.3</span> Related Work</h3>
<h5 class="paragraph" id='magicparlabel-364'><span class="paragraph_label"></span> Entity-Relationship model</h5>
<div class="standard" id='magicparlabel-365'>Our meta data model is heavily inspired by the entity-relationship model (ER model). The ER model is an abstract and conceptual way of representing a data model[<a href='#LyXCite-chen1976entity'><span class="bib-label">5</span></a>]. The main concepts in the ER model are entities and the relationships between them. The ER model strives to be a representation of the data model that is close to the human perception of the data model and is not concerned with how the data is physically stored.</div>
<h5 class="paragraph" id='magicparlabel-366'><span class="paragraph_label"></span> Apache Torque</h5>
<div class="standard" id='magicparlabel-367'>Apache Torque is an object-relational mapper for Java, that also uses the idea of auto-generating the object oriented model instead of having the user write it by hand and use annotations for the mapping[<a href='#LyXCite-torque'><span class="bib-label">3</span></a>].</div>

<div class="standard" id='magicparlabel-368'>In Torque the user defines the data model in an XML schema and Torque then generates both the object oriented model, the database schemes and the binding between the object oriented model and the relational database. Torque can also generate the XML schema from an existing database model.</div>
<h5 class="paragraph_" id='magicparlabel-369'>Eclipse Modeling Framework</h5>
<div class="standard" id='magicparlabel-370'>Some inspiration for EDMA came from working with the Eclipse Modeling Framework (EMF) in a model driven develop course. The Eclipse Modeling Framework is a huge framework with a lot of useful functionality. Unfortunately we did not feel that it was very pleasant to work with. As an example, data models in the eclipse framework are defined in an XML-based language called XMI. For a simple <em>book</em> class with a <em>title</em> attribute and a <em>pages</em> attribute the definition looks like this:</div>


<div class='float-listings'><pre class ='listings'>&lt;/xsd:schema&gt;&lt;ecore:EPackage xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:ecore="http://www.eclipse.org/emf/2002/Ecore"
  name="library "nsURI="http:///library.ecore" nsPrefix="library"&gt;
&lt;eClassifiers xsi:type="ecore:EClass" name="Book"&gt;
  &lt;eStructuralFeatures xsi:type="ecore:EAttribute" name="title"
      eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EString"/&gt;
  &lt;eStructuralFeatures xsi:type="ecore:EAttribute" name="pages"
      eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EInt"/&gt;
&lt;/eClassifiers&gt;
&lt;/ecore:EPackage&gt;</pre></div>


<div class="standard" id='magicparlabel-386'>It is also possible to define data models through commercial graphical modeling tools or annotated java files.</div>

<div class="standard" id='magicparlabel-387'>The EMF auto-generates a lot of Java code that the user is supposed to make changes to or inherit from. This quickly becomes very large files with mixed usercode and generated code where one can easily get lost.</div>



<h2 class="section" id='magicparlabel-407'><span class="section_label">4</span> EDMA System Design</h2>


<div class="standard" id='magicparlabel-409'>The EDMA system consists of the following main components:</div>

<ul class="itemize" id='magicparlabel-410'><li class="itemize_item">A simple <em>domain specific language</em> for defining value domains, the structure of the data model and the interface for the data model.</li>
<li class="itemize_item">A <em>compiler</em> to transform the definition files into an instance of a <em>meta model.</em></li>
<li class="itemize_item">A <em>generator</em> that uses the <em>meta model</em> instance to create: 
<br />



<ul class="itemize" id='magicparlabel-413'><li class="itemize_item">An internal Java API for the data model that reflects the structure of the data model. This API functions as an embedded DSL in java.</li>
<li class="itemize_item">An external interface to the data model that applications can use to communicate with the data model through.</li>
</ul>
</li><li class="itemize_item">A <em>runtime system</em> used by the internal API to handle transaction control and persistence.</li>
</ul>
<div class="standard" id='magicparlabel-416'>The interface to the runtime system has been designed to allow flexibility in the concrete implementations of the runtime system.</div>

<div class="standard" id='magicparlabel-417'>This means that different runtime systems can deploy different strategies for transaction control, data storage and persistence and the user can switch between different runtime systems without making any changes to his code.</div>

<div class="standard" id='magicparlabel-418'>Figure  shows an overview of the EDMA system.</div>



<div class="standard" id='magicparlabel-435'>We have taken an object oriented approach where the data model can be seen as a class where the structure of the data model is encapsulated from the outside world. The external interface of the data model is the public part that external applications can use. As with classes in object oriented languages, there can be several independent instances of the same data model.</div>

<div class="standard" id='magicparlabel-436'>Each method in the external interface represents a transaction on the data model. The semantic of the external interface is as if each of these methods where synchronized on the same object. The individual runtime system implementations may use more clever algorithms for concurrency control, as long as the illusion of complete mutual exclusion is kept intact. This analogy is used in order to keep focus on the object oriented approach, instead of a traditional database approach.</div>

<div class="standard" id='magicparlabel-437'>The methods of the external interface are divided in two groups, <em>views</em> and <em>actions</em>. Views cannot change the state of the data model instance, only read it (this resembles const methods in C++). Actions can both read and change the state of the instance.</div>

<div class="standard" id='magicparlabel-438'>In the following, we will describe the four main components in further detail, starting with the meta model – a very central element in the EDMA system. Thereafter, we describe the compiler and the generator, followed by a description of the example runtime system.</div>

<h3 class="subsection" id='magicparlabel-441'><span class="subsection_label">4.1</span> <a id="subsec_Value_domains" />
Value Domains</h3>
<div class="standard" id='magicparlabel-442'>In most relational database systems, many different types of values share the same data type. A person's name, an e-mail address, and a URL could all have the same data type, e.g. <span style='font-family:monospace;'>VARCHAR</span>. This means that the type system is coarse grained, and it doesn't hinder the user in storing, for example an e-mail, as a person's name.</div>

<div class="standard" id='magicparlabel-443'>In EDMA, we want to create a fine grained type system, where for example an e-mail address, and a person's name belong to different types. We call these types <em>value domains</em>.</div>

<div class="standard" id='magicparlabel-444'>In EDMA we encourage the user to create a distinct value domain for each semantically unique type. This not only adds useful semantic information to the users of the value domains, it also makes the type system able to discover a category of semantic errors, like if an email address is accidentally used in place of a name or a URL.</div>
<h5 class="paragraph" id='magicparlabel-445'><span class="paragraph_label"></span> Immutability</h5>
<div class="standard" id='magicparlabel-446'>In a multithreaded environment, mutable objects must be protected from race conditions, that can lead to threads seeing them in an inconsistent state. For immutable objects this is not a problem, since they can never change after they have been created. Therefore they will always be in a consistent state (provided that they where created in a consistent state). Also, it is never necessary to make defensive copies of immutable values, and all values that are equal can be represented by the same instance. For immutable values, the problem of accidental aliasing is also non-existing[<a href='#LyXCite-hogg1992geneva'><span class="bib-label">6</span></a>]. For these reasons, in EDMA, all values (instances of value domains) are immutable.</div>
<h5 class="paragraph" id='magicparlabel-447'><span class="paragraph_label"></span> Value Domain Constraints</h5>
<div class="standard" id='magicparlabel-448'>The value domain system allows adding constraints to the value domains. These constraints are automatically checked every time a new value is created. As an example, the user can add a constraint to the value domain <span style='font-family:monospace;'>EmailAddress</span>, that checks that the content matches a regular expression for accepted email addresses. </div>

<div class="standard" id='magicparlabel-449'>There are two types of constraints on the value domains: <em>Simple constraints</em> and <em>user implemented constraints</em>. The simple constraints regard lengths and contents of strings, and numerical ranges for numeric types. The user implemented constraints are, as the name suggests, implemented by the user and can therefore be arbitrarily complex.</div>

<div class="standard" id='magicparlabel-450'>By defining constraints on the value domains the system can automatically validate values when they are created.</div>
<h5 class="paragraph" id='magicparlabel-451'><span class="paragraph_label"></span> Primitive Value Domains</h5>
<div class="standard" id='magicparlabel-452'>Value domains can be defined from the simple value domain types: <span style='font-family:monospace;'>String</span>, <span style='font-family:monospace;'>Integer</span>, <span style='font-family:monospace;'>Long</span>, <span style='font-family:monospace;'>Float</span>, <span style='font-family:monospace;'>Double</span>, <span style='font-family:monospace;'>Boolean</span> and <span style='font-family:monospace;'>Enum</span>. Since we encourage the user to create a fine-grained set of semantically unique value domains, the primitive types can not be used directly, only in the definition of other value domains.</div>
<h5 class="paragraph" id='magicparlabel-453'><span class="paragraph_label"></span> Composed Value Domains</h5>
<div class="standard" id='magicparlabel-454'>It is possible to construct more complex value domains from the simpler ones. For this purpose we have 3 different composable value domain types: <span style='font-family:monospace;'>Struct</span>, <span style='font-family:monospace;'>List</span> and <span style='font-family:monospace;'>OneOf</span>.</div>
<h5 class="paragraph" id='magicparlabel-455'><span class="paragraph_label"></span> Struct</h5>
<div class="standard" id='magicparlabel-456'>The <span style='font-family:monospace;'>Struct</span> value domain type consists of a number of attributes, each of which has a name and a value domain. The struct value domain type can therefore be seen as a container of multiple values, each given a name. An example of a struct value domain, could be a <span style='font-family:monospace;'>Date</span>, containing a <span style='font-family:monospace;'>Day</span>, a <span style='font-family:monospace;'>Month</span> and a <span style='font-family:monospace;'>Year</span>. The attributes in a struct value domain can be declared optional, which means that the value might be <em>null</em>.</div>
<h5 class="paragraph" id='magicparlabel-457'><span class="paragraph_label"></span> List</h5>
<div class="standard" id='magicparlabel-458'>A <span style='font-family:monospace;'>List</span> value domain type contains a number of values from another value domain. For example, a value domain <span style='font-family:monospace;'>NameList</span> could be a list of <span style='font-family:monospace;'>Name</span>s.</div>
<h5 class="paragraph" id='magicparlabel-459'><span class="paragraph_label"></span> OneOf</h5>
<div class="standard" id='magicparlabel-460'>A <span style='font-family:monospace;'>OneOf</span> value domain type contains a value from one of a predefined set of value domains. An example could be a value domain <span style='font-family:monospace;'>Pet</span>, which can hold the value of either a <span style='font-family:monospace;'>Dog</span>, <span style='font-family:monospace;'>Cat</span>, or <span style='font-family:monospace;'>Fish</span>. Thus the OneOf value domain type adds polymorphism to the value domain system. </div>
<h5 class="paragraph" id='magicparlabel-461'><span class="paragraph_label"></span> Structurally Recursive Value Domains</h5>
<div class="standard" id='magicparlabel-462'>Value domains can be structurally recursive, meaning that for example a value domain <span style='font-family:monospace;'>Person</span> could contain a friend list of <span style='font-family:monospace;'>Person</span> values. But values (instances of value domains) are always tree-structures and cannot contain loops or recursive references. In the above example a person value cannot be in its own friend list. This is enforced by the immutability of the values. It is only possible to construct values from already created values, so all values are tree-structures that are constructed in a bottom-up process. This means that it is possible to define value domains where it would never be possible to create a value from that value domain. </div>

<div class="standard" id='magicparlabel-463'>An example would be a Struct value domain <em>A</em> that contains a field <em>b</em> from value domain <em>B</em> where the <em>B</em> value domain is a Struct containing a field <em>a</em> from value domain <em>A</em>. You would need a value from value domain <em>B</em> to create a value from value domain <em>A</em>, but to create a value from value domain <em>B</em> you need a value from value domain <em>A</em>. One way to solve this deadlock is to make at least one of the fields <em>a</em> or <em>b</em> optional. The EDMA compiler will detect impossible value domains and complain about them. This is done by checking that all recursive paths contains an optional field, a list that may be empty or a OneOf with a choice that breaks the loop.</div>

<div class="standard" id='magicparlabel-464'>There are advantages in having values that are guaranteed to be tree structures and therefore self-contained and loop-free. This makes processing values much simpler and the risk of entering an infinite loop while processing values is greatly reduced. This also makes it simple to move values across different borders of JVMs, machines, languages etc.</div>

<div class="standard" id='magicparlabel-465'>It is worth to notice here that it <em>is</em> possible to create a value domain that represents a general graph by using indexes into lists as references. However as long as the value domain contains both the indexes and the lists they index into, this approach does not break the self-contained and loop-free properties of the value domain.</div>
<h5 class="paragraph" id='magicparlabel-466'><span class="paragraph_label"></span> Expressiveness</h5>
<div class="standard" id='magicparlabel-467'>The value domain system is expressive enough to model itself as seen in the following listing:</div>


<div class='float-listings'><pre class ='listings'>ValueDomain MetaValueDomainSystem :
	List&lt;MetaValueDomain&gt; Constraints[noDuplicateOrMissingOrImpossible]
ValueDomain MetaValueDomain :
	Struct {name : UIdentifier, type : MetaValueDomainType, constraintList : ConstraintList}
ValueDomain MetaValueDomainType:
	OneOf&lt;MetaPrimitiveType, MetaStructType, MetaListType, MetaOneOfType&gt;
ValueDomain MetaPrimitiveType :
	OneOf&lt;MetaStringType, MetaIntegerType, MetaFloatType, MetaBooleanType, MetaEnumType&gt;
ValueDomain MetaStructType :
	List&lt;MetaAttribute&gt; Constraints[uniqueAttNames]
ValueDomain MetaAttribute :
	Struct {attName : LIdentifier, attValueDomain : UIdentifier, isOptional : TrueFalse}
ValueDomain MetaListType :
	Struct {elementValueDomain : UIdentifier, minLength : NotNegInt, maxLength : NotNegInt} Constraints[listMinLTEMax]
ValueDomain MetaOneOfType : List&lt;UIdentifier&gt;[1..MAX]
ValueDomain MetaStringType :
	Struct {minLength : NotNegInt, maxLength : NotNegInt, regexp? : Regexp} Constraints[stringMinLTEMax]
ValueDomain MetaIntegerType :
	Struct {min : AnyInt, max : AnyInt} Constraints[integerMinLTEMax]
ValueDomain MetaFloatType :
	Struct {min : AnyFloat, max : AnyFloat} Constraints[floatMinLTEMax]
ValueDomain MetaBooleanType :
	Struct {restrictedValue? : TrueFalse}
ValueDomain MetaEnumType : List&lt;UIdentifier&gt;

ValueDomain LIdentifier : String[1..MAX]["[a-z][A-Za-z0-9]*"]
ValueDomain UIdentifier : String[1..MAX]["[A-Z][A-Za-z0-9]*"]
ValueDomain TrueFalse : Boolean
ValueDomain AnyInt : Integer[MIN..MAX]
ValueDomain NotNegInt : Integer[0..MAX]
ValueDomain AnyFloat : Float[MIN..MAX]
ValueDomain Regexp : String[0..MAX]
ValueDomain ConstraintList : List&lt;LIdentifier&gt;</pre></div>


<div class="standard" id='magicparlabel-505'>This makes it possible to create a value that represents a value domain system for a specific domain, and use it as any other value in the system e.g. use it in kind attributes, move it across socket connections etc. It is also possible to model the meta model in the value domain system, in this way an entire data model instance can be stored as a single value.</div>
<h3 class="subsection" id='magicparlabel-506'><span class="subsection_label">4.2</span> <a id="sec_MetaModel" />
Meta Model</h3>
<div class="standard" id='magicparlabel-507'>The EDMA meta model is the central model that everything else in EDMA is built around. The meta model is used to describe the individual data models. An instance of the meta model represents a specific user defined data model.</div>

<div class="standard" id='magicparlabel-508'>Since the meta model has many different elements, it is described in a bottom-up fashion, starting with the most low-level definitions first, gradually adding complexity as we go along.</div>


<h4 class="subsubsection" id='magicparlabel-519'><span class="subsubsection_label">4.2.1</span> Kinds and Entities</h4>


<div class="standard" id='magicparlabel-532'>In EDMA a <em>kind</em> is both a data type and a container of all instances of that type. A kind has a set of <em>attributes</em>, where each attribute has a name and a value domain. An <em>entity</em> is an instance of a kind. As an example we could have a person kind with attributes like name, gender, birth date, email and phone number. A person entity would then contain a value for each of the attributes in the person kind. Each attribute in a kind can be either mutable or immutable. If it is immutable then a value for the attribute is set upon creation of an entity, but this value can never change throughout the lifetime of the entity. An attribute can be optional, which means that the value corresponding to that attribute may be <em>null</em>. All kinds in EDMA have an attribute called ID, which is a positive integer that uniquely identifies each <em>entity</em> in the kind.</div>
<h4 class="subsubsection" id='magicparlabel-533'><span class="subsubsection_label">4.2.2</span> Relations and Connections</h4>
<div class="standard" id='magicparlabel-534'>Assume that we have a person kind and a course kind, and we want to be able to express that a person is a student on a course. In EDMA we call this a <em>relation</em> between the person kind and the course kind. When there is a <em>relation</em> between the person kind and the course kind, it is possible to make a <em>connection</em> between a specific person entity and a specific course entity. A <em>relation</em> is both a description of possible <em>connections</em> between entities and a container for these <em>connections</em>.</div>


<h6 class="subparagraph" id='magicparlabel-545'><span class="subparagraph_label"></span> Roles</h6>
<div class="standard" id='magicparlabel-546'>A <em>relation</em> always has two participants, which we can call A and B. Both A and B are defined by a <em>kind</em> and a <em>role</em>. The reason for having roles is that we can have different relations, which involve the same kinds, in which case we use the roles to distinguish them. In the example with the Person kind and the Course kind, we could have two different relations between them: One that represents students that are enrolled on the course, and one that represents teachers that teach the course. To distinguish the two different <em>relations</em>, the role of the person would be <em>student</em> in the one relation, and <em>teacher</em> in the other. </div>



<div class="standard" id='magicparlabel-557'>It is also possible to have relations, where both the kind and the role would be the same for A and B. An example could be a friendship relation, where the kind is person and the role is friend for both A and B, this type of relation we call a self-relation. If we have a relation where A and B has the same kind, but different roles, then it is not a self relation. An example of this could be where A and B both are persons, but where the role of A is parent and the role of B is child. In a self-relation, the order of the participants are irrelevant, so if we have person a and person b, then &ldquo;a is friends with b&rdquo; is the same as &ldquo;b is friends with a&rdquo;, but there is a difference between &ldquo;a is parent of b&rdquo; (or &ldquo;b is child of a&rdquo;) and &ldquo;b is parent of a&rdquo; (or &ldquo;a is child of b&rdquo;).</div>
<h6 class="subparagraph" id='magicparlabel-558'><span class="subparagraph_label"></span> Multiplicities</h6>
<div class="standard" id='magicparlabel-559'>We also distinguish between many-to-many, many-to-one and one-to-one relations (we do not have a one-to-many relation as this is the same as a many-to-one where A and B are switched). It is worth to notice that a many-to-one self-relation does not make any sense, so this leaves us with five different types of relations:</div>

<ol class="enumerate" id='magicparlabel-560'><li class="enumerate_item">Many-To-Many (MTM)</li>
<li class="enumerate_item">Many-To-Many-Self (MTMS)</li>
<li class="enumerate_item">Many-To-One (MTO)</li>
<li class="enumerate_item">One-To-One (OTO)</li>
<li class="enumerate_item">One-To-One-Self (OTOS)</li>
</ol>
<div class="standard" id='magicparlabel-565'>So, a relation in EDMA contains the following information: a name, the kind of A, the role of A, the kind of B, the role of B, the type of the relation (one of the five types above). If a role is not defined on one of the participants, the role is set to the same as the name of the participating kind. For example, in the relations shown on Figure&nbsp;, the role of the Course is simply ``course''. In the five relation types above, <em>many</em> actually means <em>0 or more</em> and <em>one</em> actually means <em>0 or 1</em>.</div>

<div class="standard" id='magicparlabel-570'>A <em>connection</em> is an instance of a relation and can be thought of as a set of pairs of ids (a, b). Each element in the set represents the connection between an entity from kind A and an entity from kind B with the ids a and b respectively. In a self-relation (a, b) is the same as (b, a).</div>
<h6 class="subparagraph" id='magicparlabel-571'><span class="subparagraph_label"></span> Extension</h6>


<div class="standard" id='magicparlabel-581'>There is actually a sixth relation type, which we call <em>extension</em>. An extension between kinds is a 1-to-(0 or 1) relation between two different kinds. As an example we could have a kind, Person, and another kind, Student, which extends Person. This means that every student is also a person, so in order to create a new student, you would need to provide an already existing person, that is not already a student. We could also have another kind, Teacher, that also extends Person. Then every teacher would also be a person, and a person could be both a teacher and a student, or only one of them, or neither. In our running example with the diving school, we have shown the kinds Student and Teacher that both extend the kind Person.</div>
<h4 class="subsubsection" id='magicparlabel-582'><span class="subsubsection_label">4.2.3</span> Indexes</h4>
<div class="standard" id='magicparlabel-583'>In EDMA indexes are used for two different purposes: To enforce uniqueness of certain attributes within all entities of a kind, and to gain fast and easy access to certain entities, or sets of entities. Indexes can either be declared on a kind, in which case they cover all entities of that kind, or they can be declared on a relation, in which case they cover only sets of entities, that are grouped by that relation. EDMA supports three types of indexes: <em>Unique</em>, <em>Equal</em> and <em>Compare</em>. </div>
<h6 class="subparagraph" id='magicparlabel-584'><span class="subparagraph_label"></span> Unique index</h6>
<div class="standard" id='magicparlabel-585'>The <em>unique index</em> is used to enforce uniqueness of one attribute or a combination of attributes within all entities of a kind, or within sets of entities grouped by a relation. The unique index also gives a fast search mechanism using the attributes in the index. </div>

<div class="standard" id='magicparlabel-586'>As an example, we could have a Person kind with attributes <span style='font-family:monospace;'>firstName</span> and <span style='font-family:monospace;'>lastName</span>. If we declared a <em>unique</em> index on (<span style='font-family:monospace;'>firstName</span>, <span style='font-family:monospace;'>lastName</span>) in the person kind, then this would enforce the uniqueness of the combination of first name and last name, across all person entities. If we were to create a person with a name that were already taken, we would get an exception. If instead we declared the index on a relation that connects persons and courses, then we could have two or more persons with the same name, but they could not attend the same course, because the index would cover every set of persons connected to the same course.</div>

<div class="standard" id='magicparlabel-587'>In the example with the unique index on first name and last name, it is very fast to get access to a specific person entity, given that you know the first name and last name.</div>
<h6 class="subparagraph" id='magicparlabel-588'><span class="subparagraph_label"></span> Equals index</h6>
<div class="standard" id='magicparlabel-589'>The <em>equal index</em> does not enforce any constraints, but are used to get fast access to sets of entities, where the involved attributes are equal to a certain value. As an example we could have an equal index on the attribute <span style='font-family:monospace;'>firstName</span>, making it very fast to find all entities with a specific first name.</div>
<h6 class="subparagraph" id='magicparlabel-590'><span class="subparagraph_label"></span> Compare index</h6>
<div class="standard" id='magicparlabel-591'>Like the equal index, the<em> compare index</em> does not enforce any constraints, but are only used to speed up certain searches among entities. With a compare index, it is not only possible to search for entities where the involved attributes are equal to some value. It is also possible to find sets of entities, where the involved attributes are less than a given value, greater than a given value or within a range. The compare index uses the natural order of the value domains.</div>
<h4 class="subsubsection" id='magicparlabel-592'><span class="subsubsection_label">4.2.4</span> Singletons</h4>
<div class="standard" id='magicparlabel-593'>Singletons are very similar to kinds, except that they contain exactly one entity. If a singleton defines non-optional attributes, the values for these attributes most be provided upon creation of the data model instance. It is worth to note here that singletons are singletons on the data model <em>instance</em> level, not on the data model level.</div>
<h4 class="subsubsection" id='magicparlabel-594'><span class="subsubsection_label">4.2.5</span> Actions and Views</h4>
<div class="standard" id='magicparlabel-595'>Kinds and relations make up the structure of the data model. Actions and views make up the external interface to the data model. Actions can both read and change the state of the data model instances, views can only read the state. We call both actions and views <em>methods</em> if we do not need to distinguish between them.</div>

<div class="standard" id='magicparlabel-596'>Methods have a set of input and output parameters, each having a name and a value domain. Both input parameters and output parameters can be declared optional. Methods also return an error-code. The possible error-codes are defined in the definition of the method. An error-code of 0 always means that the method completed successfully and the output parameters are valid. Any other error-code means that the method could not complete for some reason and the output parameters are invalid (meaning that they are all <em>null</em>). For actions an error-code different from 0 also means that the state of the data model is left unchanged (any changes made by the action before it returns a non-zero error-code is automatically rolled back).</div>

<div class="standard" id='magicparlabel-597'>An example of an action could be one for adding a student to a course. It would take two input parameters: the ID of the student, and the ID of the course, and the action would not have any output parameters except for the error-code. Error-codes would then be defined for situations where there is no student with the given ID, no course with the given ID or the student is already assigned to the course. There could also be an error-code for the situation where the student do not have enough funding to pay for the course. As seen here the error-codes are dependent on the business logic for the data model and the user can define any number of error-codes that seems fit.</div>

<div class="standard" id='magicparlabel-598'>An example of a view could be getting the set of all students enrolled on a specific course. This view would take a course ID as input and the output would be a list of students. An error-code could be defined for the situation where there are no course with the given ID.</div>

<div class="standard" id='magicparlabel-599'>The actions and views are atomic operations – they either complete successfully and return an error-code of zero, or they fail and return a non-zero error-code, in which case no changes are made to the state of the data model instance.</div>
<h5 class="paragraph" id='magicparlabel-600'><span class="paragraph_label"></span> <a id="subsec_Transactions" />
Transactions</h5>
<div class="standard" id='magicparlabel-601'>Although we have taken an object oriented approach on the data models and on a high level of abstraction see a data model instance as just an object with synchronized methods, we want to elaborate a bit more on the transactional model behind the scene.</div>

<div class="standard" id='magicparlabel-602'>In this subsection we will now switch to a more database oriented terminology and call the methods on a data model instance <em>transactions</em>.</div>

<div class="standard" id='magicparlabel-603'>The illusion of complete mutual exclusive access to a data model instance, in database terminology, is the isolation property of the ACID (Atomicity, Consistency, Isolation and Durability) properties.</div>

<div class="standard" id='magicparlabel-604'>Although some object oriented languages supports methods to obtain isolation in multi-threaded environments, like the synchronize keyword in Java, they do not incorporate support for the other ACID properties in the core language.</div>

<div class="standard" id='magicparlabel-605'>This is something that we want to address in EDMA, therefore we will now go through each of the ACID properties and discuss how they will be handled in the example runtime. </div>
<h6 class="subparagraph" id='magicparlabel-606'><span class="subparagraph_label"></span> Atomicity</h6>
<div class="standard" id='magicparlabel-607'>This guarantees that a transaction is executed as an atomic unit, which means that it either completes successfully or does not change the state of the data model at all. This property is only relevant for <em>actions</em>, since <em>views</em> can never change the state of the data model anyway. The way this is implemented is through a rollback functionality. At any stage during the execution of an <em>action</em>, if something unexpected happens, or if the action is not able to complete successful for some reason, it can choose to abort (by returning a non-zero error-code) and any changes it have already made to the state of the data model up to this point will be automatically rolled back.</div>

<div class="standard" id='magicparlabel-608'>This has been implemented in the example runtime implementation by defining a small set of six primitive reversible operations that can be performed on the data model. These are the only operations allowed on the lowest level, so every execution of an action are broken down to a sequence of these primitive operations. When an action is executed these primitive operations are recorded and in the case of a rollback they can be inverted and played back in a reversed order which will effectively bring the data model back to the starting state. The set of primitive operations contains the following six operations:</div>

<ul class="itemize" id='magicparlabel-609'><li class="itemize_item">Update an attribute in a singleton</li>
<li class="itemize_item">Create a new entity</li>
<li class="itemize_item">Delete an entity</li>
<li class="itemize_item">Update an entity</li>
<li class="itemize_item">Create a new connection in a relationship</li>
<li class="itemize_item">Delete an existing connection in a relationship</li>
</ul>
<div class="standard" id='magicparlabel-615'>Each of these operations contains just enough information to be able to perform the reversed operation as well. This means that &ldquo;updates&rdquo; contains both the old and the new values and &ldquo;deletes&rdquo; contains information about the deleted item so it can be re-created. These sequences of primitive operations are also the basis for the persistence, which will be discussed later.</div>
<h6 class="subparagraph" id='magicparlabel-620'><span class="subparagraph_label"></span> Consistency</h6>
<div class="standard" id='magicparlabel-621'>When we say that the data model is in a consistent state, we mean that all consistency rules set up by the designer of the data model is respected in this state. Every <em>action</em> must guarantee that if it starts its execution with the data model in a consistent state, then the data model is also in a consistent state upon successful completion of the <em>action. During </em>the execution of the action, it is allowed for the data model to be in a non-consistent state. In EDMA it is therefore considered as an <em>error</em> in the programming of an <em>action</em> if it can move the data model from a consistent state to a non-consistent state.</div>

<div class="standard" id='magicparlabel-622'>At the time of writing this document there have not been incorporated a way to define consistency rules for EDMA data models (except for the value domain system and the unique index). But this would be an obvious extension of EDMA.</div>

<div class="standard" id='magicparlabel-623'>Depending on number and type of consistency rules it can be very slow to test the consistency of a data model. Therefore it can be a good idea to split consistency checks into different categories of checks that only looks at parts of the data model. For example we could define a kind consistency to only concern the attributes of an entity kind. This consistency would only have to be checked when a new entity is created or an existing entity is updated. Then we could define a relationship consistency that would concern a specific relationship, this would then have to be checked whenever a new connection is made, a connection is removed or if any of the participating entities are updated. But there could also be more complex consistency rules that would have to look at larger parts of the data model and these would be difficult to generalize about and therefore they would have to be checked after each update of the data model. Because of the potential large impact that consistency checks can have on the performance, we would consider them as part of a debugging process and there should be a possibility to turn them off when there is enough confidence in the implementations of the actions and better performance is needed. </div>

<div class="standard" id='magicparlabel-624'>It would be quite easy to implement a complete consistency check that could be run after each successfully executed action, but we think that a more general consistency and trigger framework is much more desirable and therefore we have hesitated to implement this simple solution.</div>
<h6 class="subparagraph" id='magicparlabel-625'><span class="subparagraph_label"></span> Isolation</h6>
<div class="standard" id='magicparlabel-626'>The isolation property says that during the execution of a transaction, this transaction may not see any changes to the state of the data model caused by other transactions. Or in other words: during the execution of a transaction it must seem to that transaction that it is the only transaction running at that time.</div>
<h6 class="subparagraph" id='magicparlabel-627'><span class="subparagraph_label"></span> Durability</h6>
<div class="standard" id='magicparlabel-628'>Traditionally durability means that once a transaction is committed it stays so, even in the event of a system failure. As we see it, there are at least two problems with this formulation:</div>

<ol class="enumerate" id='magicparlabel-629'><li class="enumerate_item">It is not clear what is covered by the term &ldquo;system failure&rdquo;. Is it enough that data is stored on the local hard drive or should it be stored on several different hard drives located in different cities or even on different continents? No matter how secure the data is stored it is always possible to think of some (maybe very unlikely) event that would wipe out all the data. In the EDMA example runtime implementation we have solved this by having an interchangeable persistence module with a simple interface that handles the persistence strategy. So in EDMA we define data to be persisted whenever the persistence module say so.</li>
<li class="enumerate_item">It is not perfectly clear if this formulation covers both updates and queries on the database. For <em>actions</em> it is clear that when they return from execution successfully, then any changes they have made to the state of the data model should already be persisted. But we think that it should also cover <em>views</em>, so whenever a view returns from execution, then any data seen by that view must be persisted.</li>
</ol>
<div class="standard" id='magicparlabel-631'>So in EDMA we will reformulate the durability property to something that is a bit more clear on what we mean exactly: </div>

<div class="standard" id='magicparlabel-632'>Durability is the property ensuring that: When a transaction (both views and actions) has returned successfully from its execution, the state of the data model known by the transaction at the end of the execution, must be persisted successfully.</div>
<h6 class="subparagraph" id='magicparlabel-633'><span class="subparagraph_label"></span> Transaction Model</h6>
<div class="standard" id='magicparlabel-634'>Since we want to abstract a data model instance to an object with synchronized methods that operates on an internal state, we have chosen a flat transaction model, where the transaction begins upon entering the method execution and ends upon exiting the method execution. In this way the end user of EDMA will never have to think about transactions or write transaction begin and end declarations.</div>
<h4 class="subsubsection" id='magicparlabel-635'><span class="subsubsection_label">4.2.6</span> Data Models</h4>
<div class="standard" id='magicparlabel-636'>A data model can be seen as a class with an internal, encapsulated state and an external interface. There can be many instances of the same data model, just as there can be many instances of a class. A data model instance also defines a transactional context, meaning that the internal state of the instance is under transactional control, but it is not possible to make transactions that span more than one data model instance.</div>

<div class="standard" id='magicparlabel-637'>In a large software project there could be several different data models covering different areas of the business model and there could be several instances of each data model. </div>

<div class="standard" id='magicparlabel-638'>The value domain system is the infrastructure that EDMA provides to transport information between different data model instances. Since all values in the value domain system are immutable and self-contained it is easy to seamlessly distribute the data model instances on different physical machines.</div>
<h4 class="subsubsection" id='magicparlabel-639'><span class="subsubsection_label">4.2.7</span> Environment</h4>
<div class="standard" id='magicparlabel-640'>An environment is a collection of data models that &ldquo;speak the same language&rdquo;. By this we mean that the environment defines a set of common value domains that the data models use in their methods. Each data model can also define local value domains that are only relevant in dealing with that specific data model.</div>

<div class="standard" id='magicparlabel-641'>Both the common value domains and the local value domains are available to applications that uses the data models in the environment.</div>


<h3 class="subsection" id='magicparlabel-644'><span class="subsection_label">4.3</span> EDMA Data Definition Language</h3>
<div class="standard" id='magicparlabel-649'>In designing the syntax for the EDMA language, we have striven to create a comfortable and easily learned language, for data and interface definition. In this section we describe the textual syntax through of the language through the use of examples. The complete EBNF grammar is found in Appendix <a href="#sec_EDMALanguageGrammar">B</a>.</div>

<div class="standard" id='magicparlabel-650'>The EDMA language is used to define both data and interfaces, using the following structure:</div>

<ul class="itemize" id='magicparlabel-651'><li class="itemize_item">Value Domains (global value domains)</li>
<li class="itemize_item">Data Models
<br />



<ul class="itemize" id='magicparlabel-653'><li class="itemize_item">Local Value Domains</li>
<li class="itemize_item">Singletons</li>
<li class="itemize_item">Kinds</li>
<li class="itemize_item">Relations</li>
<li class="itemize_item">Actions</li>
<li class="itemize_item">Views</li>
</ul>
</li></ul>
<div class="standard" id='magicparlabel-659'>Since value domains can be shared by several data models, they can be defined outside the context of data models. Data models are defined with a block-structure (delimited by curly brackets), containing local value domains, singletons, kinds, relations, actions and views inside the block. White spaces and newline-characters are ignored, meaning that blocks can be written on a single line.</div>

<div class="standard" id='magicparlabel-660'>It is possible to divide the definition into different files. For example, the user might want to have all the global value domains in one file, kinds, relations and singletons in a second file, and actions and views in a third file. </div>

<div class="standard" id='magicparlabel-661'>The syntax makes use of a set of reserved keywords, partly to make the language easy to read and understand for the user, partly to make it easier to parse. In the following, examples of each element type are used to explain the syntax.</div>
<h5 class="paragraph" id='magicparlabel-662'><span class="paragraph_label"></span> Value Domains</h5>
<div class="standard" id='magicparlabel-663'>Value domains are defined by a keyword <b>ValueDomain</b> followed by an identifier, the name of the value domain. The name of the value domain is written in camel case, and may contain numbers, although the first character of a value domain name must be an uppercase letter. After the identifier, a colon is written, followed by a type of primitive. There are 9 types of primitives, represented by the following keywords: <b>Integer</b>, <b>Long</b>, <b>Boolean</b>, <b>Float</b>, <b>Double</b>, <b>Struct</b>, <b>Enum</b>, <b>OneOf</b> and <b>List</b>. The colon serves to represent a type declaration, and can be read as &ldquo;of type&rdquo;. After the primitive type has been given, the user can optionally declare a constraint on the value domain. An example of a value domain declaration is shown in the following listing. </div>



<div class="standard" id='magicparlabel-671'>In the example given, the Month value domain is constrained to be in the range 1 to 12, both inclusive. For the number types, the constraint is always considering the range of values. The constraint is written in the form <span style='font-family:monospace;'>[a..b]</span>, where <span style='font-family:monospace;'>a</span> and <span style='font-family:monospace;'>b</span> are numbers, and where <span style='font-family:monospace;'>b</span> <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mo> &ge; </mo>
 </mrow></math> <span style='font-family:monospace;'>a</span>. Alternatively, the user can use the keywords <b>MIN</b> and <b>MAX</b> to represent the smallest or largest possible number. </div>

<div class="standard" id='magicparlabel-672'>For the String primitive type, the constraint considers the length of the string. The user can also specify a regular expression in a quoted string between <b>[</b> and <b>]</b>. Values matching the given regular expression are considered valid.</div>

<div class="standard" id='magicparlabel-673'>The <b>Long</b>, <b>Float</b> and <b>Double</b> value domains are written in the same way as the Integer value domain, using the respective keywords.</div>

<div class="standard" id='magicparlabel-674'>The List value domain is written with the contained value domain given between a pair of angle brackets. Optionally, the user can declare a length constraint on the list on the form <span style='font-family:monospace;'>[a..b]</span>, as the range constraint on number value domains. An example of a List definition is shown in the following listing.</div>



<div class="standard" id='magicparlabel-682'>The Enum value domain is written with the possible enumeration values in square brackets, as shown in the example in the following listing.</div>



<div class="standard" id='magicparlabel-690'>Like the numerical constraint is written in square brackets, we can see the enum values as being the constraint of the enum type, i.e. the value of an Animal type must be one of the given enumeration types.</div>

<div class="standard" id='magicparlabel-691'>The OneOf value domain is defined almost like the Enum value domain, but with angle brackets, as shown in the following example.</div>



<div class="standard" id='magicparlabel-699'>This bears resemblance to the notion of parametrized types in Java, generics, which is written as for example <span style='font-family:monospace;'>ArrayList&lt;Point&gt;</span>.</div>

<div class="standard" id='magicparlabel-700'>Structs are defined by declaring the primitive type <b>Struct</b>, followed by a block delimited by curly brackets. Inside the block is written a comma separated list of attributes. The following example shows the definition of a struct.</div>



<div class="standard" id='magicparlabel-713'>Each attribute consists of a name, a colon (again, to declare that the type, or value domain, is following), and a value domain. Attributes may be declared optional, by writing a question mark after the attribute name. The attribute type must be a non-primitive value domain. </div>

<div class="standard" id='magicparlabel-714'>Since white spaces are ignored, it is possible to write structs in a more compact style, like shown in the following example.</div>



<div class="standard" id='magicparlabel-722'>Because the attributes are separated by comma, the compact style is still readable. In contrast, the user can also add extra white space, as to impose a structure to make it more readable. This is shown in the following example.</div>


<h6 class="subparagraph" id='magicparlabel-735'><span class="subparagraph_label"></span> Custom Constraints</h6>
<div class="standard" id='magicparlabel-736'>The user can write custom constraints on value domains. Custom constraints are implemented manually by the user (in generated stub-files), and thus can be arbitrarily complex. The custom constraints are written immediately after the value domain definition, starting with the keyword <b>Constraints</b>, following a square bracket enclosed, comma separated list of constraints. Each constraint is a camel case word with a lower-case first character, and optionally, a double quoted string describing the constraint. The following listing shown an example of a value domain Date with constraints for disallowing non-work days.</div>



<div class="standard" id='magicparlabel-751'>Another example of a custom constraint is shown in the following listing. The example shows a definition of the value domain OddNumber with a constraint declaration.</div>



<div class="standard" id='magicparlabel-760'>As the user can omit the quoted descriptions, constraints can be written in a more compact form, as shown in the following listing.</div>


<h5 class="paragraph" id='magicparlabel-769'><span class="paragraph_label"></span> Data Models</h5>
<div class="standard" id='magicparlabel-770'>Data models are defined using the keyword <b>DataModel</b>, followed by an identifier making up the name of the data model. The name of the data model must be written with a capital first letter, like the name of value domains. After the name, a curly-bracket delimited block follows, containing definitions of local value domains, singletons, kinds, relations and actions and views. An example of an empty data model is shown in the following listing.</div>



<div class="standard" id='magicparlabel-781'>Data model definitions can be split up into several blocks. In that way, the user might create different parts of the data model in different files. The following example shows one single data model, defined over two files. Each of the two partial definitions of the single model contains a local value domain definition. Thus, the DivingSchool data model will contain two local value domains.</div>


<h5 class="paragraph" id='magicparlabel-800'><span class="paragraph_label"></span> Kinds</h5>
<div class="standard" id='magicparlabel-801'>The definition of kinds follows the same style as the definition of data models. First, the keyword <b>Kind</b> is given, followed by the name of the kind. The name of the kind must start with a capital letter. Like structs value domains, kinds have a comma separated list of attributes. The following example shows a definition of a kind inside a data model.</div>

<div class="standard" id='magicparlabel-802'>Like in structs, attributes can be declared optional by adding a question mark after the name. Further more, attributes in kinds may be declared mutable with a plus-sign after the name (this is not possible in value domains, as they are immutable.)</div>

<div class="standard" id='magicparlabel-819'>When defining a kind, EDMA automatically defines a local value domain resembling the entities of that kind. The local value domain corresponding to the one generated from the previous listing, is shown in the following listing.</div>



<div class="standard" id='magicparlabel-834'>In some cases, the user might want to make the generated local value domain visible outside the data model. This can be done by declaring the kind public, and optionally, declaring it public under a certain name. This can be done with the <b>Publish</b> and <b>Publish As</b> keywords respectively. If no name is given, the local value domain will be published under its own name. In the following example, a Person kind is published as DivingSchoolPerson (omitting the details.)</div>



<div class="standard" id='magicparlabel-842'>Further more, a kind can extend another kind. Kind extension is declared with the keyword <b>extends</b>, as shown in the following example (omitting the details.)</div>



<div class="standard" id='magicparlabel-850'>A kind can have indexes defined on any of its attributes, or list of attributes. An index is declared on one or many attributes by writing one of the three keywords, representing the three kinds of indexes, <b>Unique</b>, <b>Compare</b> and <b>Equals</b>. The keyword is followed by a comma separated list of attribute names, enclosed in parenthesis. An example of a Person kind with a compare index is shown in the following listing.</div>



<div class="standard" id='magicparlabel-863'>The index follows the natural order of the value domains.</div>
<h5 class="paragraph" id='magicparlabel-864'><span class="paragraph_label"></span> Singletons</h5>
<div class="standard" id='magicparlabel-865'>Singletons are defined in the same style as kinds, but with the <b>Singleton</b> keyword used instead of the <b>Kind</b> keyword.</div>
<h5 class="paragraph" id='magicparlabel-866'><span class="paragraph_label"></span> Relations</h5>
<div class="standard" id='magicparlabel-867'>A relation is defined by its name, the type of relation, and the two kinds that participate in the relation, and their roles. A relation definition starts with the <b>Relation</b> keyword, followed by the name of the relation. The relation name must start with a capital letter. After the relation name comes the first relation participant, the relation type, and the second participant. Each participant is written as two colon-separated parts, the name of a kind, and the lowercase role name. The user can leave out the colon and role, in which case the role will be the same as the kind. An example of two relation definitions are showed in the following listing.</div>



<div class="standard" id='magicparlabel-876'>The relation type is shown with the <b><span style='font-family:monospace;'>&gt;-&lt;</span></b> symbol, to mimic crows-feet notation. The three relation types available are <b><span style='font-family:monospace;'>&gt;-&lt;</span></b>, <b><span style='font-family:monospace;'>&gt;--</span></b> and <b><span style='font-family:monospace;'>---</span></b>. The &ldquo;many&rdquo; part of a many-to-one or one-to-many relation is always written on the left side.</div>

<div class="standard" id='magicparlabel-877'>Indexes can be defined on relations, as well as on indexes. When defined on a relation, the user must choose on which of the participants the index is placed, with the <b>On</b> keyword. The index declaration is placed inside a block delimited by curly brackets. The following example shows a relation with a unique index.</div>



<div class="standard" id='magicparlabel-888'>If the relation is between two of the same kinds, a colon and role name can be supplied after the kind name.</div>

<div class="standard" id='magicparlabel-889'>Constraints can be declared on relations, by using the same syntax as constraints in value domains. The constraints must be written inside the block, where also the relation indexes are written.</div>
<h5 class="paragraph" id='magicparlabel-890'><span class="paragraph_label"></span> Actions and Views</h5>
<div class="standard" id='magicparlabel-891'>Actions and views are defined inside a data model block, starting with either of the keywords <b>Action</b> or <b>View</b>. The syntax of actions and views are similar, besides the keyword. After the keyword follows the name, which must start with a lowercase letter. The name is followed by a block delimited by curly braces. Inside the block, four keywords are recognized: <b>Input</b>, <b>Output</b>, <b>ErrorCodes</b> and <b>Description</b>. The input and output declarations are followed by colon, and a comma separated list of attributes, given either as inputs or outputs. An error code is written as a number (the error code), a hyphen for separation, and quoted error text. The description keyword lets the user write a quoted string, acting as a description. The following example shows the definition of a view and an action.</div>

<div class="standard" id='magicparlabel-892'>The input, output, description, and error code sections can be written in any order.</div>
<h5 class="paragraph" id='magicparlabel-924'><span class="paragraph_label"></span> Comments</h5>
<div class="standard" id='magicparlabel-925'>The syntax for comments is like that of Java, <b>//</b> denounces a line comment, while <b>/*</b> and <b>*/</b> is used for block-commenting.</div>


<h3 class="subsection" id='magicparlabel-928'><span class="subsection_label">4.4</span> Compiler</h3>
<div class="standard" id='magicparlabel-929'>In this section, we describe the compilation of EDMA data definition files. The compiler consists of three parts: a parser, a translator, and a generator. An overview of the compilation process can be seen on Figure&nbsp;.</div>



<div class="standard" id='magicparlabel-944'>A parser takes in one or many data model definition files with the extension <span style='font-family:monospace;'>.edma</span>. While parsing the files, an abstract syntax tree (AST) representing the data models, is being created. The translator translates the AST into a meta model, which can then be fed to the generator. The generator is responsible for outputting Java classes and interfaces, reflecting the user's data model definition.</div>

<div class="standard" id='magicparlabel-945'>It is worth noting, that the abstract syntax tree defines the logical structure of our environment and data models. The important feature of the AST is that it makes the translator completely independent of the concrete textual syntax used in the EDMA language. Having the AST makes it easy to change the textual grammar and create other syntaxes, and even create other types of syntaxes. For example, it would be possible to implement a graphical user interface for drawing data models, thus serving as a syntax.</div>
<h4 class="subsubsection" id='magicparlabel-946'><span class="subsubsection_label">4.4.1</span> Parser</h4>
<div class="standard" id='magicparlabel-947'>For defining the grammer of the textual syntax, we have used a parser / scanner generator known as JavaCC. From a JavaCC-grammer, a Java-based top-down LL(k) parser is generated. The grammar specification is a variation of EBNF, mixed with Java code for building an instance of the AST.</div>
<h4 class="subsubsection" id='magicparlabel-948'><span class="subsubsection_label">4.4.2</span> Translator</h4>
<div class="standard" id='magicparlabel-949'>The translator takes an AST representing the data model definition, and creates a meta model instance. The meta model instance can be seen as an internal representation of the data model definition, and it is used by both the generator, and by the EDMA runtime system.</div>

<div class="standard" id='magicparlabel-950'>When the translator has got a complete AST from the parser, resembling the user's data model, it does two things. First, it checks whether everything is consistent within the AST. Then, it simply translates the AST instance into a Meta Model instance.</div>
<h6 class="subparagraph" id='magicparlabel-951'><span class="subparagraph_label"></span> AST Consistency</h6>
<div class="standard" id='magicparlabel-952'>In the grammar, syntactical rules governing the data model definition are specified. However, even if the language is only a data definition language, there are also some semantic rules, that we must enforce. Before translating the AST into a meta model, the translator checks for the presence of circular extensions, unknown references, invalid ranges in constraints, and value domain loops.</div>

<dl class='description' id='magicparlabel-953'><dt class="description_label">Circular&nbsp;Extensions</dt>
<dd class="description_item"> – The kinds Person and Student could be defined to extend each other. Instantiation of either would require an instance of the other to exist. Therefore, we prohibit the user from making circular extensions of kinds.</dd>
<dt class="description_label">Unknown&nbsp;References</dt>
<dd class="description_item"> – Wherever the user has written a reference to an attribute name or a kind name, it must be checked whether the given attribute or kind is actually defined.</dd>
<dt class="description_label">Value&nbsp;Domain&nbsp;Range&nbsp;Checks</dt>
<dd class="description_item"> – Since the user can specify ranges on numerical value domains, we have to check that the ranges supplied actually make sense. For example having a minimum value that is greater than the maximum value, should be invalid.</dd>
<dt class="description_label">Value&nbsp;Domain&nbsp;Loops</dt>
<dd class="description_item"> – Having immutable value domains may be tricky for the unaware user. Without any check for loops, the user would be able to define value domains for which there could never be a valid value. A value domain A of type Struct, could contain an attribute b, of type <span style='font-family:monospace;'>B</span>. Likewise, a value domain B of type Struct could contain an attribute of type A. This is shown on the listing below.
<br />

Since in A, b is not optional, it must be supplied at the instantiation of A. Similarly, when creating a value of B, a value of A must be supplied. The user could declare a type of B, and set it to null, and feed it to A upon creation, but this will make the instantiation of B fail with a nullpointer exception. Since the user might accidentially create loops, by having many different inter-related value domains, we have put a check into the compiler, to make it fail as early as possible.</dd>
</dl>
<div class="standard" id='magicparlabel-968'>As soon as an error has been found in the AST, we print out the problem, the file name and the line number where the error occurred. Each element in the AST is created with the file name and line number of the statement, that was the source of it's creation. Therefore, we can easily print it out when an error occurs in the compilation stage.</div>

<div class="standard" id='magicparlabel-969'>After the meta model has been created, the compiler invokes the Generator, which then starts generating the model-specific Java code.</div>


<h4 class="subsubsection" id='magicparlabel-972'><span class="subsubsection_label">4.4.3</span> Generator<a id="sec_Generator" />
</h4>
<div class="standard" id='magicparlabel-973'>The generator is the module responsible for generating Java classes and interfaces for a specific instance of the meta model.</div>

<div class="standard" id='magicparlabel-974'>The generator generates the following:</div>

<ul class="itemize" id='magicparlabel-975'><li class="itemize_item">Interfaces and classes for each Value Domain defined in the environment and the data models.</li>
<li class="itemize_item">The environment class that contains the instance factories for each data model in the environment.</li>
<li class="itemize_item">An instance factory for each data model in the environment, that controls the individual instances of the data model.</li>
</ul>
<div class="standard" id='magicparlabel-978'>For each data model in the environment, the following is generated:</div>

<ul class="itemize" id='magicparlabel-979'><li class="itemize_item">The set of interfaces that makes up the internal API, used by the actions and views to manipulate and view the state of the data model instance.</li>
<li class="itemize_item">The set of classes that implements the internal API and binds it to the runtime interface.</li>
<li class="itemize_item">The stub classes where the user implements the actions and view. There is one stub class for each action and view.</li>
<li class="itemize_item">The external interface for the data model.</li>
<li class="itemize_item">The implementation of the external interface, that binds the methods of the interface to the stub classes and execute them through the runtime interface.</li>
</ul>
<h6 class="subparagraph" id='magicparlabel-984'><span class="subparagraph_label"></span> </h6>
<h5 class="paragraph" id='magicparlabel-985'><span class="paragraph_label"></span> <a id="subsec_Creation_of_values" />
Value Domains</h5>
<div class="standard" id='magicparlabel-986'>The value domains are the type system and infrastructure in EDMA that binds everything together and ensures that every part of a project speaks the same language. Each value domain represents a unique type of data with a well defined structure.</div>

<div class="standard" id='magicparlabel-987'>The generator generates two classes for each defined value domain: An abstract class that serves as an interface to values from the value domain and an implementation class that implements the abstract methods in the interface. The reason for using an abstract class instead of a Java interface is that Java does not support static methods in interfaces and there are several static methods used to create new values:</div>

<ul class="itemize" id='magicparlabel-988'><li class="itemize_item">create - this method creates a new value from scratch </li>
<li class="itemize_item">fromString - this method creates a new value from the string representation of the value.</li>
<li class="itemize_item">fromStream - this method reads a value from a stream.</li>
<li class="itemize_item">fromStreamNoValidate - this method reads a value from a stream without validating it. It should only be used when reading from a trusted source. For large complex values with many constraints the validate process could be slow, that is the reason for having this method.</li>
<li class="itemize_item">fromTerminal - this method uses a terminal to instruct a user to create a new value.</li>
</ul>
<div class="standard" id='magicparlabel-993'>And some abstract methods:</div>

<ul class="itemize" id='magicparlabel-994'><li class="itemize_item">toString - returns the string representation of the value.</li>
<li class="itemize_item">toStream - writes the value to a stream.</li>
</ul>
<div class="standard" id='magicparlabel-996'>All value domain classes also have sensible implementations of the comparable interface, the hashCode and equals methods.</div>

<div class="standard" id='magicparlabel-997'>The create method for struct type value domains uses a modified version of the builder pattern to create new values. The builder pattern uses what is known as a fluid interface[<a href='#LyXCite-fowler2008'><span class="bib-label">2</span></a>], where methods are chained together. This results in more readable code, where each field has a set-method named after it. In EDMA we have taken the builder pattern one step further, so each field has its own interface, with a set-method named after the field. Each set-method then returns the builder-interface for the next field except the last one, which returns the created object or value. By doing it this way, we get a fixed order of the attributes and we make sure that it is not possible to miss out on any of them. It would be a bit cumbersome to program this by hand, but with auto-generated code it is no problem. As an example, lets see how we would create a new date from the date value domain:</div>

<div class="standard" id='magicparlabel-998'>The static method <span style='font-family:monospace;'>Date.create()</span> returns an interface that only has a method for setting the year. That method returns an interface with a method to set the month, which in turn returns an interface to set the day. The interface for setting the day finally returns the completed data value. If we put the attributes in a wrong order or if we missed out any of them, then the Java compiler would complain immediately. If the user uses a modern IDE e.g. eclipse, it gets very easy since the automatic code-completion will pop up with the name of the next field after each dot. This type of chained interfaces are used in EDMA both when creating values from value domains and when creating entities from kinds.</div>
<h5 class="paragraph" id='magicparlabel-1005'><span class="paragraph_label"></span> Data Models</h5>
<div class="standard" id='magicparlabel-1006'>For each data model in the environment, several interfaces and classes are created:</div>

<ul class="itemize" id='magicparlabel-1007'><li class="itemize_item">Data model factory interface. This interface provides methods to create new instances of the data model and to get access to existing instances of the data model. Each instance is identified by a name.</li>
<li class="itemize_item">Data model instance interface. This interface is used to start and stop the instance and to get the external interface of the instance. The methods of the external interface can only be called when the instance is running. Otherwise an exception is thrown.</li>
<li class="itemize_item">Data model external interface. This is the external interface of the data model that clients can use to execute the actions and views on the data model.</li>
<li class="itemize_item">Internal view interface. This is the interface that <em>views</em> use internally to navigate and extract information from the data model.</li>
<li class="itemize_item">Internal update interface. This interface extends the internal view interface and adds functionality to make changes to the data model. This is the interface that <em>actions</em> use internally.</li>
</ul>
<div class="standard" id='magicparlabel-1012'>Besides these interfaces there are also generated classes that bind these data model specific interfaces to the general runtime interface.</div>
<h5 class="paragraph" id='magicparlabel-1013'><span class="paragraph_label"></span> Kinds</h5>
<div class="standard" id='magicparlabel-1014'>For each kind in the data model we create a number of interfaces that can be used internally in the implementation of the views and actions. These interfaces are:</div>

<ul class="itemize" id='magicparlabel-1015'><li class="itemize_item">The entity view interface. This interface provides methods to read the attributes of an entity of this kind. It will also get the methods that are used to navigate any relations that this kind is part of.</li>
<li class="itemize_item">The entity update interface. This interface extends the view interface and adds methods to update the mutable attributes. This interface will also get methods to create and delete connections with other entities through the relations that this kind is part of.</li>
<li class="itemize_item">The set interface. This interface is used to navigate sets of entities of this kind. It implements the iterable interface and has methods to create new sets by unions, intersections and subtractions with other sets of the same kind. It also gets methods to navigate relations that this kind is part of.</li>
<li class="itemize_item">The filter interface. This is a simple interface that can be used to create specialized filters that can be used on sets of entities of this kind.</li>
<li class="itemize_item">The kind interface. This interface has methods to get access to all entities of this kind or a specific entity either by ID or by any unique index on the kind. It also has methods to get access to specific sets of entities based on the indexes declared on this kind.</li>
</ul>
<div class="standard" id='magicparlabel-1020'>For each kind in the data model, the internal view interface for the data model gets a method to access the kind interface and the internal update interface gets methods to create new entities and delete entities of this kind and a method to upgrade a view interface for an entity of this kind to an update interface. For singletons we only have the entity view and entity update interface.</div>

<div class="standard" id='magicparlabel-1021'>The way we update entities is a little special because of the unique index. Normally we would just make a set method for each mutable attribute and then these could be used to update entities one attribute at the time, but this could give problems if there are unique indexes that span more than one attribute. As an example, lets say we have a person kind with separate attributes for first name and last name and that we have a unique index on (firstName, lastName). There exist a person called &ldquo;John Andersen&rdquo; and another person called &ldquo;Thomas Andersen&rdquo;. Lets say we want to change the name of &ldquo;Thomas Andersen&rdquo; to &ldquo;John Nielsen&rdquo;, then we would get an UniqueException if we started by changing his first name to &ldquo;John&rdquo;, because now there would be two people named &ldquo;John Andersen&rdquo;. To solve this we have made it possible to update several attributes at once. Instead of doing something like this:We instead do like this:Thus, we update both the first name and the last name at the same time and we will only get an UniqueException if there is another person named &ldquo;John Nielsen&rdquo;. The <em>save</em> method only declares that it can throw a UniqueException if we actually update an attribute that is part of a unique index. This is done by a little trick, where we actually have two different interfaces for updating the attributes, a <em>plain</em> one where the <em>save</em> method does <em>not</em> throw a UniqueException and a <em>unique</em> one where the <em>save</em> method declares to throw the UniqueException. In the <em>plain</em> interface all set methods on attributes that are not part of a unique index just return the <em>plain</em> interface again, but the set methods for those attributes that are involved in a unique index returns the <em>unique</em> interface instead. In the <em>unique</em> interface all set methods returns the <em>unique</em> interface again. So this does that as soon as we have &ldquo;touched&rdquo; an attribute that is part of a unique index, then the <em>save</em> method will declare that it can throw the UniqueException.</div>

<div class="standard" id='magicparlabel-1035'>Besides these interfaces there are also generated classes that binds these data model specific interfaces to the general runtime interface.</div>
<h5 class="paragraph" id='magicparlabel-1036'><span class="paragraph_label"></span> Relations</h5>
<div class="standard" id='magicparlabel-1037'>The relations in the data model add methods to the interfaces for the kinds participating in the relation. The names of these methods are dependent on the type of the relation, as well as names and roles of the participating kinds. For example, having a relation <span style='font-family:monospace;'>StudentEnrollment</span> between <span style='font-family:monospace;'>Course</span> and <span style='font-family:monospace;'>Person</span> (having the role of <span style='font-family:monospace;'>student</span>) results in four methods; two in the <span style='font-family:monospace;'>CourseUpdate</span> interface (<span style='font-family:monospace;'>addStudent</span> and <span style='font-family:monospace;'>removeStudent</span>), one in the <span style='font-family:monospace;'>PersonViewer</span> interface (<span style='font-family:monospace;'>asStudentGetCourseSet</span>) and one in the <span style='font-family:monospace;'>CourseViewer</span> interface (<span style='font-family:monospace;'>getStudentSet</span>). This is visualized in figure&nbsp;.</div>

<div class="standard" id='magicparlabel-1042'>Notice that the method in the course viewer interface is not named <span style='font-family:monospace;'>asCourseGetStudentSet</span>, but just <span style='font-family:monospace;'>getStudentSet.</span> Methods in the <span style='font-family:monospace;'>PersonUpdate</span> interface for adding and removing courses (as a student) could be generated as well; however, these would be redundant with the <span style='font-family:monospace;'>addStudent</span> and <span style='font-family:monospace;'>removeStudent</span> in the <span style='font-family:monospace;'>CourseUpdater</span> interface. Therefore, the generator only creates connection methods on the first kind in the relation (the kind written to the left in the relation declaration).</div>

<div class="standard" id='magicparlabel-1072'>In a one-to-many relation, a method returning a set of the other kind, is created on the first kind, while a method returning a single entity is created on the second kind. This is shown in figure&nbsp;.</div>

<div class="standard" id='magicparlabel-1077'>In the <span style='font-family:monospace;'>CourseUpdate</span> interface, a method is generated for creating and deleting connections, as shown below.This method returns the previous teacher, or <em>null</em> if there previously was no teacher assigned to the course. To remove the current teacher without setting a new, this method can be called with <em>null</em> as argument.</div>

<div class="standard" id='magicparlabel-1108'>The one-to-one-self relation generates code as expected. Figure&nbsp; shows a one-to-one-self relation, <span style='font-family:monospace;'>Marriage</span>, relating two persons, each with the role of <span style='font-family:monospace;'>spouse</span>. In the resulting PersonViewer interface, a method to get the spouse, as well one to set the spouse, is generated.</div>
<h5 class="paragraph" id='magicparlabel-1134'><span class="paragraph_label"></span> Indexes</h5>
<div class="standard" id='magicparlabel-1135'>There are three types of indexes in EDMA<em> (Unique</em>, <em>Equal</em> and <em>Compare</em>) and each of these can be placed both on kinds and on relations. When an index is placed on a kind, the methods related to the index are added to the kind's interface. When an index is placed on a relation, the methods are added to the entity viewer interface. A Unique index does not only add extra methods to these interfaces, it also adds a &ldquo;<span style='font-family:monospace;'>throws UniqueException</span>&rdquo; declaration to every method that might violate the unique constraint.</div>


<h5 class="paragraph" id='magicparlabel-1176'><span class="paragraph_label"></span> Actions and Views</h5>
<div class="standard" id='magicparlabel-1177'>Actions and views are the transactions in EDMA. For each Action or View defined by a data model, a corresponding Java class is created by the generator. These classes are the placeholders for the Java-code that makes up the specific action or view. This is best illustrated by an example: In the data model definition we define an action like this:</div>



<div class="standard" id='magicparlabel-1198'>The generator will then generate the following java class:</div>



<div class="standard" id='magicparlabel-1271'>The user must now implement the business logic that makes up the action using the interface provided as a parameter in the execute method. The execute method must return one of the error-codes or 0 (OK) if successful. The implementation could look like this:</div>



<div class="standard" id='magicparlabel-1298'>The EDMA framework will take care of calling the execute method and automatically roll back changes in the case of an error code different than 0 (OK) is returned or an exception is thrown.</div>

<div class="standard" id='magicparlabel-1299'>For a view it is almost the same except that the interface provided as a parameter to the execute method is a &ldquo;view&rdquo; interface which means that it has no methods for updating the data model instance.</div>
<h5 class="paragraph" id='magicparlabel-1300'><span class="paragraph_label"></span> Utilities</h5>
<div class="standard" id='magicparlabel-1301'>Because of the fine grained value domain system with well defined, but arbitrary complex values and the meta description of both the internal structure and the external interface of the data models, it is possible to auto-generate many useful utilities for working with specific data models. This is where the full strength of the model driven approach comes to play. We have created a few simple examples of what can be auto generated, but only ones imagination limits the possibilities of what could be auto generated.</div>

<div class="standard" id='magicparlabel-1302'>When a new utility has been invented and generation code written, all both earlier and future projects can benefit from a specialized version of the utility by the press of a button.</div>
<h6 class="subparagraph" id='magicparlabel-1303'><span class="subparagraph_label"></span> Remote access</h6>
<div class="standard" id='magicparlabel-1304'>The generator creates a Java-interface from the actions and views on each data model defined. This interface is the external interface to an instance of that data model. This interface will be used by the client programs that operate on the specific data model instance. These client programs could be placed within the same JVM as the Data model instance, but they could also be placed in a different JVM, perhaps on a different machine. Therefore the generator will generate a server program and a client proxy that communicates over sockets. This makes it very easy to separate the client application from the data model instance if this is needed.</div>


<h6 class="subparagraph" id='magicparlabel-1315'><span class="subparagraph_label"></span> Terminal test</h6>
<div class="standard" id='magicparlabel-1316'>The generator also generates a program where a user can call the methods of the external interface through a simple terminal.</div>


<h6 class="subparagraph" id='magicparlabel-1327'><span class="subparagraph_label"></span> Web Interface</h6>
<div class="standard" id='magicparlabel-1328'>It would also be possible to generate a web interface where a user can interact with a data model instance through the external interface. Javascript can be created to validate the value domains. We have created an early prototype of this, but it requires a bit more work to be perfected.</div>


<h5 class="paragraph" id='magicparlabel-1339'><span class="paragraph_label"></span> Names and Packages</h5>
<div class="standard" id='magicparlabel-1340'>It is important to us that the generated code can compile right away without any changes, so we need to keep track of all imports and package information. Since many of the generated interfaces and classes are dependent on each other and on the runtime interface, any changes to the naming conventions or the package structure would require lots of changes to the generator code in many different places. To avoid this we have abstracted out the naming conventions and the package structure to a separate interface that takes care of all class names, package names and package layout. This interface is then used all over the generator. In this way it is easy to make changes to the names of interfaces and classes or to the package structure of the generated code. It is even possible to have several implementations of the naming interface, so it is possible to switch between different naming and package layout strategies.</div>


<h3 class="subsection" id='magicparlabel-1343'><span class="subsection_label">4.5</span> <a id="sec_Runtime" />
Runtime System</h3>
<div class="standard" id='magicparlabel-1344'>The runtime system is the module that is responsible for managing all the data in a data model instance at runtime. This includes the following tasks:</div>

<ul class="itemize" id='magicparlabel-1345'><li class="itemize_item"><b>Data Containment: </b>Holding data that make up the current state of a running data model instance, which includes all entities and connections between entities.</li>
<li class="itemize_item"><b>Index Containment:</b> Keeping and updating all indexes on the data model instance.</li>
<li class="itemize_item"><b>Transaction Execution:</b> Making sure that all transactions are executed correctly.</li>
<li class="itemize_item"><b>Data Persistence:</b> Taking care of the persistence of the data model instance. </li>
</ul>
<div class="standard" id='magicparlabel-1349'>The runtime implements a series of runtime interfaces, used by the generated code. There could be many different implementations of the runtime interface, each with different strategies and solutions on how to solve these tasks. This way it is easy to switch between different runtime implementations without any changes to the generated code, or to the code written by the users.</div>
<h4 class="subsubsection" id='magicparlabel-1350'><span class="subsubsection_label">4.5.1</span> Runtime Interface</h4>
<div class="standard" id='magicparlabel-1351'>In the creation of the runtime interface we have tried to make it independent of how it would be implemented.</div>

<div class="standard" id='magicparlabel-1352'>Since the runtime interface is non-generated code, it has no knowledge of specific data models at compile time. It gets the information about the specific data model that it should manage from the meta model instance at runtime. Thus, in the runtime interface specific kinds, relations and indexes are referred to by their index in the meta model instance.</div>

<div class="standard" id='magicparlabel-1353'>The runtime interface consists of a number of Java interfaces that a runtime implementation must implement. These interfaces are:</div>

<ul class="itemize" id='magicparlabel-1354'><li class="itemize_item"><span style='font-family:monospace;'>IRuntimeFactory</span> - Given the meta model instance for a specific data model it returns an <span style='font-family:monospace;'>IDataModelInstanceFactory</span></li>
<li class="itemize_item"><span style='font-family:monospace;'>IDataModelInstanceFactory</span> - Can load, create and delete individual instances of a data model.</li>
<li class="itemize_item"><span style='font-family:monospace;'>IDataModelInstance</span> - Represents an instance of a data model. Has methods to start and stop the instance and execute views and actions.</li>
<li class="itemize_item"><span style='font-family:monospace;'>IView</span> - Represents a view on the data model implemented by the user.</li>
<li class="itemize_item"><span style='font-family:monospace;'>IAction</span> - Represents an action on the data model implemented by the user.</li>
<li class="itemize_item"><span style='font-family:monospace;'>IResult</span> - Represents the result of executing a view or an action on the data model instance.</li>
<li class="itemize_item"><span style='font-family:monospace;'>IDataModelView</span> - This is the interface that the user implementations of actions are bound to through the auto-generated internal API interfaces and classes.</li>
<li class="itemize_item"><span style='font-family:monospace;'>IDataModelUpdate</span> - This is the interface that the user implementations of views are bound to through the auto-generated internal API interfaces and classes.</li>
<li class="itemize_item"><span style='font-family:monospace;'>IIndex</span> - Represents an index on the data model.</li>
<li class="itemize_item"><span style='font-family:monospace;'>IEntity</span> - Represents an entity in the data model.</li>
</ul>
<div class="standard" id='magicparlabel-1364'>Any implementation of an EDMA runtime system must provide these interfaces for the generated code to bind up against.</div>
<h6 class="subparagraph" id='magicparlabel-1365'><span class="subparagraph_label"></span> Procedural vs Declarative Query Languages</h6>
<div class="standard" id='magicparlabel-1366'>In EDMA queries to the data models are written in a procedural manner, where the user describes an algorithm for how to construct the result, using the structure of the data model to navigate and using set operations to narrow or widen the result.</div>

<div class="standard" id='magicparlabel-1367'>In SQL, queries are written in a declarative way, where the user describes what the result should be, but not how to obtain it.</div>

<div class="standard" id='magicparlabel-1368'>It is a subjective matter which of these approaches that feel most natural, but if a user has an object oriented background, he is used to get things done in a procedural manner.</div>

<div class="standard" id='magicparlabel-1369'>One advantage of the declarative approach is that the underlying system has freedom to analyze the query and try to find the most optimal algorithm for creating the result.</div>

<div class="standard" id='magicparlabel-1370'>But even though EDMA takes a procedural approach to obtain the result, we can use abstraction to let the runtime system delay decisions and do some amount of optimization on its own. One example of this is the way sets and set operations are handled in the runtime system.</div>
<h6 class="subparagraph" id='magicparlabel-1371'><span class="subparagraph_label"></span> Sets and set operations</h6>
<div class="standard" id='magicparlabel-1372'>One of the important features the runtime system most provide is set operations such as union, intersection and subtraction. But instead of representing a set by a java class, we simply use an index that the runtime system controls. In this way when the user asks the runtime system to perform an intersection of two sets, all the runtime system actually gets are the indexes of the sets to intersect and it returns a new index that represents the intersection of the sets. But the runtime does not actually have to perform the intersection at this time. Only when the user actually wants to access or count the elements in the set, the runtime must perform the intersection. In the case of complicated queries that involves many set operations before the final result is produced, the runtime system can analyze and optimize how to perform these set operations. This method of postponing evaluation until the result is actually used is known as lazy evaluation.</div>

<div class="standard" id='magicparlabel-1373'>Especially in a runtime implementation that is backed by an SQL database, the lazy evaluation is important to avoid sending lots of small queries to the DBMS, but instead build a larger query behind the scene and send it when the result is needed. This will both minimize communication with the DBMS and give the DBMS better optimization opportunities.</div>
<h6 class="subparagraph" id='magicparlabel-1374'><span class="subparagraph_label"></span> Value domains in the runtime</h6>
<div class="standard" id='magicparlabel-1375'>Each value domain has its own handler in the meta model instances. These value domain handlers take care of everything that has to do with values. To the runtime system a value is simply a Java object and every time the runtime system needs to do something with a value (e.g. write it to a stream) it simply invokes the handler for that specific value domain.</div>
<h4 class="subsubsection" id='magicparlabel-1376'><span class="subsubsection_label">4.5.2</span> Example Runtime System</h4>
<div class="standard" id='magicparlabel-1377'>We have created an example runtime system that are written entirely in Java. It stores the current state of the data model instances in memory using standard Java collections like HashMap, HashSet, TreeMap, TreeSet etc. This gives us a fairly fast implementation but with a significant memory footprint.</div>
<h5 class="paragraph" id='magicparlabel-1378'><span class="paragraph_label"></span> Data Containment</h5>
<div class="standard" id='magicparlabel-1379'>All the data of a running data model instance, is held in containers called <em>Kind Store, Relation Store</em> and <em>Index Store</em>. They contain all the data that is currently in the data model, as well as uncommitted data.</div>
<h6 class="subparagraph" id='magicparlabel-1380'><span class="subparagraph_label"></span> Kind Store</h6>
<div class="standard" id='magicparlabel-1381'>Entities of any kind are stored in a Kind Store. There is one kind store for each kind in the data model definition. A kind store is backed by a hashmap, with a <span style='font-family:monospace;'>Long</span> as key, and an <span style='font-family:monospace;'>Entity</span> object as value. The <span style='font-family:monospace;'>Entity</span> object contains an object array, holding the attribute values of the entity.</div>
<h6 class="subparagraph" id='magicparlabel-1382'><span class="subparagraph_label"></span> Relation Store</h6>
<div class="standard" id='magicparlabel-1383'>The relation store is used for storing connections between entities. We have different Relation Store implementations based on cardinality of the relation. Each end of the relation has a map that maps from IDs to connected IDs. If the opposite end is a <em>one</em> single IDs are stored as values, if the opposite end is a <em>many</em>, sets of IDs are the values. Special implementations take care of removing redundancy in self-relations by sorting the IDs before a connection is inserted or retrieved. </div>
<h5 class="paragraph" id='magicparlabel-1384'><span class="paragraph_label"></span> Index Containment</h5>
<div class="standard" id='magicparlabel-1385'>As earlier mentioned, EDMA provides three types of indexes on kinds and on relations: unique, compare and equals. In the example runtime system the equals- and unique indexes are backed by hashmaps, and the compare index is backed by a treemap using the NavigableMap interface.</div>

<div class="standard" id='magicparlabel-1386'>Updates on the indexes are performed whenever a relevant entity is created, deleted or relevant attributes are updated.</div>
<h5 class="paragraph" id='magicparlabel-1387'><span class="paragraph_label"></span> Transaction Execution</h5>
<div class="standard" id='magicparlabel-1388'>The execution model is responsible for managing the execution of the transactions. The execution model must ensure the ACID properties.</div>

<div class="standard" id='magicparlabel-1389'>There are basically two ways of executing transactions. Either, transactions can be executed sequentially, or they can be executed in parallel. In most database systems, transaction execution is done in parallel, using concurrency control mechanisms to secure data integrity. When executing transactions in parallel, certain concurrency control mechanisms are needed to ensure the isolation property. Concurrency control can either be pessimistic or optimistic. </div>
<h6 class="subparagraph" id='magicparlabel-1390'><span class="subparagraph_label"></span> Pessimistic Concurrency Control</h6>
<div class="standard" id='magicparlabel-1391'>In a pessimistic concurrency control mechanism, transactions acquire locks on data, before they execute. In EDMA, the user writes the transactions in pure Java, after the code has been generated. This means that EDMA is not compiling or reading the user created transactions. This makes it impossible for EDMA to know which parts of the data model the user is accessing, and hence which parts should be locked.</div>
<h6 class="subparagraph" id='magicparlabel-1392'><span class="subparagraph_label"></span> Optimistic Concurrency Control</h6>
<div class="standard" id='magicparlabel-1393'>In the optimistic approach, all reads of a transaction are logged, and the writes are done to a local cache only, until the commit phase. In the commit phase it is checked that none of the reads has changed before the writes are made permanent. If any of the reads has changed, the entire transaction is canceled and re-executed at a later time.</div>

<div class="standard" id='magicparlabel-1394'>It would be possible to implement a similar strategy in an EDMA runtime system, but we have chosen not to do so in the example runtime system because of: 1) The complexity of it, and the time it would take to implement, 2) the bookkeeping overhead it would impose, and 3) it would require that all transactions could risk to be canceled and re-executed, which puts some heavy constraints on the side effects that would be allowed inside a transaction. In Java it would be very hard (if not impossible) to detect and warn about such unwanted side effects and therefore this would break the illusion that a data model instance is just a synchronized object.</div>
<h6 class="subparagraph" id='magicparlabel-1395'><span class="subparagraph_label"></span> Sequential Execution</h6>
<div class="standard" id='magicparlabel-1396'>The simplest way of obtaining 100% ACID properties would be to execute and persist all transactions completely sequentially. Although this approach would probably be sufficient in many cases where performance is not a big issue, we can easily get a better performance in a multi-threaded environment by some parallelization of the process. There are two ways we can parallelize the process without adding any significant concurrency control overhead. The first one is to pipeline the process into an execution step and a persistence step. The second way is to parallelize views. </div>

<div class="standard" id='magicparlabel-1397'>In EDMA, we have chosen to make the actions run sequentially. However, the sequential run has been pipelined into a two-step process: execution and persistence. By having the process broken up in two independent steps, one thread can run the execution of a transaction while another thread runs the persistence of a previously executed transaction.</div>
<h6 class="subparagraph" id='magicparlabel-1398'><span class="subparagraph_label"></span> Pipelining</h6>
<div class="standard" id='magicparlabel-1399'>By pipelining the execution and the persistence, we do not have to wait for a transaction to be persisted before we can start executing the next one. Figure&nbsp; illustrates the idea, representing the different transactions of threads by boxes in different colors (each color belongs to one thread.)</div>

<div class="standard" id='magicparlabel-1404'>In figure  a thread starts a transaction, represented by the green box, at time 0. At time 1, the execution unit takes the green transaction from the task buffer, and executes it, while another thread (blue) puts another transaction into the task buffer. At time 2, the green transaction is handed over to the persistence unit, while the blue transaction is going into the execution unit. Now, we can have one thread doing the execution, while another thread does the persistence. We still return control to the client, only when the action called by the client has been persisted. Therefore, the thread issuing the green transaction is blocked, until the green transaction enters the After slot (only shown for pedagogical reasons).</div>

<div class="standard" id='magicparlabel-1419'>Each of the two steps in the pipeline are sequentially executed, and therefore the slowest of them decides the throughput of the complete pipeline. However, if we add a buffer between the two steps, we can smooth out the workload of each step, if some transactions are heavier on the execution and others are heavier on the persistence. The goal is to keep both the execution and the persistence mechanism as busy (i.e. non-idling) as possible, with a minimum of waiting. This is shown on figure&nbsp;. </div>


<h6 class="subparagraph" id='magicparlabel-1434'><span class="subparagraph_label"></span> Parallelization of Views</h6>
<div class="standard" id='magicparlabel-1435'>The second parallelization method takes advantage of the distinction we have made between the two types of transactions: <em>actions</em> and <em>views. </em>Since we know that views can never change the state of the data model it is safe to parallelize these. It is important to notice here that even though views have nothing to persist, we still need to send them through the entire pipeline and not let them return control to the client thread before they have reached the persistence step. The reason for this is the <em>durability</em> property that we wish to maintain. We do not want a view to reflect anything in the data model that has not yet been persisted. If we let the views return immediately after the execution step, we could get into a situation where the view reflected the effect of an action that were still in the persistence buffer, waiting to be persisted. If the persistence of the action somehow failed, then the view would reflect a non-persisted state of the data model. Therefore, execution of views is parallelized, but views must sequentially pass through the persistence unit (which then does nothing else than marking the view as persisted.)</div>
<h6 class="subparagraph" id='magicparlabel-1436'><span class="subparagraph_label"></span> The execution algorithm used in the example runtime system</h6>
<div class="standard" id='magicparlabel-1437'>In EDMA the executor and the persistence module are run in two separate threads. <em>Actions</em> are executed sequentially in the executor thread while <em>views </em>are executed in parallel in their client threads. The executor has two modes: action-mode and view-mode. When in action-mode it executes actions in sequence. When in view mode it lets views execute in their client thread in parallel. When it switches from view-mode to action-mode, it waits for all current running views to finish their execution before it starts executing actions.</div>

<div class="standard" id='magicparlabel-1438'>The pseudo code for the main loop of the executor can be seen in algorithm&nbsp;<a href="#alg_Execution_main_loop">1</a>.</div>



<div class='float-algorithm'><div class='float-listings'><pre class ='listings'>loop
	t &lt;- get next task from queue
	if(t is an action)
		if(not in action-mode)
			wait for running views to finish
			set mode to action-mode
		executeAction(t)
	else
		set mode to view-mode
		allow t to execute in client thread</pre></div>


<div class="plain_layout" id='magicparlabel-1457'><span class='float-caption-Standard float-caption float-caption-standard'>Algorithm 1:  <a id="alg_Execution_main_loop" />
Execution main loop</span></div>
</div>


<div class="standard" id='magicparlabel-1462'>In the current implementation of the executor, a single FIFO queue is used for both <em>actions</em> and <em>views</em>. This provides good fairness, but if <em>actions</em> and <em>views</em> are highly interleaved, in the sense that there are no large groups of <em>views</em> that are not interrupted by <em>actions</em>, then we do not get much parallelization. We could instead have two FIFO queues, one for <em>actions</em> and one for <em>views.</em> In that way, it would be possible to parallelize the views in larger chunks. We could then have an algorithm that would process <em>views</em> until the <em>view</em> queue is empty and then switch to process <em>actions</em> until the <em>action</em> queue is empty. In order to avoid starvation we could set a maximum number of transactions to process before looking to the other kind. It is important to notice here that although this strategy could lead to a non-chronological execution of transactions, the chronology would be preserved within each client thread. This is guaranteed, since whenever a client is executing a transaction, control is never returned to the client thread before the transaction has been both executed and persisted.</div>
<h5 class="paragraph" id='magicparlabel-1463'><span class="paragraph_label"></span> <a id="subsec_Persistence" />
Data Persistence</h5>
<div class="standard" id='magicparlabel-1464'>In EDMA the current state of the data model is kept in RAM, which is a volatile storage that is lost in the case of a power failure, or any other type of system failures. For many applications it is crucial to store data in a more persistent way so the state of the data model can be preserved and regenerated even in the case of a power failure, system reboots an so on. Sometimes it is enough to store data on a local hard drive, other times applications need a more secure persistence where data is stored in several different places.</div>

<div class="standard" id='magicparlabel-1465'>In EDMA the persistence module is operated on through a simple interface, making it possible to have different persistence module implementations, with different strategies for data persistence. Although there is currently only one implementation, switching between different persistence strategies can be made into a matter of changing one line of code for the user. In the following, we describe the strategy that we have implemented in this project.</div>

<div class="standard" id='magicparlabel-1466'>Every time an action is executed in EDMA, it generates a sequence of primitive operations. If the execution fails for some reason, these operations are rolled back (as described in section <a href="#subsec_Transactions">4.2.5</a>) and nothing is sent on to the persistence module. If the action executes successfully, the sequence of operations that describe all changes made to the state of the data model instance, is put into an object called a <em>persistence unit</em>. Besides the sequence of operations, the persistence unit also has two callback functions, one to call if the data is successfully persisted and another one to call if the persistence of the data fails for some reason. This persistence unit is then handed over to the persistence module and whenever the persistence module has persisted the data or failed in its attempt to do so, it will call the corresponding callback function on the persistence unit.</div>

<div class="standard" id='magicparlabel-1467'>This effectively means that every time an action successfully makes changes to the state of the data model instance, these changes are persisted as an atomic unit. So when the need for recovery arises, these changes can be replayed in sequence to re-generate the state. This also means that a full history of states of the data model is preserved and could be re-generated if needed.</div>

<div class="standard" id='magicparlabel-1468'>It is important to note here, that to honor the durability property, a persistence unit may never be considered successfully persisted before all preceding persistence units has also been successfully persisted. Actually <em>views</em> also need to pass through the persistence module as persistence units although they do not have anything to persist. The reason for this is that the result of a view is not considered valid or durable before all preceding actions have been successfully persisted. If the persistence module fails to persist a persistence unit, then all succeeding persistence units must also be considered failed, as shown in Figure&nbsp;.</div>



<div class="standard" id='magicparlabel-1483'>This may seem like a very bold form of error handling – shutting down the whole system, when one thread's transaction fails to be persisted. However, if the persistence module fails, it means that the disk failed to write data to the log file, which indicates that there might be a problem with the disk. Therefore, it wouldn't make sense to continue writing any subsequent transaction to that file. The failure could be caused by bad sectors on the disk, which means that it could be possible to successfully write to a new log file. A clever implementation of the persistence module (in contrast to our simple proof-of-concept implementation) could retry writing to the file a number of times, and upon failure, start writing to a new log file. If that also fails, writing to another disk could be attempted. Taking it even further, if writing to any of the disks fails, the system could fall back on writing to a network socket.</div>

<div class="standard" id='magicparlabel-1484'>If the system really fails to persist a transaction, EDMA is closed down, and an administrator will have to manually start the system again (after running any disk-utility to flag out bad sectors.) Upon restart, the system reads the whole log file, restoring the data model to a state identical to the one at the time before the crash.</div>
<h4 class="subsubsection" id='magicparlabel-1485'><span class="subsubsection_label">4.5.3</span> SQL Runtime System</h4>
<div class="standard" id='magicparlabel-1486'>When we planned this thesis, we intended to include a SQL implementation of the runtime system that would store the data model instances in a traditional SQL database. </div>

<div class="standard" id='magicparlabel-1487'>There are several reasons why this would be a good idea. First, databases are very mature as a technology, and the database engines are highly sophisticated and optimized for giving high throughput, serving many concurrent users, and storing large amounts of data. It would add some extra work for the user in setting up and connect to a data base, but this would be rewarded by good scalability in the amount of data that could be stored. He could always create prototypes with the embedded java runtime and then switch to the SQL runtime when the need for storing more data showed up.</div>

<div class="standard" id='magicparlabel-1488'>However, we chose not to implement an SQL database backed runtime, because it showed to be more complicated than expected, after we had invented our value domains system. In an SQL database, there is a finite set of primitive value domains. In our value domain system, value domains can be constructed arbitrarily complex, and therefore there exists an unbounded number of different value domains. This makes it a non-trivial task to map our entities to SQL tables. It came to a point where we either had to give up the value domain system or the SQL implementation due to time constraints.</div>

<div class="standard" id='magicparlabel-1489'>Given our focus in this project, of investigating the possibilities of reducing the efforts of coming from a conceptual model to a working prototype and explore alternative ways of working with data models, we chose to keep the value domain system and postpone the SQL implementation.</div>
<h4 class="subsubsection" id='magicparlabel-1490'><span class="subsubsection_label">4.5.4</span> JDBM3 Runtime System</h4>
<div class="standard" id='magicparlabel-1491'>The example runtime has the limitation that it can only hold as much data, as the RAM can contain. Further more, there is a significant memory footprint in using the example runtime, since all data values are being wrapped in a number of Java objects, taking up memory (see the Evaluation section for more details.) For that reason, we have chosen to exploit the flexibility of the EDMA system, and implemented the usage of disk-backed sets and maps, using the open source framework JDBM3. JDBM3 is a key-value store with a number of disk-backed collections, with the goal of being able to handle billions of items without being limited by memory. The point of using JDBM3 in EDMA was to have both large amounts of data, but also to make it possible to perform set operations on large sets (for results or partial results in actions and views.)</div>

<div class="standard" id='magicparlabel-1492'>It turned out that there were some hindrances, making it difficult to obtain good performance using JDBM3. In order to reach a good performance level, we need to disable auto-commit in JDBM3. However, having to manually call commit would require substantial changes in the infrastructure of the runtime system, therefore complicating the task more than the benefit added. Further more, it was found that JDBM3 has a bug, preventing EDMA from using multiple threads access the data store. That said, since the authors of JDBM3 keep the project alive with frequent updates, it would be a matter of time before the bug gets fixed.</div>



<h2 class="section" id='magicparlabel-1495'><span class="section_label">5</span> <a id="sec_Evaluation" />
Evaluation</h2>
<div class="standard" id='magicparlabel-1496'>In this section, we address the issue of evaluating the EDMA system, both with respect to its functional usability, and with respect to a few performance parameters. Since one of the main points with EDMA is to make it easy for the user to come from an idea of a data model, to working implemented code reflecting that model, we briefly discuss the steps that are required for doing so.</div>

<div class="standard" id='magicparlabel-1497'>Although performance hasn't been the main focus of this project, we have created a few simple performance tests. These are presented and briefly discussed in Appendix <a href="#sec_PerformanceEvaluation">C</a>.</div>
<h3 class="subsection" id='magicparlabel-1498'><span class="subsection_label">5.1</span> Workflow</h3>
<div class="standard" id='magicparlabel-1499'>The flow of creating a data model implementation can be divided into 4 phases:</div>

<ul class="itemize" id='magicparlabel-1500'><li class="itemize_item">1 – Model definition</li>
<li class="itemize_item">2 – Code generation (run the EDMA compiler)</li>
<li class="itemize_item">3 – action and view implementation (create the necessary code in the action and view stub classes)</li>
<li class="itemize_item">4 – data model instantiation (create an instance of the data model to use in the external application)</li>
</ul>
<div class="standard" id='magicparlabel-1504'>Designing and implementing a concrete data model can be seen as an iterative process. In a prototyping process, where not all business requirements may be strictly given, the user might switch between phase 1, 2 and 3 for a number of iterations. New requirements or ideas may continually influence and change the design for a number of iterations. Therefore, it is important that the user can easily go back and update the definition files, re-generate the code, and fill out stub code of newly created actions and views. And if the latest change to a definition file has resulted in broken code, it must be easy to find and correct the files in question. In the following, we evaluate the four steps that make up the process of using EDMA.</div>
<h5 class="paragraph" id='magicparlabel-1505'><span class="paragraph_label"></span> Data Definition</h5>
<div class="standard" id='magicparlabel-1506'>Data definition is done by creating one, or many, data definition files, adhering to the syntax of the EDMA definition language. The definition of the kinds will itself result in a number of iterations, where the user realizes the need for value domains, relations and actions and views. For example, when creating the Person, the user realizes the need for the attribute value domains Name, Date, PhoneNumber and Balance. The following is noticed.</div>

<ul class="itemize" id='magicparlabel-1507'><li class="itemize_item">Each value domain and each relation takes up one line of code. Each kind takes up one line for the declaration, plus one line for each attribute. Actions and views take up one line for the declaration, one line for the description, one for the error code, and one line for each input and output.</li>
<li class="itemize_item">The number of relations will rarely diverge significantly from the number of kinds.</li>
<li class="itemize_item">The number of actions will often be significantly larger than the number of kinds and relations (the user can have creation and deletion actions for each kind and for each relation, and additional views and actions.)</li>
<li class="itemize_item">Value domain files with definitions for common value domains (Date, Time, Email, URL, etc.) can be reused, significantly reducing the time it takes to create the data model definition.</li>
</ul>
<div class="standard" id='magicparlabel-1511'>Because of the number, and line-span, of actions and views, we reason that writing the action and views is the most time consuming process, when writing the edma-files.</div>
<h5 class="paragraph" id='magicparlabel-1512'><span class="paragraph_label"></span> Running the EDMA Compiler</h5>
<div class="standard" id='magicparlabel-1513'>Running the EDMA compiler is a question of running a Java program. If there are errors in any of the edma-files, the compiler gives the user a message stating the error type, and the location of the error. After the compiler has been run, the user should make sure that the IDE shows the newest version of the directory listing (in Eclipse, this is done by right clicking on the project folder, and choosing Refresh.)</div>
<h5 class="paragraph" id='magicparlabel-1514'><span class="paragraph_label"></span> Implementing Actions and Views</h5>
<div class="standard" id='magicparlabel-1515'>The stub code that is generated for actions and views purposefully contains a syntax error. Because the Java compiler will refuse to compile, and show the problematic files, the user can quickly find the action and view stub classes that need to be filled out. This is an extremely useful feature when working iteratively.</div>
<h5 class="paragraph" id='magicparlabel-1516'><span class="paragraph_label"></span> Instantiation</h5>
<div class="standard" id='magicparlabel-1517'>Instantiating the created data model is done in very few steps, by calling a static method to retrieve a meta model instance, and creating a runtime factory by which to obtain a model instance. Calling the actions and views is easy, since the user knows which names he gave the actions and views. The external data model interface contains methods with names identical to the actions and views.</div>
<h3 class="subsection" id='magicparlabel-1518'><span class="subsection_label">5.2</span> Implementing the Diving School</h3>
<div class="standard" id='magicparlabel-1519'>We have implemented the Diving School data model using EDMA. Through implementing it, several observations have been done.</div>

<ul class="itemize" id='magicparlabel-1520'><li class="itemize_item">The EDMA system works. We are able to create data definition files, generate Java code, and start an instance of the data model. We are able to insert, change and remove entities and connections.</li>
<li class="itemize_item">The EDMA system is well suited for a prototyping workflow. Adding, changing and removing kinds or relations breaks the code only in the implementation in the stub-code sections that depend on the changes. </li>
<li class="itemize_item">The value domain system has proven to be an extremely helpful feature. Calling an action or a view requires specific value domains, which types of values are given as arguments or returned.</li>
</ul>


<h2 class="section" id='magicparlabel-1525'><span class="section_label">6</span> Conclusion</h2>
<div class="standard" id='magicparlabel-1530'>In this thesis work we have designed and implemented EDMA, a software system that can assist a java programmer in the process of converting a conceptual data model into a working implementation of the model in java. The system assists the process by:</div>

<ol class="enumerate" id='magicparlabel-1531'><li class="enumerate_item"><b>Reducing the amount of code the programmer must write.</b>
<br />

This is done by auto generating an object oriented representation of the data model and the interface for the data model with corresponding java stub classes for the implementation of the interface. The programmer will only have to write the interface implementation using the object oriented representation. The code generation is based on a definition of the data model written in a simple language designed for the purpose. EDMA can easily be extended to support a graphical user interface for defining the data model.</li>
<li class="enumerate_item"><b>Removing the task of implementing bi-directional entity-relationships</b>
<br />

This is automatically implemented in the generated object oriented model.</li>
<li class="enumerate_item"><b>Removing the task of implementing remote access to the instances of the data model.</b>
<br />

EDMA automatically generates a server program and a client proxy to facilitate remote access to the data model instances.</li>
<li class="enumerate_item"><b>Providing user interfaces for data input</b>
<br />

EDMA automatically generates a textual user interface based on the defined data model interface. The user interface supports automatic value validation based on the constraints defined on the value domains. EDMA can easily be extended to generate other types of user interfaces e.g. a HTML based interface.</li>
<li class="enumerate_item"><b>Ensuring thread-safe access to the model instances in a multithreaded environment</b>
<br />

The instances of the generated data model are thread safe.</li>
<li class="enumerate_item"><b>Offering automatic persistence of the instances of the data model
<br />

</b>The instances of the data model can be automatically and durably persisted to a file. The modular design of the example runtime makes it easy to implement alternative persistence strategies.</li>
</ol>
<div class="standard" id='magicparlabel-1537'>EDMA includes a simple but yet expressive value domain system that can be used to define fine grained project domain specific value domains for immutable data values. The defined value domains are automatically transformed into java implementations with support for:</div>

<ul class="itemize" id='magicparlabel-1538'><li class="itemize_item">streaming,</li>
<li class="itemize_item">conversion to and from strings,</li>
<li class="itemize_item">Javas container classes, by sensible implementations of equals, hashCode and compareTo,</li>
<li class="itemize_item">automatic value validation,</li>
<li class="itemize_item">interactive textual user interface for value creation through a simple terminal interface.</li>
</ul>
<h5 class="paragraph" id='magicparlabel-1543'><span class="paragraph_label"></span> State of the system</h5>
<div class="standard" id='magicparlabel-1544'>EDMA is still in a prototype state and has not been systematically tested. But we have successfully used it on various experimental data models, including the diving school example model from this report.</div>


<h2 class="section" id='magicparlabel-1547'><span class="section_label">7</span> Future Work</h2>
<div class="standard" id='magicparlabel-1548'>There are a number of features that could still be implemented in EDMA, especially related to usability. By trying to use EDMA in various situations, we have found that the time the user spends on reaching a readily usable data model can be even further reduced. For example, we could auto-generate CRUD actions and views (methods for Creating, Reading, Updating and Deleting).</div>

<dl class='description' id='magicparlabel-1549'><dt class="description_label">CRUD&nbsp;Actions&nbsp;and&nbsp;Views</dt>
<dd class="description_item"> One way of helping the user, is to auto-generate actions and methods for creating, reading, updating and deleting (CRUD) data entities. At first, it was our philosophy that the user should only have the actions and views defined by himself, in order to not clutter the API with functions that wouldn't be used. However, by creating data models with our system ourselves, we have found that we almost always end up creating the most basic actions and views for each kind:</dd>
</dl>

<ul class="itemize" id='magicparlabel-1550'><li class="itemize_item">Insert a new entity of a given kind.</li>
<li class="itemize_item">Get entities based on attribute values where indexes are defined.</li>
<li class="itemize_item">Updating of the mutable attributes in a kind.</li>
<li class="itemize_item">Delete an entity.</li>
</ul>
<div class="standard" id='magicparlabel-1554'>As of the current version of EDMA, the user has to define these 4 methods in an <span style='font-family:monospace;'>.edma</span>-file, and implement them in the generated Java stub-code. Further more, for each relation, the user often needs to connect two or more entities, or to delete a connection between two or more entities.</div>

<div class="standard" id='magicparlabel-1555'>It would require two changes to the system, to auto-generate CRUD and relation-methods:</div>

<ul class="itemize" id='magicparlabel-1556'><li class="itemize_item">Changing the compiler to add meta-actions and meta-views, for each kind and each relation.</li>
<li class="itemize_item">Changing the generator to generate the implementations of the actions and views, instead of having the user to fill in stub-code in the auto-generated actions and views.</li>
</ul>
<div class="standard" id='magicparlabel-1558'>Both of these two tasks are trivial, and could be implemented in a short time. It would spare the user for the tasks of implementing tedious, simple actions and views, at the cost of either putting possibly unused functions in the generated data model API or having the user define in the data model definition what methods he wants auto generated on the individual kinds and relations. </div>

<dl class='description' id='magicparlabel-1559'><dt class="description_label">Multiple&nbsp;APIs</dt>
<dd class="description_item"> In a setting with many users, it is often possible to distinguish between access rights of users. An extension to the data model would be to group actions and views into interfaces. For example, an interface for an Admin user could contain one set of actions and views, while an interface for a User could contain a different set of actions and views.</dd>
<dt class="description_label">Simplifying&nbsp;the&nbsp;Value&nbsp;Domain&nbsp;System</dt>
<dd class="description_item"> The value domain system can be made more simple, by removing some of the primitive types. For example, the types Integer and Long could be substituted with a single Number type, and the Float and Double types could be substituted with a single Decimal type. By inspecting range constraints it is possible to determine the best representation.</dd>
<dt class="description_label">Google&nbsp;App&nbsp;Engine</dt>
<dd class="description_item"> Google App Engine uses a data repository called High Replication Datastore (HRD), that operates on entities and entity groups. They offer strong consistency within an entity group, so it might be possible to implement an EDMA runtime backed by the Google App Engines data repository, that maps a data model instance in EDMA to an entity group in Google App Engines data repository.</dd>
</dl>


<h2 class="section" id='magicparlabel-1564'><span class="section_label">A</span> <a id="sec_EDMAtutorial" />
EDMA tutorial</h2>
<div class="standard" id='magicparlabel-1565'>This tutorial will be loosely based on the Diving School example in the report. If you have not already read through this example, now would be a good time to at least skim through it.</div>

<div class="standard" id='magicparlabel-1566'>To follow this tutorial you need eclipse (or another Java Development Environment) and the EDMA.jar file. In this tutorial we will take you through all the steps that are required to build a working example of the Diving School Course Registration System with EDMA. This includes the following steps:</div>

<ul class="itemize" id='magicparlabel-1567'><li class="itemize_item">Set up a new EDMA project in eclipse.</li>
<li class="itemize_item">Define global value domains.</li>
<li class="itemize_item">Define the data model for the course registration system.</li>
<li class="itemize_item">Define the actions and views for the course registration system.</li>
<li class="itemize_item">Implement the actions and views.</li>
<li class="itemize_item">Connect to the runtime and use the course registration system.</li>
</ul>
<h3 class="subsection" id='magicparlabel-1573'><span class="subsection_label">A.1</span> Set up a new EDMA project</h3>

<ol class="enumerate" id='magicparlabel-1574'><li class="enumerate_item">Create a new java project in eclipse named <em>DivingSchool</em>.</li>
<li class="enumerate_item">Right click the project in package explorer and choose <em>new</em>  <em>Folder</em>. Write <em>lib</em> as the name of the folder and click <em>finish</em>.</li>
<li class="enumerate_item">Copy EDMA.jar to the newly created folder. Right click the project in package explorer and choose <em>refresh</em>.</li>
<li class="enumerate_item">Right click the project in the package explorer and choose <em>properties</em>. Now click on <em>Java Build Path</em> in the left part of the window. In the right part of the window click on the tab <em>Libraries</em> and then on the button <em>Add JARs... </em>Navigate to the <em>lib</em> folder and choose the EDMA.jar file. Click <em>OK</em> in both windows.</li>
<li class="enumerate_item">Right click on the project in package explorer and choose <em>new</em>  <em>Folder</em>. Write <em>edma</em> as the name of the folder and click <em>finish</em>. Right click on the newly created edma folder and choose <em>new</em>  <em>File</em>. Write Common.edma as the file name and click <em>finish</em>. Right click the new Common.edma file and choose <em>Open with</em>  <em>Text Editor. </em>Now write this line exactly:Make sure you write exactly the above line and then press <em>Ctrl-S</em> to save the file. You have now created your first global value domain called Name. The values in Name are strings that are at least 1 character long. You will learn more about how to create value domains in a moment.<div class='float-listings'><pre class ='listings'>ValueDomain Name : String[1..MAX]</pre></div>
</li>
<li class="enumerate_item">Right click on the project in package explorer and choose <em>new</em>  <em>Class</em>. Write Make as the name of the class and click finish. Write this code into the class:Make sure you replace the paths with the actual paths on your machine. Now right click on this class in the package explorer and choose <em>Run As</em>  <em>Java Application</em>. The output should look like this: Now right click the project in package explorer and choose <em>refresh</em>. You should now see some generated packages in the project. Every time you make any changes to your EDMA files you must run this Make class and refresh the project.<div class='float-listings'><pre class ='listings Java'>import edma.generator.EdmaGenerator;

public class Make
{
	public static void main(String[] args)
	{
		//This will be the name of the environment
		String environmentName = "DivingSchool";
		//This is the path to the folder with your EDMA files
		String edmaSrcDir = "C:/Workspace/DivingSchool/edma";
		//This is the path to the java src folder
		String javaSrcDir = "C:/Workspace/DivingSchool/src";
		//This is the root package of the generated code
		String rootPackage = "tutorial";
		new EdmaGenerator(environmentName,
						  edmaSrcDir,
						  javaSrcDir,
						  rootPackage).make();
	}
}</pre></div>
<div class='float-listings'><pre class ='listings'>Gathering and compiling input files...
Generating environment generator...
Generating value domain classes...
Deleting generated directories...
Writing generated java files...
All done!</pre></div>
</li>
</ol>
<div class="standard" id='magicparlabel-1640'>When you run the Make class it creates a new instance of the EdmaGenerator class and calls the make() method on it. The compiler now looks for files in the edma folder and its sub folders that has the extension &ldquo;.edma&rdquo;. All these files are then compiled to a meta model and the generator then uses this meta model to generate all the java interfaces and classes. If you look at the generated packages and java files, you should see a package called <em>generated</em> as a sub package of<em> tutorial.divingschool </em>(depending on the names you gave for the project and root package)<em>.</em> This package and everything inside it will be deleted and re-generated whenever you call the make() method on the generator class, so you should never put anything into this package or make changes to the files inside this package or any of its sub packages.</div>
<h3 class="subsection" id='magicparlabel-1641'><span class="subsection_label">A.2</span> Define Global Value Domains</h3>
<div class="standard" id='magicparlabel-1642'>Now you should have a newly created EDMA project up and running with one global value domain called Name. Now lets define some more global value domains. We need a Date value domain that contains a year, a month and a day of month. All values from this value domain should be valid dates. First lets create the value domains Year, Month and DayOfMonth:</div>
<div class='float-listings'><pre class ='listings'>// Year, Month and DayOfMonth
ValueDomain Year : Integer[0..9999]
ValueDomain Month : Integer[1..12]
ValueDomain DayOfMonth : Integer[1..31]</pre></div>


<div class="standard" id='magicparlabel-1650'>Add those value domains to the Common.edma file. You can make comments in edma files just like in java files with // and /* ... */.</div>

<div class="standard" id='magicparlabel-1651'>Before we continue, we will take a quick look at how these value domains work. Run Make and refresh the project. Now create a new Test class in the default package that looks like this:</div>


<div class='float-listings'><pre class ='listings Java'>import tutorial.divingschool.generated.valuedomains.Year;
import edma.valuedomains.exceptions.InvalidValueException;

public class Test
{
	public static void main(String[] args)
	{
		//A valid year
		Year foo = Year.create(1988);
		System.out.println(foo.toString());
		foo = Year.fromString("1807");
		Year bar = Year.create(1807);
		System.out.println("foo equals bar: " + foo.equals(bar));
		System.out.println("Is -11 a valid year: "
			+ Year.isValidYear(-11));
		System.out.println("Is 1990 a valid year: "
			+ Year.isValidYear(1990));
		//Lets try to make an invalid year:
		try
		{
			bar = Year.create(-54);
		}
		catch(InvalidValueException e)
		{
			System.out.println(e.getMessage());
		}
	}
}
</pre></div>


<div class="standard" id='magicparlabel-1685'>As you can see from this code there are a few static methods on the Year class that can be used to create new values from the Year value domain. There is also a method to get a value from a human user through a simple text based terminal:</div>


<div class='float-listings'><pre class ='listings Java'>Year.fromTerminal(new SimpleTerminal());</pre></div>


<div class="standard" id='magicparlabel-1691'>You can also take a look at the generated Year.java file to see all the methods. </div>

<div class="standard" id='magicparlabel-1692'>Now we can create the Date value domain as a <em>Struct</em> value domain that uses the Year, Month and DayOfMonth value domains. Add the following to the Common.edma file:</div>
<div class='float-listings'><pre class ='listings'>//Date
ValueDomain Date : Struct
{
	year : Year,
	month : Month,
	day : DayOfMonth
}</pre></div>


<div class="standard" id='magicparlabel-1703'>Notice that in a <em>Struct</em> value domain you can only refer to value domains that are defined elsewhere. The order is not important, you can define Year, Month and DayOfMonth before or after Date or even in a separate file if you want. But you can not use the basic value domains like String, Integer etc in a <em>Struct</em> value domain. So this is NOT possible:</div>


<div class='float-listings'><pre class ='listings'>//Invalid definition of Date
//Will NOT compile
ValueDomain Date : Struct
{
	year : Integer[0..9999],
	month : Integer[1..12],
	day : Integer[1..31]
}</pre></div>


<div class="standard" id='magicparlabel-1716'>Now run Make and refresh the project. The Date value domain is a <em>Struct</em> value domain that are build from other value domains. Each <em>field</em> in a <em>Struct</em> value domain consist of a name and a value domain. A <em>field</em> in a struct can be optional, which means that the value may be <em>null</em>. To make a field optional all you have to do is add a question mark after the name of the field. Here is an example of a Struct value domain with some optional fields:</div>


<div class='float-listings'><pre class ='listings'>//Value Domain with optional fields
ValueDomain FooBar : Struct
{
	foo? : SomeValueDomainName,
	bar : SomeValueDomainName,
	foobar? : AnotherValueDomainName
}</pre></div>


<div class="standard" id='magicparlabel-1728'>Here foo and foobar are optional so they may be <em>null</em>. If a field is not optional then a NullPointerException is thrown if it is set to <em>null</em>.</div>

<div class="standard" id='magicparlabel-1729'><em>Struct</em> value domains has a natural order where the significance of the fields follows their position in the <em>Struct</em>, with the first field being the most significant and the last field least significant. So if we had put the fields in another order, then dates would not sort properly when using their natural order. Here is some examples of how you can create values in the Date value domain.</div>
<div class='float-listings'><pre class ='listings Java'>import tutorial.divingschool.generated.valuedomains.Date;

public class DateTest
{
	public static void main(String[] args)
	{
		//Create a date with the create() method
		Date foo = Date.create().year(2012).month(2).day(15);
		System.out.println(foo.toString());
		//Create a date from a string representation of the date
		Date bar = Date.fromString("(2012, 3, 4)");
		
		//What happens if we create an invalid date like this 2012-2-30
		Date notValid = Date.create().year(2012).month(2).day(30);
		System.out.println(notValid.toString());
	}
}</pre></div>


<div class="standard" id='magicparlabel-1750'>Notice how the creation uses fluid interfaces to make it easier too read the code. This can be very useful if you create struct value domains with many fields. There is a separate interface for each field you set that returns the interface to set the next field, so it is not possible to leave out a field without getting a compile error from the java compiler. Try it out, write Date foo = Date.create().year(1988).day(15) and see that the compiler will not accept it because the month is missing. Also the order of the fields is fixed when creating the values, so Date.create().month(5).year(1788).day(7) will not compile either.</div>

<div class="standard" id='magicparlabel-1751'>At first this strictness in the creation can seem a little rigid, but if you later on add another field to a struct value domain, then the compiler makes sure that you take this new field into account everywhere you create values with that value domain.</div>

<div class="standard" id='magicparlabel-1752'>If you want, try to create a TreeSet&lt;Date&gt; and put some dates into it, they should be correctly sorted by their natural order when you iterate over the set.</div>

<div class="standard" id='magicparlabel-1753'>When creating a Date value, it is automatically tested that the year, month and day are within the allowed limits for their value domains, but what about invalid dates as 30/2/2012? These are not caught at the moment. We can add a user implemented constraint to do this:</div>


<div class='float-listings'><pre class ='listings'>//Date
ValueDomain Date : Struct
{
	year : Year,
	month : Month,
	day : DayOfMonth
} Constraints[validDate]</pre></div>


<div class="standard" id='magicparlabel-1765'>This is done by adding the keyword <em>Constraints </em>followed by a comma separated list of names in square brackets. In this case we only added one constraint. Now run Make and refresh the project. Try to run the DateTest class above again and see what happens. It should throw an exception saying that the validDate constraint is not implemented and where you can implement it. Navigate to the class mentioned in the exception. It should look like this:</div>


<div class='float-listings'><pre class ='listings Java'>package tutorial.divingschool.usercode.valueconstraints.date;

import tutorial.divingschool.generated.valuedomains.Date;

/**
 * This class is the implementation class for the Date constraint validDate
 * No description given
 */
public class ValidDate
{
    /**
     * Checks the validDate constraint for the Date value domain.
     * No description given
     * @param date  The instance value to be checked
     * @return      the reason the constraint is violated, or &lt;tt&gt;null&lt;/tt&gt; if
     *              the constraint is not violated
     */
    public static String checkValidDate(Date date)
    {
        // Implementation of constraint validDate
        // WARNING : Any code outside the following begin and end tags
        // will be lost when re-generation occurs.
        
        // EDMA_non-generated_code_begin
        
        //TODO: Implement the constraint validDate here...
        return "Constraint not implemented. Implement in tutorial.divingschool.usercode.valueconstraints.date.ValidDate";
        
        // EDMA_non-generated_code_end
    }
}</pre></div>


<div class="standard" id='magicparlabel-1801'>The class is in a sub package of the <em>usercode</em> package. All classes that you need to put code into will be placed in the usercode package or its sub packages. Now lets implement the validDate constraint to only allow valid dates. This involves checking for leap years. Be sure to only put your code between the <em>EDMA_non-generated_code_begin</em> and the <em>EDMA_non-generated_code_end</em> tags, since anything outside these tags will be re-generated when you run Make (except any imports you might add, these will be preserved too). Now try to add the following code between the <em>EDMA_non-generated_code_begin</em> and the <em>EDMA_non-generated_code_end</em> tags: </div>


<div class='float-listings'><pre class ='listings Java'>    // EDMA_non-generated_code_begin
    int day = date.day().value();
    if(day &lt;= 28) return null;
    switch(date.month().value())
    {
      case 2:
        if(day &gt; 29) return "February can not have more than 29 days";
        // day == 29
        int year = date.year().value();
        if(year % 4 == 0 &amp;&amp; (!(year % 100 == 0) || year % 400 == 0)) return null;
        return Integer.toString(year)
          + " is not a leap year, so February can not have 29 days";
      case 4:
      case 6:
      case 9:
      case 11:
        if(day &lt;= 30) return null;
        return "April, June, September and November can not have more than 30 days";
      default:
        return null;
    }
    // EDMA_non-generated_code_end</pre></div>


<div class="standard" id='magicparlabel-1828'>As you see here the return value is a <em>String</em>. You should return <em>null</em>, if the value is valid, otherwise you should return an error message that says why the value is not valid. After you have updated this file, try to run the DateTest again. This time only the invalid dates like 30/2/2012 should fail.</div>

<div class="standard" id='magicparlabel-1829'>With user implemented constraints you can make value domains that are very precise in which values they accept and which they do not accept. You should always try to make your value domains as precise as possible, because then you will catch malformed input as early as possible. The value domains are your guarantee that the input to and output from your <em>actions</em> and <em>views</em> are valid. As an example of a very specialized value domain, we will make a value domain called FunnyInt that only contains positive integers that are even, but not dividable by 10:</div>


<div class='float-listings'><pre class ='listings'>//FunnyInt
ValueDomain FunnyInt : Integer[1..MAX] Constraints[even, notDividableBy10]</pre></div>


<div class="standard" id='magicparlabel-1836'>Add the above to your Common.edma file and then run Make and refresh the project. Now find the file ${project}.usercode.valueconstraints.funnyint.Even.java and replace the code between the <em>EDMA_non-generated_code_begin</em> and the <em>EDMA_non-generated_code_end</em> tags with this:</div>


<div class='float-listings'><pre class ='listings Java'>if(funnyInt.value() % 2 == 0) return null;
return funnyInt.value() + " is not even!";</pre></div>


<div class="standard" id='magicparlabel-1843'>In the same sub package find the file NotDividableBy10.java and replace the code between the <em>EDMA_non-generated_code_begin</em> and the <em>EDMA_non-generated_code_end</em> tags with this:</div>


<div class='float-listings'><pre class ='listings Java'>if(funnyInt.value() % 10 == 0) return funnyInt.value() + " is dividable by 10!";
return null;</pre></div>


<div class="standard" id='magicparlabel-1850'>Make a test class and try out your new FunnyInt value domain.</div>

<div class="standard" id='magicparlabel-1851'>We actually do not need the FunnyInt value domain in the course registration system after all, so feel free to delete it from the Common.edma file and regenerate. When you do this, you will notice that the Even.java and NotDividableBy10.java files are still there, but now they do not compile because the FunnyInt value domain no longer exists. You will have to delete these files yourself. EDMA will never delete files inside the usercode package or its sub packages. Only stuff outside the <em>EDMA_non-generated_code_begin</em> and the <em>EDMA_non-generated_code_end</em> tags will be overwritten by EDMA in the <em>usercode</em> package and its sub packages. But keep in mind that files you put in the <em>generated</em> package or its sub packages will be deleted by EDMA.</div>

<div class="standard" id='magicparlabel-1852'>Now lets make the value domains that we need to create the Person Kind. The Person Kind should have a name, an email, a mobile phone number and a credit balance. The credit balance should be a non-negative integer, since we do not allow negative credit. We already have a Name value domain that is just a String of length 1 or more. Lets make the other value domains:</div>


<div class='float-listings'><pre class ='listings'>//Email
ValueDomain Email : String[3..MAX]
//Mobile
ValueDomain Mobile : String[8]
//Credit
ValueDomain Credit : Integer[0..MAX]</pre></div>


<div class="standard" id='magicparlabel-1863'>As seen here the String value domains can both have a length range like 3..MAX and 3..256 or it can just have a single length value like in the mobile value domain. This means that a value from the mobile value domain must be a string that are exactly 8 characters long. We could also have used the notation 8..8 which is the same.</div>

<div class="standard" id='magicparlabel-1864'>String value domains can also have regular expressions added to them. These are added in square brackets after the length constraints. The syntax for the regular expressions should be just like you would write it in java as a hard coded string surrounded by double quotes. Lets add a regular expression to the Email value domain and the Mobile value domain:</div>


<div class='float-listings'><pre class ='listings'>//Email
ValueDomain Email : String[3..MAX]
["[\\w-]+(\\.[\\w-]+)*@[A-Za-z0-9]+(\\.[A-Za-z0-9]+)*(\\.[A-Za-z]{2,})"]
//Mobile
ValueDomain Mobile : String[8]["[0-9]+"]</pre></div>


<div class="standard" id='magicparlabel-1874'>This is not a perfect email regular expression, but it serves fine as an example of how to use regular expressions on String value domains. In the mobile regular expression we do not need to test that the length is 8, since this is already being tested in the length constraint. You should try it out now by making some valid and invalid emails and mobile phone numbers in a test class.</div>

<div class="standard" id='magicparlabel-1875'>The last thing we will look at before we move on to the data model is how to create a <em>List</em> value domain. As an example we will create a value domain where the values are lists of dates:</div>


<div class='float-listings'><pre class ='listings'>//DateList
ValueDomain DateList : List&lt;Date&gt;</pre></div>


<div class="standard" id='magicparlabel-1882'>Run Make and refresh the project. Now here is some examples of how you can create and use values from the DateList value domain:</div>


<div class='float-listings'><pre class ='listings Java'>DateList myDateList = DateList.begin()
								.add(Date.fromString("(2012, 2, 1)"))
								.add(Date.fromString("(2012, 4, 5)"))
								.add(Date.fromString("(2012, 6, 26)"))
								.end();
System.out.println(myDateList);		
for(Date date : myDateList)
{
	System.out.println(date);
}

DateListBuilder builder = DateList.begin();
for(int i = 1; i &lt;= 29; ++i)
{
	Date d = Date.create().year(2012).month(2).day(i);
	builder.add(d);
}
DateList datesInFebruary = builder.end();

System.out.println("The dates in february 2012:");
for(Date date : datesInFebruary)
{
	System.out.println(date);
}

DateList someDates = DateList.fromString("((1999,1,3),(1988,2,5),(1745,3,4))");
System.out.println(someDates);
DateList empty = DateList.fromString("()");
System.out.println(empty);</pre></div>


<div class="standard" id='magicparlabel-1916'>It is important to notice that like all other values from value domains, list values are also immutable. The value is not created until the end() method is called on the builder interface and when the value is created, it can never be changed. So in the shown example the DateList datesInFebruary will always contain the same dates in the same order that they where added to the builder.</div>

<div class="standard" id='magicparlabel-1917'><em>List</em> value domains has a natural order, where the elements are compared one by one from the beginning of the lists. So if we have lists of integers, then (1,3) is greater than (1,2,3), but (1,2) is smaller than (1,2,3). This is the same way that Strings in java is naturally ordered as lists of characters. </div>

<div class="standard" id='magicparlabel-1918'>This is all you need to know about value domains for now. </div>
<h3 class="subsection" id='magicparlabel-1919'><span class="subsection_label">A.3</span> Defining the Data Model</h3>
<div class="standard" id='magicparlabel-1920'>Create a new file in the edma folder called CourseRegistration.edma. This file will contain our definition of the course registration data model. Write the following into the file:</div>


<div class='float-listings'><pre class ='listings'>DataModel CourseRegistration
{
}</pre></div>


<div class="standard" id='magicparlabel-1928'>Now run Make and refresh the project. In the package explorer navigate to the package <em>generated</em>. Inside this package you will find a package called <em>courseregistration</em>. Inside this package you should find the following files: </div>

<ul class="itemize" id='magicparlabel-1929'><li class="itemize_item"><em>CourseRegistration</em>.java - This is the external API to instances of the data model. Right now this interface is empty because we have no actions or views in our data model definition yet. Later on when we add actions and views to the data model, they will show up in this interface.</li>
<li class="itemize_item"><em>CourseRegistrationInstance</em>.java - This is the interface to a specific instance of the data model. This interface has methods to start and stop the instance and to get the external API from the instance.</li>
<li class="itemize_item"><em>CourseRegistrationFactory</em>.java - This is the factory class where we can get access to the instances of our data model. Each instance of a data model is identified by a name. The factory provides methods to create new instances, to test whether an instance with a given name exists and to get access to an existing instance.</li>
<li class="itemize_item"><em>CourseRegistrationViewer</em>.java - This is the internal interface that views on the data model has access to. It will get all the methods and functionality that we need to extract information from the data model instance. Right now the data model definition is empty, so this interface is also empty.</li>
<li class="itemize_item"><em>CourseRegistrationUpdater</em>.java - This is the internal interface that actions on the data model has access to. It extends the <em>CourseRegistrationViewer</em> interface, so actions can also extract information from the data model, but then it adds methods and functionality to update the state of the data model instance. Right now this interface is empty because the data model definition is empty.</li>
</ul>
<div class="standard" id='magicparlabel-1934'>Inside the <em>courseregistration </em>package you should also find two sub packages called <em>remote</em> and <em>test</em>. The <em>remote</em> package contains classes that makes it possible to set up a server that handles access to a data model instance, and a proxy class that clients then can use to access the data model instance on the server. The <em>test</em> package contains a class that takes an API interface to a data model instance and then creates an interactive console where <em>actions</em> and <em>views</em> on the data model can be called.</div>

<div class="standard" id='magicparlabel-1935'>Before we can try out all these things, we need to have something in our data model definition. To start out with we will create a very simple data model with a Person Kind, an action that can create new persons and a view that can get a list of all the persons.</div>
<h3 class="subsection" id='magicparlabel-1936'><span class="subsection_label">A.4</span> Kinds</h3>
<div class="standard" id='magicparlabel-1937'>First we define the Person Kind. Update your CourseRegistration.edma file to look like this:</div>


<div class='float-listings'><pre class ='listings'>DataModel CourseRegistration
{
	Kind Person
	{
		name : Name,
		email : Email,
		mobile : Mobile
	}
}</pre></div>


<div class="standard" id='magicparlabel-1951'>Again run Make and refresh the project. Now take a look inside the ...<em>generated.courseregistration</em> sub package again. You should now see two new sub packages that have been created: <em>kinds</em> and <em>valuedomains</em>. If you take a look into the <em>valuedomains</em> sub package you should find the files: <em>PersonID</em>.java, <em>Person</em>.java and <em>PersonList</em>.java. These are value domains that have been automatically created from the Person Kind. The <em>PersonID</em> value domain contains a long value that are used to identify a person entity inside the data model instance. All Kinds have an implicit id value beside the values that are defined explicitly. The <em>Person</em> value domain is a struct value domain that contains this id value plus all the values that are defined explicitly in the Person Kind. The <em>PersonList</em> value domain is a <em>list</em> value domain where the elements are values from the <em>Person</em> value domain. All these auto generated value domains are local to the data model which means that you can not use them in global value domains or value domains that are local to other data models. You can also make your own local value domains by defining them inside the data model's { and }. If you want the <em>PersonID</em>, <em>Person</em> and <em>PersonList</em> to be global value domains, so you can use them in other global value domains or in other data models you can write Publish after the kind name like this:</div>


<div class='float-listings'><pre class ='listings'>DataModel CourseRegistration
{
	Kind Person Publish
	{
		name : Name,
		email : Email,
		mobile : Mobile
	}
}</pre></div>


<div class="standard" id='magicparlabel-1965'>You can also make them global with another name to avoid name clashes with other global value domains. This is done with the As keyword like this:</div>
<div class='float-listings'><pre class ='listings'>DataModel CourseRegistration
{
	Kind Person Publish As MyPerson
	{
		name : Name,
		email : Email,
		mobile : Mobile
	}
}</pre></div>


<div class="standard" id='magicparlabel-1978'>Now the generated value domains will be global with the names: <em>MyPersonID</em>, <em>MyPerson</em> and <em>MyPersonList</em>.</div>

<div class="standard" id='magicparlabel-1979'>Before we go on you will need to know a few things about what a data model instance is. A data model instance should be viewed as a sealed container that contains some data that might change over time. It is not possible to see or update the data from outside the container. But the container provides <em>actions</em> and <em>views</em> that can go inside the container and look at the data and the <em>actions</em> can also make changes to the data. But they can not take any references to the data outside the container. So the only way a <em>view</em> or an <em>action</em> can get information out of the container is by taking snapshots of the data and then bring these snapshots to the outside. A snapshot can be thought of as an immutable picture of how the data looked when it was taken. In EDMA we use values from value domains to capture these snapshots, since these values are immutable. So the generated PersonID, Person and PersonList value domains can be used to bring information from inside the data model instance to the outside.</div>

<div class="standard" id='magicparlabel-1980'>The <em>attributes</em> in a kind can also be made optional with a question mark, just like the fields in a <em>Struct</em> value domain.</div>

<div class="standard" id='magicparlabel-1981'>Now lets look into the <em>kinds</em> sub package, there should be a sub package called <em>person</em>. Inside the <em>person</em> sub package you will find the internal interfaces that can be used by the <em>views</em> and the <em>actions</em> when they operate inside the data model instance. The sub package should contain these files:</div>

<ul class="itemize" id='magicparlabel-1982'><li class="itemize_item">PersonViewer.java - This is the view interface to a person entity inside the data model instance. This interface contains methods to get snapshots of all the attributes in the entity. If you look into this interface you will find the methods: getID(). getName(), getEmail() and getMobile(). The values returned by these methods are snapshots of the entity attributes. There is also a method named snapshot() that will take a snapshot of the entire entity as a value from the Person value domain described earlier.</li>
<li class="itemize_item">PersonUpdater.java - This is the update interface to a person entity inside the data model instance. Right now this interface is empty because we have not allowed any of the attributes in the Person Kind to be updated. Lets try to make the <em>mobile</em> attribute updateable. This is done by adding a + after the name of the attribute like this:Now run Make again and refresh. The PersonUpdater interface should now contains a method called beginUpdate() that returns another interface where the updateable attributes can be set and a save() method to end the updates to the attributes. Right now it might seem a little overkill that you need to call beginUpdate().setMobile(...).save() to update the mobile phone number. But later on when we introduce the Unique index it will be more clear why it is done in this way.<div class='float-listings'><pre class ='listings'>DataModel CourseRegistration
{
	Kind Person
	{
		name : Name,
		email : Email,
		mobile+ : Mobile
	}
}</pre></div>
</li>
<li class="itemize_item">PersonSet.java - This interface represents a set of person entities (each of them represented by the PersonViewer interface). You can iterate over the set, you can order the set by any of the attributes and you can suborder by any attribute. You can also perform set operations like union, intersection and subtraction. Sets are immutable, so every time you change something, you actually get a new set. The set also has a snapshot() methods that returns it as a value from the PersonList value domain. The interface is made so the runtime system can choose to delay all set operations like union, intersection, subtraction, ordering etc until the set is actual iterated over or accessed in other ways. This makes it possible for the runtime system to optimize the set operations.</li>
<li class="itemize_item">PersonFilter.java - This is a filter interface that can be used to implement user defined filters to perform specialized searches in sets. The interface has a single method called <em>accept</em> that takes a PersonViewer interface as parameter and returns a boolean.</li>
<li class="itemize_item">PersonKind.java - This is the interface to the collection of all person entities in the data model instance. It has methods to get a specific entity by its ID and to get all the entities as a set. </li>
</ul>
<h3 class="subsection" id='magicparlabel-1999'><span class="subsection_label">A.5</span> Views and Actions</h3>
<div class="standard" id='magicparlabel-2000'>The entities in the data model instance can only be accessed through <em>views</em> or <em>actions.</em> <em>Views</em> can only extract data from a data model instance while <em>actions</em> can both extract data and make changes to the data inside a data model instance. We will start by making an action that can create a new person kind.</div>

<div class="standard" id='magicparlabel-2001'>Create a new file in the <em>edma</em> folder named CourseRegistrationAPI.edma that contains this:</div>
<div class='float-listings'><pre class ='listings'>DataModel CourseRegistration
{
	Action createPerson
	{
		Description:
			"Creates a new person"
		Input: 
			name : Name,
			email : Email,
			mobile : Mobile
		Output:
			id : PersonID
	}
}</pre></div>


<div class="standard" id='magicparlabel-2019'>This defines an action that can create a new person. It has a description, some input parameters and an output parameter.</div>

<div class="standard" id='magicparlabel-2020'>Now run Make and refresh the project. </div>

<div class="standard" id='magicparlabel-2021'>First we have to implement the action to do what we want, namely create a new Person entity. Locate the file: tutorial.divingschool.usercode.models. courseregistration.actions.CreatePersonUserImpl.java. It will intentionally have a compile error, so it should be easy to locate it.</div>


<div class='float-listings'><pre class ='listings Java'>.
.
.
    /**
     * Execution of the action
     * @param upd  Update interface
     * @return     Return 0 to commit or one of the error codes to roll back
     */
    public int execute(CourseRegistrationUpdater upd)
    {
        // Implementation of createPerson
        // Return one of the following error codes:
        // OK
        
        // If an error needs extra explanation, use: setErrorDescription("Extra info");
        
        // WARNING : Any code outside the following begin and end tags
        // will be lost when re-generation occurs.
        
        // EDMA_non-generated_code_begin
        
        "TODO : put your implementation of createPerson here...";
        
        // EDMA_non-generated_code_end
    }
.
.
.
</pre></div>


<div class="standard" id='magicparlabel-2055'>The implementation should go between the <em>EDMA_non-generated_code_begin</em> and <em>EDMA_non-generated_code_end</em> tags in the <em>execute</em> method. The execute methods has a single parameter which is an interface to the data model instance. Since this is an action, the interface is an update-interface that can change the state of the data model. The execute method returns an int, which is a status code. Since we have not yet defined any error conditions, we should simply return OK (which is always defined as 0). Replace the implementation of the execute method with this:</div>


<div class='float-listings'><pre class ='listings Java'>// EDMA_non-generated_code_begin
PersonUpdater person = upd.newPerson()
							.name(in_name)
							.email(in_email)
							.mobile(in_mobile);
out_id = person.getID();
return OK;
// EDMA_non-generated_code_end</pre></div>


<div class="standard" id='magicparlabel-2068'>As you can see the class has defined all the input parameters prepended with &ldquo;in_&rdquo;. These parameters are automatically initialized by the EDMA system before the execute method is called. The output parameters are also defined prepended with &ldquo;out_&rdquo;. The values of the output parameters must be set in the execute method by you (unless you return a non-zero error-code, then you can ignore the output parameters, but more on that later).</div>

<div class="standard" id='magicparlabel-2069'>Before we test the create person action, lets make a view that returns all persons, so we can see if they actually gets created. In CourseRegistrationAPI.edma add this view to the data model CourseRegistration:</div>


<div class='float-listings'><pre class ='listings'>	View getAllPersons
	{
		Description:
			"Returns a list of all persons"
		Output:
			personList : PersonList
	}</pre></div>


<div class="standard" id='magicparlabel-2081'>This view takes no input and returns a list of all persons. Run Make and refresh, then locate the file: tutorial.divingschool.usercode.models.courseregistration.views.GetAllPersonsUserImpl.java and put the following implementation into the <em>execute</em> method:</div>


<div class='float-listings'><pre class ='listings Java'>// EDMA_non-generated_code_begin
out_personList = view.getPersonKind().getAll().snapshot();
return OK;
// EDMA_non-generated_code_end</pre></div>


<div class="standard" id='magicparlabel-2090'>Notice that the parameter to the execute method is a <em>view</em> interface because this is a view and not an action, so it is not allowed to change the state of the data model instance.</div>
<h3 class="subsection" id='magicparlabel-2091'><span class="subsection_label">A.6</span> Try it out</h3>
<div class="standard" id='magicparlabel-2092'>We will now go through all the steps needed to create an instance of the CourseRegistration data model and manipulate it through the actions and views we have created. To do this create a class called TryIt in the default package with a main method.</div>

<div class="standard" id='magicparlabel-2093'>The first thing we do is to create a runtime factory. The runtime factory provides the runtime execution logic to each data model instance. There can be many different implementations of the runtime factory with different strategies for execution and persistence. The example runtime factory provided with this version of EDMA features a thread-safe pipelined execution and single file persistence. The argument to the constructor is the directory where the instances should be persisted. The runtime factory is generic code that is not generated from any specific data model.</div>


<div class='float-listings'><pre class ='listings Java'>RuntimeFactory rtfactory = new RuntimeFactory("C:/tmp");</pre></div>


<div class="standard" id='magicparlabel-2099'>Now that we have a runtime factory, we need to create our environment and connect it to the runtime factory:</div>


<div class='float-listings'><pre class ='listings Java'>DivingSchool ds = new DivingSchool(rtfactory);</pre></div>


<div class="standard" id='magicparlabel-2105'>The environment is an auto-generated class that provides access to instance factories for each data model defined in the environment. At the moment we only have one data model in our environment, the CourseRegistration data model. A data model can have several independent instances, so each data model has an instance factory that can create and delete instances of that particular data model.</div>

<div class="standard" id='magicparlabel-2106'>Now lets get the instance factory for our CourseRegistration data model:</div>


<div class='float-listings'><pre class ='listings Java'>CourseRegistrationFactory crf = ds.getCourseRegistrationFactory();</pre></div>


<div class="standard" id='magicparlabel-2112'>The instance factory controls the instances of the data model. Each instance is identified by a name, for now we just need one instance that we will call &ldquo;MyInstance&rdquo;. If the instance already exists, we will reuse it, if it does not exist, we will create it:</div>


<div class='float-listings'><pre class ='listings Java'>CourseRegistrationInstance instance = null;
String instanceName = "MyInstance";
if(crf.exists(instanceName))
{
	instance = crf.getInstance(instanceName);
}
else
{
	instance = crf.newInstance(instanceName);
}</pre></div>


<div class="standard" id='magicparlabel-2127'>NOTE: An instance of a data model contains data that follow the structure of that particular data model. This means that if you change the data model, then the instances are no longer usable. This means that every time you make changes to the structure of your data model you should also delete any instances you have stored. You may create, delete and modify the actions and views on the data model and still reuse the instances, just be careful not to change any value domains that are used in the kinds.</div>

<div class="standard" id='magicparlabel-2128'>From the instance we can get the API that lets us execute actions and views on the instance. With the example runtime factory that we are using, instances are thread-safe, so the API can be operated from several threads simultaneously. Now lets get the API from our instance:</div>


<div class='float-listings'><pre class ='listings Java'>CourseRegistration cr = instance.getAPI();</pre></div>


<div class="standard" id='magicparlabel-2134'>Before we can call any action or views on the instance, it needs to be started. Instances can be started and stopped. When an instance is started, its internal worker-threads are created and ready to execute actions and views. When we are finished using an instance it should be stopped.</div>

<div class="standard" id='magicparlabel-2135'>Now lets fire up the instance:</div>


<div class='float-listings'><pre class ='listings Java'>instance.start();</pre></div>


<div class="standard" id='magicparlabel-2141'>That's it! Now we can start executing actions and views on our data model instance. Lets try out the action &ldquo;CreatePerson&rdquo;:</div>


<div class='float-listings'><pre class ='listings Java'>cr.createPerson(Name.create("John Doe"),
				Email.create("johndoe@foo.bar"),
				Mobile.create("12345678"));</pre></div>


<div class="standard" id='magicparlabel-2149'>In order to check that we actually did create a new entity, lets try the view &ldquo;GetAllPersons&rdquo;:</div>


<div class='float-listings'><pre class ='listings Java'>PersonList list = cr.getAllPersons().getPersonList();
System.out.println(list);</pre></div>


<div class="standard" id='magicparlabel-2156'>Since actions and views can have multiple return values and also returns a status, each action or view has its own result interface on which the status and the return values can be accessed. So the getAllPersons() methods returns a result on which we then can access the return value &ldquo;PersonList&rdquo; by calling getPersonList().</div>

<div class="standard" id='magicparlabel-2157'>All value classes has a default toString() method so we can just print out the entire list with System.out.println(list).</div>

<div class="standard" id='magicparlabel-2158'>Now we just need to stop the instance to terminate the program:</div>


<div class='float-listings'><pre class ='listings Java'>instance.stop();</pre></div>


<div class="standard" id='magicparlabel-2164'>First time this is run it will create a new data model instance with the name &ldquo;MyInstance&rdquo; and add a person to that instance. If it is run again it will just load the existing instance and add another person to that. Try it out...</div>

<div class="standard" id='magicparlabel-2165'>If you look in the directory you gave to the runtime factory (in this example it was &ldquo;C:/tmp&rdquo;), you should see a file called &ldquo;myinstance.data&rdquo;<em>.</em> This file contains the persisted data for the instance.</div>

<div class="standard" id='magicparlabel-2166'>Another way to test the data model is to use the auto-generated terminal test program. The terminal test program takes an interface to the API and an interface to a terminal (a terminal here just means a simple text-in, text-out user interface). It lets the user call the actions and views from the terminal. To use the auto-generated terminal test program, replace the lines between <em>instance.start()</em> and <em>instance.stop()</em> with this line:</div>


<div class='float-listings'><pre class ='listings Java'>new CourseRegistrationTest(cr, new SimpleTerminal()).start();</pre></div>


<div class="standard" id='magicparlabel-2172'>Then run the program. Now you can create new persons and see the list off all persons through the terminal test program.</div>

<div class="standard" id='magicparlabel-2173'>From now on, when you create new actions or views and run Make, the terminal test program will be regenerated to support the new methods.</div>
<h3 class="subsection" id='magicparlabel-2174'><span class="subsection_label">A.7</span> Indexes</h3>
<div class="standard" id='magicparlabel-2175'>Before we continue, you should delete the instance persistence file &ldquo;myinstance.data&rdquo;. This is important because we are going to make changes to the data model.</div>

<div class="standard" id='magicparlabel-2176'>We will now add some indexes to our data model. There are 3 types of indexes in EDMA: unique index, equal index and compare index. The unique index is used to force certain fields or combinations of fields to be unique within a kind. For example we could make the email and mobile fields unique in the person kind. To do this change the definition of the person kind to look like this:</div>


<div class='float-listings'><pre class ='listings'>Kind Person
{
	name : Name,
	email : Email,
	mobile : Mobile,
	Unique(email),
	Unique(mobile)
}</pre></div>


<div class="standard" id='magicparlabel-2189'>This means that now 2 different persons can not have the same email or the same mobile number. If you run make and refresh the project, you will see some changes in the generated files:</div>

<ol class="enumerate" id='magicparlabel-2190'><li class="enumerate_item">In CourseRegistrationUpdater.java, the newPerson(...) method now declares to throw an UniqueException. EDMA will throw this exception if you try to create a person with an email or mobile number that already exists.</li>
<li class="enumerate_item">The PersonKind interface has got two new methods: getFromEmail(...) and getFromMobile(...).</li>
</ol>
<div class="standard" id='magicparlabel-2192'>Since it is generally considered too be bug if actions or views throws exceptions, EDMA provides a better way of handling this. In the definition of the &ldquo;CreatePerson&rdquo; action we can declare that the action may fail on certain input. We do this by defining two error code:</div>


<div class='float-listings'><pre class ='listings'>Action createPerson
{
	Description:
		"Creates a new person"
	Input: 
		name : Name,
		email : Email,
		mobile : Mobile
	Output:
		id : PersonID
	ErrorCodes:
		1 - "Email already exists",
		2 - "Mobile already exists"
}</pre></div>


<div class="standard" id='magicparlabel-2211'>Now run make and refresh the project again. The CreatePersonUserImpl class now has two extra &ldquo;static final int&rdquo; that represents the added error codes. You can now alter the implementation of the action &ldquo;CreatePerson&rdquo; to look like this:</div>


<div class='float-listings'><pre class ='listings Java'>EDMA_non-generated_code_begin
//Check that email is unique
if(upd.getPersonKind().getFromEmail(in_email) != null)
{
	return EMAIL_ALREADY_EXISTS;
}
//Check that mobile is unique
if(upd.getPersonKind().getFromMobile(in_mobile) != null)
{
	return MOBILE_ALREADY_EXISTS;
}

PersonUpdater person = upd.newPerson()
							.name(in_name)
							.email(in_email)
							.mobile(in_mobile);
out_id = person.getID();
return OK;
// EDMA_non-generated_code_end</pre></div>


<div class="standard" id='magicparlabel-2235'>Now the action first checks that the email and mobile number are indeed unique, before it tries to create the new person. The isolation property of the ACID guarantees will make sure that no other actions can race in and create a person in between we checked the uniqueness and we created the new person.</div>

<div class="standard" id='magicparlabel-2236'>Only the Unique index alters what data we can put into the data model instance. The equal and compare indexes only helps making it easier and faster to access certain sets of entities. If you want to make it easy and fast to get the set of all entities in a kind where one or more attributes are equal to certain values, then you should use the equal index. If you also want to make it easy and fast to get entities where certain attributes are less than, greater than or in between certain values, you should use a compare index.</div>

<div class="standard" id='magicparlabel-2237'>Equal and compare indexes are defined with the &ldquo;Equal&rdquo; and &ldquo;Compare&rdquo; keyword just like unique indexes are defined with the &ldquo;Unique&rdquo; keyword. You should try them out and take a look at the methods they add to the kind interface.</div>

<div class="standard" id='magicparlabel-2238'>Indexes can be defined on a single attribute or on multiple attributes separated by commas.</div>
<h3 class="subsection" id='magicparlabel-2239'><span class="subsection_label">A.8</span> Relationships</h3>
<div class="standard" id='magicparlabel-2240'>You can also define relationships between kinds. There are 3 main types of relationships: &ldquo;one to one&rdquo;, &ldquo;many to one&rdquo; and &ldquo;many to many&rdquo; (&ldquo;one-to-many&rdquo; is just a &ldquo;many-to-one&rdquo; where the kinds are reversed). Relationships are defined using the Relation keyword in the EDMA definition language. A relationship keeps track of individual connections between entities from the two kinds that participate in the relationship. An example could be a relationship between a student and a course. We could call this relationship StudentEnrollment and every connection in the relationship would represent that a specific student entity is enrolled on a specific course entity.</div>

<div class="standard" id='magicparlabel-2241'>The relationship definition would look like this:</div>


<div class='float-listings'><pre class ='listings'>Relation StudentEnrollment Course &gt;-&lt; Student</pre></div>


<div class="standard" id='magicparlabel-2247'>And it would lead to the creation of the method:</div>


<div class='float-listings'><pre class ='listings Java'>public CourseSet getCourseSet();</pre></div>


<div class="standard" id='magicparlabel-2253'>in the StudentViewer interface. The methods returns the set of courses that the student are currently enrolled on. In the CourseViewer interface we would get this method:</div>


<div class='float-listings'><pre class ='listings Java'>public StudentSet getStudentSet();</pre></div>


<div class="standard" id='magicparlabel-2259'>that would return the set of students that are currently enrolled on the course. In the CourseUpdate interface we would get these methods:</div>


<div class='float-listings'><pre class ='listings Java'>public boolean addStudent(StudentViewer student);
public boolean removeStudent(StudentViewer student);</pre></div>


<div class="standard" id='magicparlabel-2266'>The StudentUpdate interface does not get methods to add or remove courses. The add/remove methods are always added to the kind that appears first in the definition.</div>

<div class="standard" id='magicparlabel-2267'>If each course could have one teacher that would be a many to one relation and the definition could look like this:</div>


<div class='float-listings'><pre class ='listings'>Relation StudentEnrollment Course &gt;-- Teacher</pre></div>


<div class="standard" id='magicparlabel-2273'>Try for yourself to create a &ldquo;many-to-one&rdquo; and see what methods that are created on the interfaces of the involved kinds.</div>

<div class="standard" id='magicparlabel-2274'>But what if we did not have a student kind and a teacher kind, but just a person kind?</div>

<div class="standard" id='magicparlabel-2275'>In this case we would need to distinguish the role of the person in the two relationships:</div>


<div class='float-listings'><pre class ='listings'>Relation StudentEnrollment Course &gt;-&lt; Person : student
Relation StudentEnrollment Course &gt;-- Person : teacher</pre></div>


<div class="standard" id='magicparlabel-2282'>The name after the colon is the role name. Try it out and see how it alters the names of the created methods on the involved kinds. If no role name is provided, the role is asserted to be the same as the name of the kind. So with the example of <span style='font-family:monospace;'>Course &gt;-&lt; Person</span>, if no role name is provided for the Person, it just has the role of a person, which is very general.</div>

<div class="standard" id='magicparlabel-2283'>A &ldquo;one-to-one&rdquo; relationship is defined by <span style='font-family:monospace;'>&ldquo;---&rdquo;</span> as you might have guessed. Try it out and see which methods you will get.</div>

<div class="standard" id='magicparlabel-2284'>Note that all the generated interfaces have meaningful javadoc (or at least they should have, lets us know if some is missing). So you can always experiment with different data model definitions and see what gets generated and what it does. Hopefully it will make good sense in the context of the data model.</div>
<h3 class="subsection" id='magicparlabel-2285'><span class="subsection_label">A.9</span> Remote Access</h3>
<div class="standard" id='magicparlabel-2286'>The generator also generates java code that let you use the data model instance from a different machine through a socket connection. The code consists of:</div>

<ul class="itemize" id='magicparlabel-2287'><li class="itemize_item">A simple server that uses a thread pool to handle incoming requests and relate them to the data model interface</li>
<li class="itemize_item">A proxy that implements the data model interface and relates all method calls to the server</li>
</ul>
<div class="standard" id='magicparlabel-2289'>The follow code shows how you create a server from a data model instance interface:</div>


<div class='float-listings'><pre class ='listings Java'>//Make sure the instance is running...
CourseRegistration intf = instance.getAPI();
int port = 1234;
Server server = new Server(port, new CourseRegistrationServerInstance(intf));
server.start();</pre></div>


<div class="standard" id='magicparlabel-2299'>And this shows how you would access the interface on the client side:</div>


<div class='float-listings'><pre class ='listings Java'>CourseRegistration intf = new CourseRegClientInstance("localhost", 1234);</pre></div>


<div class="standard" id='magicparlabel-2305'>(Replace &ldquo;localhost&rdquo; with the IP of the server). You can now use the interface on the client side, just as if the data model instance was running locally. </div>


<h2 class="section" id='magicparlabel-2308'><span class="section_label">B</span> <a id="sec_EDMALanguageGrammar" />
EDMA Language Grammar</h2>
<div class="standard" id='magicparlabel-2309'>Here, we present the grammar for the EDMA language. The grammar is written in JavaCC, and the grammar listed shows an EBNF representation of the syntax.</div>


<div class='float-listings'><pre class ='listings'>SKIP :
{
  " "
| "\t"
| "\r"
| "\n"
| &lt;"//" (~[ "\n", "\r" ])*
    (
      "\n"
    | "\r"
    | "\r\n"
    )&gt;
| &lt;"/*"&gt;: INSIDE_COMMENT 
}

&lt;INSIDE_COMMENT&gt;SKIP :
{
  &lt;"*/"&gt;: DEFAULT
| &lt;~[]&gt;
}

TOKEN :
{
  &lt;DECIMAL : &lt;NUMBER&gt; "." &lt;DIGITS&gt;&gt;
| &lt;NUMBER : ("-")?&lt;DIGITS&gt;&gt;
| &lt;DIGITS : ([ "0"-"9" ])+&gt;
| &lt;MIN : "MIN"&gt;
| &lt;MAX : "MAX"&gt;
| &lt;KEYWORD_NULL : "null"&gt;
| &lt;KEYWORD_VALUEDOMAIN : "ValueDomain"&gt;
| &lt;KEYWORD_DATAMODEL : "DataModel"&gt;
| &lt;KEYWORD_KIND : "Kind"&gt;
| &lt;KEYWORD_EXTENDS : ("e"|"E")"xtends"&gt; // OPTION: Extends or extends?
| &lt;KEYWORD_RELATION : "Relation"&gt;
| &lt;KEYWORD_SINGLETON : "Singleton"&gt;
| &lt;KEYWORD_UNIQUE : "Unique"&gt;
| &lt;KEYWORD_COMPARE : "Compare"&gt;
| &lt;KEYWORD_EQUALS : "Equals"&gt;
| &lt;KEYWORD_VOID  : "void"&gt;
| &lt;KEYWORD_ACTION : "Action"&gt;
| &lt;KEYWORD_INTERFACE : "Interface"&gt;
| &lt;KEYWORD_VIEW : "View"&gt;
| &lt;KEYWORD_DEFAULT : "Default"&gt;
| &lt;KEYWORD_TRUE : "true"&gt;
| &lt;KEYWORD_FALSE : "false"&gt;
| &lt;KEYWORD_LISTOF : "List"&gt;
| &lt;KEYWORD_ENUM : "Enum"&gt;
| &lt;KEYWORD_MAP : "Map"&gt;
| &lt;KEYWORD_ONEOF : "OneOf"&gt;
| &lt;KEYWORD_STRUCT : "Struct"&gt;
| &lt;KEYWORD_CONSTRAINTS : "Constraints"&gt;
| &lt;KEYWORD_PUBLISH : "Publish"&gt;
| &lt;KEYWORD_AS : "As"&gt;
| &lt;KEYWORD_PUBLISHAS : "PublishAs"&gt;
| &lt;KEYWORD_ON  : "On"&gt;
| &lt;KEYWORD_INPUT : "Input"&gt;
| &lt;KEYWORD_OUTPUT : "Output"&gt;
| &lt;KEYWORD_ERRORCODES : "ErrorCodes"&gt;
| &lt;KEYWORD_DESCRIPTION : "Description"&gt;
| &lt;BOOLEAN_DOMAIN : "Boolean"&gt;
| &lt;STRING_DOMAIN : "String"&gt;
| &lt;FLOAT_DOMAIN : "Float"&gt;
| &lt;DOUBLE_DOMAIN : "Double"&gt;
| &lt;INTEGER_DOMAIN : "Integer"&gt;
| &lt;LONG_DOMAIN : "Long"&gt;

| &lt;REGEX_RANGE : "[\"" ~[ "\"", "\n", "\r" ] "\"]"&gt;
| &lt;CAMELCASE_WORD : [ "a"-"z" ] ([ "a"-"z", "A"-"Z", "0"-"9" ])*&gt;
| &lt;IDENTIFIER : [ "A"-"Z" ] ([ "a"-"z", "A"-"Z","0"-"9" ])*&gt;

| &lt;ARROW : "-&gt;"&gt;
| &lt;L_PAR : "("&gt;
| &lt;R_PAR : ")"&gt;
| &lt;L_BR : "{"&gt;
| &lt;R_BR : "}"&gt;
| &lt;L_SQBR : "["&gt;
| &lt;R_SQBR : "]"&gt;
| &lt;COLON : ":"&gt;
| &lt;COMMA : ","&gt;
| &lt;RELATION_SYMBOL :
    "---"
  | "&gt;--"
  | "&gt;-&lt;"&gt;
| &lt;QUESTION_MARK : "?"&gt;
| &lt;PLUS : "+"&gt;
| &lt;MINUS : "-"&gt;
| &lt;LT : "&lt;"&gt;
| &lt;GT : "&gt;"&gt;
}

TOKEN :
{
  &lt;Q_STRING : "\""  (&lt;ALLOWABLE_CHARACTERS&gt;)* "\""&gt;
| &lt;ALLOWABLE_CHARACTERS: ( (~["\\","\""]) | ("\\" ( ["u"] ["0"-"9", "a"-"f", "A"-"F"]
														   ["0"-"9", "a"-"f", "A"-"F"]
														   ["0"-"9", "a"-"f", "A"-"F"]
														   ["0"-"9", "a"-"f", "A"-"F"]
      											     | ["\"", "\\", "b", "f", "n", "r", "t"]
      											   )
      										  )
      					  )&gt; 
}

/** Productions */
Input = { ValueDomain }, { DataModel }, &lt;EOF&gt;;

ValueDomain = &lt;KEYWORD_VALUEDOMAIN&gt;, &lt;IDENTIFIER&gt;, &lt;COLON&gt;,
  ( ValueDomainEnum | ValueDomainList | ValueDomainMap | ValueDomainStruct
    | ValueDomainSingle | ValueDomainOneOf ), 
  [ ConstraintNodeList ];

ConstraintNodeList = &lt;KEYWORD_CONSTRAINTS&gt;, &lt;L_SQBR&gt;, ConstraintNode,
  { &lt;COMMA&gt;, ConstraintNode }, &lt;R_SQBR&gt;;

ConstraintNode = &lt;CAMELCASE_WORD&gt;, [ &lt;Q_STRING&gt; ];

ValueDomainEnum = &lt;KEYWORD_ENUM&gt;, &lt;L_SQBR&gt;, &lt;IDENTIFIER&gt;,
  { &lt;COMMA&gt;, &lt;IDENTIFIER&gt; }, &lt;R_SQBR&gt;;

ValueDomainList = &lt;KEYWORD_LISTOF&gt;, &lt;LT&gt;, &lt;IDENTIFIER&gt;, &lt;GT&gt;, [ Range ];

Range = &lt;L_SQBR&gt;, ( &lt;MIN&gt;, | ( &lt;DECIMAL&gt; | &lt;NUMBER&gt; ) ),
  ( &lt;R_SQBR&gt; | "..", ( &lt;DECIMAL&gt; | &lt;NUMBER&gt; | &lt;MAX&gt; ),
    &lt;R_SQBR&gt;
  );

ValueDomainMap = &lt;KEYWORD_MAP&gt;, &lt;LT&gt;, &lt;IDENTIFIER&gt;, &lt;COMMA&gt;,
  &lt;IDENTIFIER&gt;, &lt;GT&gt;;

ValueDomainStruct = 
  &lt;KEYWORD_STRUCT&gt;, &lt;L_BR&gt;
  [ &lt;CAMELCASE_WORD&gt;, [ &lt;QUESTION_MARK&gt; ], &lt;COLON&gt;, &lt;IDENTIFIER&gt;,
    { &lt;COMMA&gt;, &lt;CAMELCASE_WORD&gt;, [ &lt;QUESTION_MARK&gt; ], &lt;COLON&gt;, &lt;IDENTIFIER&gt; }
  ], &lt;R_BR&gt;;

ValueDomainSingle = 
    &lt;BOOLEAN_DOMAIN&gt; 
  | &lt;STRING_DOMAIN&gt;, Range [ RegexRange ] 
  | ( &lt;FLOAT_DOMAIN&gt; | &lt;DOUBLE_DOMAIN&gt; | &lt;INTEGER_DOMAIN&gt; | &lt;LONG_DOMAIN&gt; ), Range;

RegexRange = &lt;L_SQBR&gt;, &lt;Q_STRING&gt;, &lt;R_SQBR&gt;;

ValueDomainOneOf = &lt;KEYWORD_ONEOF&gt;, &lt;LT&gt;, &lt;IDENTIFIER&gt;, { &lt;COMMA&gt;, &lt;IDENTIFIER&gt; }, &lt;GT&gt;;

DataModel = &lt;KEYWORD_DATAMODEL&gt;, &lt;IDENTIFIER&gt;, &lt;L_BR&gt;,
  { Kind | Relation | Singleton | ActionView | Interface | ValueDomain },
  [ ConstraintNodeList ], &lt;R_BR&gt;;

Index =
  ( &lt;KEYWORD_UNIQUE&gt; | &lt;KEYWORD_EQUALS&gt; | &lt;KEYWORD_COMPARE&gt; ),
  &lt;L_PAR&gt;, &lt;CAMELCASE_WORD&gt;, { [ &lt;COMMA&gt; ], &lt;CAMELCASE_WORD&gt; }, &lt;R_PAR&gt;;

RelationIndex = ( &lt;KEYWORD_UNIQUE&gt; | &lt;KEYWORD_EQUALS&gt; | &lt;KEYWORD_COMPARE&gt; ),
  &lt;KEYWORD_ON&gt;, &lt;IDENTIFIER&gt;, [ &lt;COLON&gt;, &lt;CAMELCASE_WORD&gt; ],
  &lt;L_PAR&gt;, &lt;CAMELCASE_WORD&gt;, { [&lt;COMMA&gt;], &lt;CAMELCASE_WORD&gt; }, &lt;R_PAR&gt;;

Kind = &lt; KEYWORD_KIND &gt;, &lt; IDENTIFIER &gt;, [ &lt; KEYWORD_EXTENDS &gt;, &lt; IDENTIFIER &gt; ],
  [ &lt;KEYWORD_PUBLISH &gt;, [ &lt;KEYWORD_AS &gt; t=&lt; IDENTIFIER &gt; ] ],
  &lt; L_BR &gt;,
  [ (  Attribute | Index |  ConstraintNodeList ),
  	{ &lt; COMMA &gt;, ( Attribute | Index | ConstraintNodeList ) }
  ], &lt; R_BR &gt;;

Attribute = ( &lt;CAMELCASE_WORD&gt;,
  [ &lt;QUESTION_MARK&gt;, [ &lt;PLUS&gt; ] | &lt;PLUS&gt; [ &lt;QUESTION_MARK&gt; ] ] ), &lt;COLON&gt;,
  &lt;IDENTIFIER&gt;, [ &lt;KEYWORD_DEFAULT&gt;, &lt;L_SQBR&gt;, BasicValue, &lt;R_SQBR&gt; ];

BasicValue = &lt;Q_STRING&gt; | &lt;MIN&gt; | &lt;MAX&gt; | &lt;NUMBER&gt; | &lt;DECIMAL&gt; | &lt;KEYWORD_TRUE&gt;
  | &lt;KEYWORD_FALSE&gt; | &lt;IDENTIFIER&gt; | &lt;KEYWORD_NULL&gt; | ListOfBasicValues;


ListOfBasicValues = &lt;L_PAR&gt;, BasicValue, { &lt;COMMA&gt;, BasicValue }, &lt;R_PAR&gt;;

Relation = &lt;KEYWORD_RELATION&gt;, &lt;IDENTIFIER&gt;, &lt;IDENTIFIER&gt;,
  [ &lt;COLON&gt;, &lt;CAMELCASE_WORD&gt; ],
  RelationType, &lt;IDENTIFIER&gt;, [ &lt;COLON&gt;, &lt;CAMELCASE_WORD&gt; ],
  [ &lt;L_BR&gt;, ( RelationIndex | ConstraintNodeList ),
	{ &lt;COMMA&gt;, ( RelationIndex | ConstraintNodeList ) }, &lt;R_BR&gt; ];

RelationType = &lt;RELATION_SYMBOL&gt;;

Singleton = &lt;KEYWORD_SINGLETON&gt;, &lt;IDENTIFIER&gt;,
 [ &lt;KEYWORD_PUBLISH&gt;, [ &lt;KEYWORD_AS&gt;, &lt;IDENTIFIER&gt; ] ],
  &lt;L_BR&gt;, Attribute , { &lt;COMMA&gt;, Attribute },
  [ ConstraintNodeList ], &lt;R_BR&gt;;

ActionView = ( &lt;KEYWORD_ACTION&gt; | &lt;KEYWORD_VIEW&gt; ), &lt;CAMELCASE_WORD&gt;, &lt;L_BR&gt;,
	{ &lt;KEYWORD_INPUT&gt;, &lt;COLON&gt;, NameAndTypeList
    | &lt;KEYWORD_OUTPUT&gt;, &lt;COLON&gt;, NameAndTypeList
    | &lt;KEYWORD_ERRORCODES&gt;, &lt;COLON&gt;, ErrorCodeList
    | &lt;KEYWORD_DESCRIPTION&gt;, &lt;COLON&gt;, &lt;Q_STRING&gt; },
  &lt;R_BR&gt;;

ErrorCodeList = [ ErrorCode, { &lt;COMMA&gt;, ErrorCode } ];

ErrorCode = ( &lt;DIGITS&gt; | &lt;NUMBER&gt; ), &lt;MINUS&gt;, &lt;Q_STRING&gt;;

NameAndTypeList = NameAndType, { &lt;COMMA&gt;, NameAndType };

NameAndType = &lt;CAMELCASE_WORD&gt;, [ &lt;QUESTION_MARK&gt; ], &lt;COLON&gt;, &lt;IDENTIFIER&gt;;
</pre></div>



<h2 class="section" id='magicparlabel-2517'><span class="section_label">C</span> <a id="sec_PerformanceEvaluation" />
Performance Evaluation</h2>
<div class="standard" id='magicparlabel-2518'>There are at least three main reasons for having performance evaluations:</div>

<ul class="itemize" id='magicparlabel-2519'><li class="itemize_item">To review the system with respect to its performance goals</li>
<li class="itemize_item">To compare the performance of two or more similar systems</li>
<li class="itemize_item">To find bottlenecks</li>
</ul>
<div class="standard" id='magicparlabel-2522'>The investigations are implemented in more details, as described in this section. In order to get a good balance between testing systematically, and testing with realistic data, we have used two data models in the testing phase.</div>

<ul class="itemize" id='magicparlabel-2523'><li class="itemize_item">The <em>Diving School</em> model. This data model represents a realistic data model, i.e. a model that would realistically appear in a small business setting.
<br />



<ul class="itemize" id='magicparlabel-2524'><li class="itemize_item">Defines the kinds: Person, Student (extending Person), Teacher (extending Person), CourseType and Course.</li>
<li class="itemize_item">Defines relations for describing course dependency, student enrollment on courses, passed courses for students, assigned teachers on courses, and teaching abilities on course types.</li>
</ul>
</li><li class="itemize_item">The <em>Test Model</em>: This data model is a more systematically build data model.
<br />



<ul class="itemize" id='magicparlabel-2527'><li class="itemize_item">Defines the kinds: TestKindNoAttributes, TestKindOneAttribute, TestKindTwoAttributes, TestKindThreeAttributes, etc. Each kind has the number of attributes that its name describes – the attribute is of type PosInt (a positive integer).</li>
</ul>
</li></ul>
<div class="standard" id='magicparlabel-2528'>Having the diving school model means that we can come up with tests that are realistic, which can be easier to design than systematically and comprehensively testing a long series of possible data model compositions.</div>

<div class="standard" id='magicparlabel-2529'>However, it is also interesting to systematically measure how much data can actually be stored given a certain JVM heap size. Having the systematic <em>test model</em> means that we can create some systematical tests, knowing exactly what what is stored.</div>
<h3 class="subsection" id='magicparlabel-2530'><span class="subsection_label">C.1</span> Memory Consumption</h3>
<div class="standard" id='magicparlabel-2531'>In order to find out the memory consumption of stored entities, we instantiate a Test Data model, and fill it with entities of type TestKindOneAttribute – an entity containing only one attribute, an integer, and the mandatory entity ID – a Long. Before and after each insertion, the memory usage of the virtual machine is found, and the difference is calculated.</div>

<ul class="itemize" id='magicparlabel-2532'><li class="itemize_item">Precondition: An instance of the Test Data Model is running.</li>
<li class="itemize_item">Flow of events:
<br />



<ol class="enumerate" id='magicparlabel-2534'><li class="enumerate_item">Run garbage collection.</li>
<li class="enumerate_item">Stop the current thread for a short time (to let the garbage collection finish.)</li>
<li class="enumerate_item">Run finalization.</li>
<li class="enumerate_item">Stop the current thread for a short time.</li>
<li class="enumerate_item">Get the amount of free memory in the runtime.</li>
<li class="enumerate_item">Insert a new unique integer into the data model instance.</li>
<li class="enumerate_item">Get the amount of free memory in the runtime.</li>
<li class="enumerate_item">Calculate the amount of used memory (write it to a file) and go back to step 1.</li>
</ol>
</li></ul>
<div class="standard" id='magicparlabel-2542'>Since we cannot force the JVM to run the garbage collector, it can be difficult to determine the exact amount of memory used, and the result might not be reliable. However, by experiments we have found that running the garbage collector and the finalization, and letting the main thread sleep while they run (i.e. letting them resume after garbage collection and finalization is finished) often gives results as expected.</div>
<h4 class="subsubsection" id='magicparlabel-2543'><span class="subsubsection_label">C.1.1</span> Results</h4>
<div class="standard" id='magicparlabel-2544'>Figure  shows the memory usage of a number of insertions of entities with one attribute each.</div>


<h4 class="subsubsection" id='magicparlabel-2559'><span class="subsubsection_label">C.1.2</span> Discussion</h4>
<div class="standard" id='magicparlabel-2560'>Ideally, each insertion would take up the same amount of memory, but figure  suggests otherwise. The very first insertion is shown to cost 49128 bytes. The excessive size can be attributed to class loading, which is performed at the first initialization of a given object. After the first insertion, the memory usage for each inserted integer is 296 bytes, then dropping to 64 bytes after 100 insertions. At the 128th insertion, the memory usage for each insertion increases to 96 bytes, and it stays at this level for the rest of the insertions. It is, however, difficult to conclude what causes these memory changes, at these exact points in time.</div>

<div class="standard" id='magicparlabel-2565'>The spikes that are seen at insertion number 12, 24, 48, 96, 192 and 384 are related to the expansion of hash maps.</div>

<div class="standard" id='magicparlabel-2566'>96 bytes for storing an integer is a significant memory overhead, caused by storing the data in our Entry objects. It can be explained by the many levels of wrapping of values into objects, that occurs in EDMA. The diagram shown in figure  shows the wrapping that occurs when storing an integer value in EDMA.</div>



<div class="standard" id='magicparlabel-2581'>The diagram shows several contributions to the excessive memory use – object headers take up 8 or 16 bytes (on 32 bit and 64 bit platforms respectively), and the JVM performs 8 byte alignment , contributing to unnecessary allocation. This is further enhanced when having many instances of small objects. The storage of the bold-boxed integer in figure  adds up to a total of 96 bytes, like the graph in figure  suggests.</div>
<h3 class="subsection" id='magicparlabel-2594'><span class="subsection_label">C.2</span> Data Insertion Response Time</h3>
<div class="standard" id='magicparlabel-2595'>The response time for inserting data is measured in the following procedure.</div>

<ul class="itemize" id='magicparlabel-2596'><li class="itemize_item">Precondition: An empty data model instance must be started.</li>
<li class="itemize_item">Flow of events:
<br />



<ol class="enumerate" id='magicparlabel-2598'><li class="enumerate_item">Prepare an entity to insert.</li>
<li class="enumerate_item">Record the current time.</li>
<li class="enumerate_item">Insert the prepared entity.</li>
<li class="enumerate_item">Record the current time, and calculate the time difference.</li>
</ol>
</li></ul>
<div class="standard" id='magicparlabel-2602'>The reason for the entity value to be prepared before the time taking starts, is that we want to measure only the response time of inserting data – not including creating the data values.</div>
<h4 class="subsubsection" id='magicparlabel-2603'><span class="subsubsection_label">C.2.1</span> Results</h4>
<div class="standard" id='magicparlabel-2604'>Figure  shows the response time of inserting entities. </div>


<h4 class="subsubsection" id='magicparlabel-2619'><span class="subsubsection_label">C.2.2</span> Discussion</h4>
<div class="standard" id='magicparlabel-2620'>The response time for the very first insertion is rather high (31 ms), because it includes class loading. After classes have been loaded, the response time drops to around 0.3 ms. After about 1200 insertions, the response time finds a stable level at around 0.1 ms per insertion.</div>
<h3 class="subsection" id='magicparlabel-2621'><span class="subsection_label">C.3</span> Data Insertion Throughput</h3>
<div class="standard" id='magicparlabel-2622'>In order to measure the throughput when inserting data, the following procedure is executed.</div>

<ul class="itemize" id='magicparlabel-2623'><li class="itemize_item">Precondition: An empty data model instance must be started.</li>
<li class="itemize_item">Flow of events:
<br />



<ol class="enumerate" id='magicparlabel-2625'><li class="enumerate_item">Create a number of worker threads, with the job of inserting a certain number of entities.</li>
<li class="enumerate_item">Record the current time.</li>
<li class="enumerate_item">Start all the worker threads.</li>
<li class="enumerate_item">Join all the worker threads (wait for their finish.)</li>
<li class="enumerate_item">Record the current time, calculate the time difference and throughput.</li>
<li class="enumerate_item">Clear the data model instance – remove all entities.</li>
<li class="enumerate_item">Increase the number of worker threads, and go back to step 1.</li>
</ol>
</li></ul>
<div class="standard" id='magicparlabel-2632'>The test has been run, inserting 32768 Person entities, divided between the number of worker threads. </div>
<h4 class="subsubsection" id='magicparlabel-2633'><span class="subsubsection_label">C.3.1</span> Results</h4>
<div class="standard" id='magicparlabel-2634'>Figure  shows the insertion throughput, varied by the number of concurrent worker threads. It is seen that the single-threaded throughput measure is at the lowest, running at 12 insertions/ms. Running with two threads increases the throughput to 22 insertions/ms, and with four threads the throughput is 44. Running with up to 100 threads, the throughput varies between 46 and 57 insertions/ms.</div>

<div class="standard" id='magicparlabel-2639'>Running with more than 100 threads shows a decreasing tendency in the throughput. This might be because either the execution buffer, or the persistence buffer, is occasionally full – they are both set to a maximum size of 100, in the current implementation. Using 200 or more threads, shows a drastic decrease in the throughput, because both of the buffers are filled, causing blocking of the worker threads. Here, the throughput falls to about the same level as when using 2 threads (around 20 insertions/ms.)</div>
<h4 class="subsubsection" id='magicparlabel-2649'><span class="subsubsection_label">C.3.2</span> Discussion</h4>
<div class="standard" id='magicparlabel-2650'>It is not obvious, why the graph looks like it does. Going from one to two threads doubles the throughput as expected, but we wouldn't expect much more throughput by using more than two threads. A plausible explanation would be the overhead that is involved in changing the state of threads, by calling wait and notify. The two running units in our two step pipeline utilize two synchronized buffers, causing many calls to wait and notify. Using two threads, we keep the slowest of the two execution units (often the persistence unit) busy However, when using 3 or more threads, both the executor and the persist are kept busy most of the time, causing fewer thread state changes. This could explain why extra performance is gained using more than 2 threads.</div>
<h3 class="subsection" id='magicparlabel-2651'><span class="subsection_label">C.4</span> Data Retrieval Response Time</h3>
<div class="standard" id='magicparlabel-2652'>In order to measure the response time of retrieving data, we insert a large number of Person entities into a running data model instance. We then search for persons, that we know have been put into the data model instance.</div>

<ul class="itemize" id='magicparlabel-2653'><li class="itemize_item">Precondition: A data model instance has been started, and 10000 Person entities has been inserted. The first and last name of each Person entity has additionally been stored in a list.</li>
<li class="itemize_item">Flow of events:
<br />



<ol class="enumerate" id='magicparlabel-2655'><li class="enumerate_item">Get a random first name and last name from the list of inserted names.</li>
<li class="enumerate_item">Record the current time.</li>
<li class="enumerate_item">Run the view that retrieves Persons from the chosen first name and last name.</li>
<li class="enumerate_item">Record the current time, calculate the time difference, and go back to step 1.</li>
</ol>
</li></ul>
<h4 class="subsubsection" id='magicparlabel-2659'><span class="subsubsection_label">C.4.1</span> Results</h4>
<div class="standard" id='magicparlabel-2660'>The response time when using two different indexes (a compare index and an equals index) is shown in figure .</div>


<h4 class="subsubsection" id='magicparlabel-2675'><span class="subsubsection_label">C.4.2</span> Discussion</h4>
<div class="standard" id='magicparlabel-2676'>The response time lies around 0.16 ms to 0.30 ms when using the compare index (which is based on a tree map), while the equals index (based on a hash map) is slightly faster, ranging from 0.12 ms to 0.22 ms.</div>
<h3 class="subsection" id='magicparlabel-2677'><span class="subsection_label">C.5</span> Data Retrieval Throughput</h3>
<div class="standard" id='magicparlabel-2678'>Measuring the throughput of retrieving data is done by creating a variable amount of worker threads, each retrieving a Person from the first name and last name.</div>

<ul class="itemize" id='magicparlabel-2679'><li class="itemize_item">Preconditions: A data model instance is started, and 100.000 Person entities has been inserted. The first and last name of each Person entity has additionally been stored in a list.</li>
<li class="itemize_item">Flow of events:
<br />



<ol class="enumerate" id='magicparlabel-2681'><li class="enumerate_item">Run garbage collection and finalization.</li>
<li class="enumerate_item">Create a number of worker threads, each with the task of retrieving a person from a first name and last name.</li>
<li class="enumerate_item">Record the current time.</li>
<li class="enumerate_item">Start all the worker threads.</li>
<li class="enumerate_item">Join all the worker threads.</li>
<li class="enumerate_item">Record the current time.</li>
<li class="enumerate_item">Calculate the throughput, as the number of views executed per millisecond.</li>
<li class="enumerate_item">Increase the number of worker threads, and go back to step 1.</li>
</ol>
</li></ul>
<div class="standard" id='magicparlabel-2689'>The worker threads together execute a total of one million views.</div>
<h4 class="subsubsection" id='magicparlabel-2690'><span class="subsubsection_label">C.5.1</span> Results</h4>
<div class="standard" id='magicparlabel-2691'>The results for the throughput measuring can be seen in figure .</div>



<div class="standard" id='magicparlabel-2706'>The x-axis shows the number of concurrent threads to perform the views, and the y-axis shows the calculated number of persons that was retrieved per millisecond.</div>

<div class="standard" id='magicparlabel-2707'>Running with one thread gives a throughput of 13.75 views / ms with the compare index, and 14.8 with the equal index. Increasing the number of threads to 2 gives a compare index throughput of 58 views / ms, while the equals index is 45 views / ms. The throughput stabilizes at around 78 views / ms for the equals index, and 67 views / ms for the compare index, as long as there are less than 100 worker threads. Using more than 100 threads, the throughput drops to about 30 views / ms.</div>
<h4 class="subsubsection" id='magicparlabel-2708'><span class="subsubsection_label">C.5.2</span> Discussion</h4>
<div class="standard" id='magicparlabel-2709'>The results show, as expected, that the equals index has a higher throughput value than the compare index, and that running with multiple threads has a great impact, compared to running with only one thread. However, when the number of threads is higher than the size of the execution buffer (here 100), the throughput drops to around 30 views / ms.</div>
<h3 class="subsection" id='magicparlabel-2710'><span class="subsection_label">C.6</span> Interleaved Actions and Views</h3>
<div class="standard" id='magicparlabel-2711'>In order to see how the number of actions affects the total throughput, when running interleaved actions and views, we run the following procedure.</div>

<ul class="itemize" id='magicparlabel-2712'><li class="itemize_item">Precondition: A data model instance has been started, and 100.000 Person entities has been inserted.</li>
<li class="itemize_item">Flow of events:
<br />



<ol class="enumerate" id='magicparlabel-2714'><li class="enumerate_item"><math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>p</mi>
   </mrow>
   <mrow>
    <mrow><mi>a</mi><mi>c</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi>
    </mrow>
   </mrow>
  </msub>
 </mrow></math>, the probability of running an action instead of a view, is set to 0.</li>
<li class="enumerate_item">While <em><math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow>
   <msub>
    <mrow><mi>p</mi>
    </mrow>
    <mrow>
     <mrow><mi>a</mi><mi>c</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi>
     </mrow>
    </mrow>
   </msub><mo> &le; </mo><mn>1</mn>
  </mrow>
 </mrow></math>
<br />

</em>

<ol class="enumerate" id='magicparlabel-2716'><li class="enumerate_item">50 worker threads are created, with the task of running either an action or a view in each iteration, depending on <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>p</mi>
   </mrow>
   <mrow>
    <mrow><mi>a</mi><mi>c</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi>
    </mrow>
   </mrow>
  </msub>
 </mrow></math>.</li>
<li class="enumerate_item">The current time is recorded.</li>
<li class="enumerate_item">All the worker threads are started.</li>
<li class="enumerate_item">All the worker threads are joined.</li>
<li class="enumerate_item">The current time is recorded.</li>
<li class="enumerate_item">The total number of actions and views are determined.</li>
<li class="enumerate_item">The total throughput, the view throughput and the action throughput is calculated.</li>
<li class="enumerate_item"><math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>p</mi>
   </mrow>
   <mrow>
    <mrow><mi>a</mi><mi>c</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi>
    </mrow>
   </mrow>
  </msub>
 </mrow></math> is increased by 0.02.</li>
</ol>
</li></ol>
</li></ul>
<h4 class="subsubsection" id='magicparlabel-2724'><span class="subsubsection_label">C.6.1</span> Results</h4>
<div class="standard" id='magicparlabel-2725'>The result of running interleaved actions and views can be seen in figure .</div>


<h4 class="subsubsection" id='magicparlabel-2740'><span class="subsubsection_label">C.6.2</span> Discussion</h4>
<div class="standard" id='magicparlabel-2741'>The graph shown in figure  shows that the total throughput remains constant, even if the probability of running actions increases. The action throughput seems almost directly inverse to the view throughput, which is contrary to our expectations. Since our runtime system is able to run multiple views concurrently, but not actions, we would expect a dropping total throughput, when increasing the number of actions run.</div>
<h3 class="subsection" id='magicparlabel-2746'><span class="subsection_label">C.7</span> Scalability</h3>
<div class="standard" id='magicparlabel-2747'>Scalability denotes the possibilities of adding workload to the system. Andre B. Bondi of Bell Labs proposes definitions of 6 different scalability aspects in [<a href='#LyXCite-bondi2000characteristics'><span class="bib-label">4</span></a>]. According to Bondi, there are at least the following aspects of scalability:</div>

<ol class='lyxlist' id='magicparlabel-2748'><li class="labeling_item"><span class='lyxlist'>Load&nbsp;Scalability</span>
 – describes how well a system is able to function gracefully at light, moderate or heavy load, i.e. mostly considering variance in the number of users.</li>
<li class="labeling_item"><span class='lyxlist'>Space&nbsp;Scalability</span>
 – describes how the memory requirements changes, as the amount of data handled by a system changes. The system can be considered spatially scalable, if the memory usage grows sublinearly with the number of data items in question.</li>
<li class="labeling_item"><span class='lyxlist'>Space-Time&nbsp;Scalability</span>
 – describes the ability for a system to function gracefully, when the amount of data changes by orders of magnitude.</li>
<li class="labeling_item"><span class='lyxlist'>Structural&nbsp;Scalability</span>
 – describes whether a system uses data structures or algorithms that naturally limit the amount of data that can be contained or dealt with.</li>
<li class="labeling_item"><span class='lyxlist'>Distance&nbsp;Scalability</span>
 – the ability for a system to operate over short as well as long distances (considering issues such as reliability at drop-outs, timing issues, noise, etc.)</li>
<li class="labeling_item"><span class='lyxlist'>Speed/Distance&nbsp;Scalability</span>
 – the ability for a system to operate at high speed over short as well as long distances.</li>
</ol>
<div class="standard" id='magicparlabel-2754'>Throughout the project, some of these scalability aspects has been prioritized higher than others. In the beginning of developing the EDMA system, although not formally stated anywhere, it was the thought that it should be able to serve small businesses with &ldquo;thousands&rdquo; of users (&lt;10000). </div>
<h4 class="subsubsection" id='magicparlabel-2755'><span class="subsubsection_label">C.7.1</span> Load Scalability</h4>
<div class="standard" id='magicparlabel-2756'>The load scalability mainly depends on the execution of actions and views, together with the persistence. According to Bondi, load scalability can be improved by not having unproductive execution cycles in the program, avoiding busy waiting, and allow parallel execution where possible. As explained in the section about the transaction execution, EDMA is able to execute multiple views at the same time. However, only one action can be executed at the time, which puts a boundary on the load scalability. However, even if only one action can be executed at the time, heavy load will have the system continue gracefully, until a certain degree, determined by the maximum size of the execution buffer and the persistence buffer. When these are both filled, throughput decreases drastically, as shown in the test of data insertion throughput.</div>
<h4 class="subsubsection" id='magicparlabel-2757'><span class="subsubsection_label">C.7.2</span> Space Scalability</h4>
<div class="standard" id='magicparlabel-2758'>The space scalability depends on how data is stored in the runtime system, and how it is persisted on the disk.</div>

<div class="standard" id='magicparlabel-2759'>In the runtime system, data is held in the memory, in the kind stores. The kind stores hold all data entities in maps, with an ID as key (as a long), and an Entity object as value. The Entity contains an Object array, holding the actual attribute values. However, the value domain system uses instance control, guaranteeing that two equal values will only be instantiated once in the memory. Therefore, the entities that are kept by the kind store may reuse each others' values. However, the kind store still has to hold separate Entity objects for each entity, making it linearly growing with the amount of data. This makes the system less scalable as seen from the spatial aspect. The upper bound for the amount of data is decided by the choice of either using Java maps, or maps from the JDBM3 library (the user chooses this upon instantiation of the data model.) If the former is used, the upper bound is determined by the amount of RAM that is available to the Java Virtual Machine. If the latter is used, the upper bound is determined by the disk size.</div>
<h4 class="subsubsection" id='magicparlabel-2760'><span class="subsubsection_label">C.7.3</span> Space-Time scalability</h4>
<div class="standard" id='magicparlabel-2761'>With respect to data search, EDMA uses tree maps for compare-indexes and hash maps for equal-indexes, making it efficient. If the user instead uses a custom made filter to search for data of a certain kind, data is traversed linearly, hurting the space-time scalability. Therefore, the user should be encouraged to use indexes as much as possible, and applying custom filters as late in the search process as possible.</div>
<h4 class="subsubsection" id='magicparlabel-2762'><span class="subsubsection_label">C.7.4</span> Structural scalability</h4>
<div class="standard" id='magicparlabel-2763'>Naturally, there are limits for how much data can be stored. If regular Java maps are used for storing the runtime data, the amount of RAM accessible is a limit for the data amount, and the file system is a limit for the log file size. </div>

<div class="standard" id='magicparlabel-2764'>From the user's point of view, some aspects of the EDMA system are structurally scalable, while others are not. There are some logical problems in changing a data model, after it has been taken into use – for example:</div>

<ul class="itemize" id='magicparlabel-2765'><li class="itemize_item">If a kind is removed, what should be done when the data model tries to load the log file, where the kind existed?</li>
<li class="itemize_item">If non-optional attributes are added to a kind, or a new kind with non-optional attributes is added, what should be the values of the new attributes? When the log file is loaded, how can kind entities be created, if there are no stored values for the newly added attributes?</li>
<li class="itemize_item">What should be done if a kind or an attribute is renamed?</li>
</ul>
<div class="standard" id='magicparlabel-2768'>Some of these problems can be solved by having more interaction with the user – for example, in the case of renaming an element, the user could explicitly tell EDMA the old name and the new name of the element, upon instantiation. In the case of newly added attributes, the user could either manually or automatically supply the missing data, possibly adding null-data or temporary &ldquo;dummy&rdquo; data (e.g. 00000000 for phone number.)</div>

<div class="standard" id='magicparlabel-2769'>In this project, we haven't taken into account that the user should be able to change the data model after it has been taken into use. However, because of it's structure, the user is able to make the following changes to a data model, after it has been taken into use (i.e. data has been stored in the log file):</div>

<ul class="itemize" id='magicparlabel-2770'><li class="itemize_item">Adding kinds (after the last kind in the data model in the data model definition)</li>
<li class="itemize_item">Adding optional attributes to kinds</li>
<li class="itemize_item">Adding relations (after the last relation in the data model definition)</li>
<li class="itemize_item">Adding actions and views</li>
<li class="itemize_item">Adding indexes to existing kinds and relations</li>
</ul>
<div class="standard" id='magicparlabel-2775'>The reason to only be able to be added &ldquo;in the end&rdquo;, is that the runtime system uses the sequential order of the kind (0, 1, 2, ...) in the definition file, rather than the kind name. Adding a kind in the top, will therefore push all the other kinds one step forward, which will invalidate the log file. </div>

<div class="standard" id='magicparlabel-2776'>The following is not possible without substantial changes to the system:</div>

<ul class="itemize" id='magicparlabel-2777'><li class="itemize_item">Removing or renaming kinds, attributes, relations, actions or views (renaming or removing actions or views does not break anything in the runtime system directly, but will break the user's code)</li>
<li class="itemize_item">Adding non-optional attributes to kinds</li>
</ul>





<div class='nomencl'><h2 class='nomencl'>Nomenclature</h2>

<dl><dt><a href='#magicparlabel-532' class='nomencl'>Attribute</a></dt>
<dd>A name and a value domain. An example could be "age" in the value domain "PositiveInteger", which is comparable to a variable "age" of type "uint". Attributes are either optional or mandatory, and mutable or immutable.</dd>
<dt><a href='#magicparlabel-410' class='nomencl'>Data model definition</a></dt>
<dd>A definition of a data model, ie. the elements that can be contained in a data model. A data model definition is often written in a Data Definition Language (DDL), opposed to a Data Manipulation Language (DML).</dd>
<dt><a href='#magicparlabel-532' class='nomencl'>Entity</a></dt>
<dd>A set of values, conforming to a certain kind. </dd>
<dt><a href='#magicparlabel-446' class='nomencl'>Immutable</a></dt>
<dd>Not changable. An immutable variable can never get its value changed over the course of its lifetime.</dd>
<dt><a href='#magicparlabel-532' class='nomencl'>Kind</a></dt>
<dd>A kind consists of a name and a set of attributes. An instance of a kind is called an entity. For example, a kind could be Person, with the attributes name, birth date and phone number. An entity of this kind could be (John, (1980, 3, 5), 31415926).</dd>
<dt><a href='#magicparlabel-446' class='nomencl'>Mutable</a></dt>
<dd>Changable. A mutable variable can get its value changed over the course of its lifetime.</dd>
<dt><a href='#magicparlabel-534' class='nomencl'>Relation</a></dt>
<dd>A connection between two kinds. If a relation exists between kinds A and B, entities of A and B can be connected. For example, a relation can exist between kinds Course and Student, which means that an entity of course (eg. (Programming, 2012)) can be connected to a Student (eg. (John Doe, 1984, +4531415926)).</dd>
<dt><a href='#magicparlabel-443' class='nomencl'>Value domain</a></dt>
<dd>Can be seen as a type with extra restrictions on the possible values. Like the value 42 could be of type "int", the value "John" could be in a value domain "Name".</dd>
</dl>
</div>


<div class="standard" id='magicparlabel-2781'><h2 class='bibtex'>References</h2><div class='bibtex'><div class='bibtexentry' id='LyXCite-baker2011megastore'><span class='bibtexinfo'><span class="bib-fullnames:author">J. Baker, C. Bond, J.C. Corbett, JJ Furman, A. Khorlin, J. Larson, J.M. Léon, Y. Li, A. Lloyd, and V. Yushprakh</span>, "<span class="bib-title">Megastore: Providing scalable, highly available storage for interactive services</span>", in <i><span class="bib-booktitle">Proc. of CIDR</span></i> (<span class="bib-year">2011</span>).</span></div>
<div class='bibtexentry' id='LyXCite-berenson1995critique'><span class='bibtexinfo'><span class="bib-fullnames:author">H. Berenson, P. Bernstein, J. Gray, J. Melton, E. O'Neil, and P. O'Neil</span>, "<span class="bib-title">A critique of ANSI SQL isolation levels</span>", <i><span class="bib-journal">ACM SIGMOD Record</span></i>  <span class="bib-volume">24</span>, <span class="bib-number">2</span> (<span class="bib-year">1995</span>), pp. <span class="bib-pages">1--10</span>.</span></div>
<div class='bibtexentry' id='LyXCite-bierman2005first'><span class='bibtexinfo'><span class="bib-fullnames:author">G. Bierman and A. Wren</span>, "<span class="bib-title">First-class relationships in an object-oriented language</span>", <i><span class="bib-journal">ECOOP 2005-Object-Oriented Programming</span></i>  (<span class="bib-year">2005</span>), pp. <span class="bib-pages">733--733</span>.</span></div>
<div class='bibtexentry' id='LyXCite-bloch2008effective'><span class='bibtexinfo'><span class="bib-fullnames:author">J. Bloch</span>, <i><span class="bib-title">Effective Java</span></i> (<span class="bib-publisher">Prentice Hall</span>, <span class="bib-year">2008</span>).</span></div>
<div class='bibtexentry' id='LyXCite-bondi2000characteristics'><span class='bibtexinfo'><span class="bib-fullnames:author">A.B. Bondi</span>, "<span class="bib-title">Characteristics of scalability and their impact on performance</span>", in <i><span class="bib-booktitle">Proceedings of the 2nd international workshop on Software and performance</span></i> (<span class="bib-year">2000</span>), pp. <span class="bib-pages">195--203</span>.</span></div>
<div class='bibtexentry' id='LyXCite-chamberlin1974sequel'><span class='bibtexinfo'><span class="bib-fullnames:author">D.D. Chamberlin and R.F. Boyce</span>, "<span class="bib-title">SEQUEL: A structured English query language</span>", in <i><span class="bib-booktitle">Proceedings of the 1974 ACM SIGFIDET (now SIGMOD) workshop on Data description, access and control</span></i> (<span class="bib-year">1974</span>), pp. <span class="bib-pages">249--264</span>.</span></div>
<div class='bibtexentry' id='LyXCite-chang2008bigtable'><span class='bibtexinfo'><span class="bib-fullnames:author">F. Chang, J. Dean, S. Ghemawat, W.C. Hsieh, D.A. Wallach, M. Burrows, T. Chandra, A. Fikes, and R.E. Gruber</span>, "<span class="bib-title">Bigtable: A distributed storage system for structured data</span>", <i><span class="bib-journal">ACM Transactions on Computer Systems (TOCS)</span></i>  <span class="bib-volume">26</span>, <span class="bib-number">2</span> (<span class="bib-year">2008</span>), pp. <span class="bib-pages">4</span>.</span></div>
<div class='bibtexentry' id='LyXCite-chen1976entity'><span class='bibtexinfo'><span class="bib-fullnames:author">P.P.S. Chen</span>, "<span class="bib-title">The entity-relationship model - toward a unified view of data</span>", <i><span class="bib-journal">ACM Transactions on Database Systems (TODS)</span></i>  <span class="bib-volume">1</span>, <span class="bib-number">1</span> (<span class="bib-year">1976</span>), pp. <span class="bib-pages">9--36</span>.</span></div>
<div class='bibtexentry' id='LyXCite-dieckmann1999study'><span class='bibtexinfo'><span class="bib-fullnames:author">S. Dieckmann and U. Hölzle</span>, "<span class="bib-title">A study of the allocation behavior of the SPECjvm98 Java benchmarks</span>", <i><span class="bib-journal">ECOOP'99-Object-Oriented Programming</span></i>  (<span class="bib-year">1999</span>), pp. <span class="bib-pages">668--668</span>.</span></div>
<div class='bibtexentry' id='LyXCite-fowler2008'><span class='bibtexinfo'>"<span class="bib-title">FluidInterface</span>" (<span class="bib-year">2008</span>).</span></div>
<div class='bibtexentry' id='LyXCite-hogg1992geneva'><span class='bibtexinfo'><span class="bib-fullnames:author">J. Hogg, D. Lea, A. Wills, D. deChampeaux, and R. Holt</span>, "<span class="bib-title">The Geneva convention on the treatment of object aliasing</span>", <i><span class="bib-journal">ACM SIGPLAN OOPS Messenger</span></i>  <span class="bib-volume">3</span>, <span class="bib-number">2</span> (<span class="bib-year">1992</span>), pp. <span class="bib-pages">11--16</span>.</span></div>
<div class='bibtexentry' id='LyXCite-ireland2009classification'><span class='bibtexinfo'><span class="bib-fullnames:author">C. Ireland, D. Bowers, M. Newton, and K. Waugh</span>, "<span class="bib-title">A classification of object-relational impedance mismatch</span>", in <i><span class="bib-booktitle">Advances in Databases, Knowledge, and Data Applications, 2009. DBKDA'09. First International Conference on</span></i> (<span class="bib-year">2009</span>), pp. <span class="bib-pages">36--43</span>.</span></div>
<div class='bibtexentry' id='LyXCite-java6doc'><span class='bibtexinfo'>"<span class="bib-title">Javadoc, JavaSE 6</span>" (<span class="bib-year">2012</span>).</span></div>
<div class='bibtexentry' id='LyXCite-keller1997mapping'><span class='bibtexinfo'><span class="bib-fullnames:author">W. Keller</span>, "<span class="bib-title">Mapping Objects to Tables</span>", in <i><span class="bib-booktitle">Proceedings of Second European Conference on Pattern Languages of Programming (EuroPLoP'97). Siemens Technical Report</span></i> vol. <span class="bib-volume">120</span>,  (<span class="bib-year">1997</span>).</span></div>
<div class='bibtexentry' id='LyXCite-lethbridge2002object'><span class='bibtexinfo'><span class="bib-fullnames:author">T. Lethbridge and R. Laganiere</span>, "<span class="bib-title">Object-Oriented Software Engineering: Practical Software Development using UML and Java</span>", <i></i>  (<span class="bib-year">2002</span>).</span></div>
<div class='bibtexentry' id='LyXCite-lewis2002databases'><span class='bibtexinfo'><span class="bib-fullnames:author">P.M. Lewis, A. Bernstein, and M. Kifer</span>, <i><span class="bib-title">Databases and Transaction Procesing: An Application-Oriented Approach</span></i> (<span class="bib-publisher">Addison-Wesley</span>, <span class="bib-year">2002</span>).</span></div>
<div class='bibtexentry' id='LyXCite-noble1997basic'><span class='bibtexinfo'><span class="bib-fullnames:author">J. Noble</span>, "<span class="bib-title">Basic relationship patterns</span>", <i><span class="bib-journal">Pattern Languages of Program Design</span></i>  <span class="bib-volume">4</span> (<span class="bib-year">1997</span>), pp. <span class="bib-pages">73--94</span>.</span></div>
<div class='bibtexentry' id='LyXCite-o2008object'><span class='bibtexinfo'><span class="bib-fullnames:author">E.J. O'Neil</span>, "<span class="bib-title">Object/relational mapping 2008: hibernate and the entity data model (edm)</span>", in <i><span class="bib-booktitle">Proceedings of the 2008 ACM SIGMOD international conference on Management of data</span></i> (<span class="bib-year">2008</span>), pp. <span class="bib-pages">1351--1356</span>.</span></div>
<div class='bibtexentry' id='LyXCite-parr2007definitive'><span class='bibtexinfo'><span class="bib-fullnames:author">T. Parr</span>, <i><span class="bib-title">The definitive ANTLR reference: building domain-specific languages</span></i> (<span class="bib-year">2007</span>).</span></div>
<div class='bibtexentry' id='LyXCite-psm'><span class='bibtexinfo'>"<span class="bib-title">SQL/PSM - Procedures Stored in the Database, General-Purpose Programming</span>".</span></div>
<div class='bibtexentry' id='LyXCite-rumbaugh1987relations'><span class='bibtexinfo'><span class="bib-fullnames:author">J. Rumbaugh</span>, "<span class="bib-title">Relations as semantic constructs in an object-oriented language</span>", <i><span class="bib-journal">ACM Sigplan Notices</span></i>  <span class="bib-volume">22</span>, <span class="bib-number">12</span> (<span class="bib-year">1987</span>), pp. <span class="bib-pages">466--481</span>.</span></div>
<div class='bibtexentry' id='LyXCite-shah1989dsm'><span class='bibtexinfo'><span class="bib-fullnames:author">A.V. Shah, J.H. Hamel, R.A. Borsari, and JE Rumbaugh</span>, "<span class="bib-title">DSM: an object-relationship modeling language</span>", <i><span class="bib-journal">ACM Sigplan Notices</span></i>  <span class="bib-volume">24</span>, <span class="bib-number">10</span> (<span class="bib-year">1989</span>), pp. <span class="bib-pages">191--202</span>.</span></div>
<div class='bibtexentry' id='LyXCite-sql92'><span class='bibtexinfo'>"<span class="bib-title">SQL-92 Specification (ISO/IEC 9075:1992, Database Language SQL - July 30, 1992)</span>" (<span class="bib-year">2012</span>).</span></div>
<div class='bibtexentry' id='LyXCite-stefik1985object'><span class='bibtexinfo'><span class="bib-fullnames:author">M. Stefik and D.G. Bobrow</span>, "<span class="bib-title">Object-oriented programming: Themes and variations</span>", <i><span class="bib-journal">AI magazine</span></i>  <span class="bib-volume">6</span>, <span class="bib-number">4</span> (<span class="bib-year">1985</span>), pp. <span class="bib-pages">40</span>.</span></div>
<div class='bibtexentry' id='LyXCite-stroustrup2012software'><span class='bibtexinfo'><span class="bib-fullnames:author">B. Stroustrup</span>, "<span class="bib-title">Software Development for Infrastructure</span>", <i><span class="bib-journal">Computer-IEEE Computer Magazine</span></i>  <span class="bib-volume">45</span>, <span class="bib-number">1</span> (<span class="bib-year">2012</span>), pp. <span class="bib-pages">47</span>.</span></div>
<div class='bibtexentry' id='LyXCite-subramanian1999performance'><span class='bibtexinfo'><span class="bib-fullnames:author">M. Subramanian, V. Krishnamurthy, and R. Shores</span>, "<span class="bib-title">Performance challenges in object-relational DBMSs</span>", <i><span class="bib-journal">Data Engineering Bulletin</span></i>  <span class="bib-volume">22</span>, <span class="bib-number">2</span> (<span class="bib-year">1999</span>), pp. <span class="bib-pages">27--31</span>.</span></div>
<div class='bibtexentry' id='LyXCite-sutter2007software'><span class='bibtexinfo'><span class="bib-fullnames:author">H. Sutter</span>, "<span class="bib-title">Software and the Concurrency Revolution</span>", <i></i>  (<span class="bib-year">2007</span>).</span></div>
<div class='bibtexentry' id='LyXCite-torque'><span class='bibtexinfo'>"<span class="bib-title">Apache Torque</span>" (<span class="bib-year">2012</span>).</span></div>
<div class='bibtexentry' id='LyXCite-venkatrao1995sql'><span class='bibtexinfo'><span class="bib-fullnames:author">M. Venkatrao and M. Pizzo</span>, "<span class="bib-title">SQL/CLI - a new binding style for SQL</span>", <i><span class="bib-journal">ACM SIGMOD Record</span></i>  <span class="bib-volume">24</span>, <span class="bib-number">4</span> (<span class="bib-year">1995</span>), pp. <span class="bib-pages">72--77</span>.</span></div>
<div class='bibtexentry' id='LyXCite-vietnam2007'><span class='bibtexinfo'>"<span class="bib-title">The Vietnam of Computer Science</span>" (<span class="bib-year">2006</span>).</span></div>
</div></div>
</body>
</html>
