
\section{Introduction}

Many software development projects use object oriented approaches
to solve various problems. The main idea in object oriented development
is to use various abstraction levels to overview and understand large
and complex systems. An object should encapsulate and hide any internal
structure and state from the outside world and provide only an interface
for the outside world to see and use. One advantage of doing this,
is that the object can then be seen at a higher level of abstraction,
since the outside viewer does not have to care about the internal
details. Another advantage is that the object could easily be replaced
with another object providing the same interface, but with a different
implementation.

In an ideal world, building software would be much like playing with
LEGO bricks. Instead of building large specialized programs from scratch,
we should rather create a good set of small abstract programs that
can be put together in different ways to solve different tasks. There
are two properties in which software development is superior to LEGO:
\begin{itemize}
\item When you need a type of brick that LEGO does not manufacture, it is
rather hard to make it yourself. This is not the case in software
development. 
\item You have an unlimited number of each type of brick, so in software
development reuse does not mean recycle. You do not have to tear down
the beautiful house you build yesterday, because you want to build
a robot today.
\end{itemize}
In a good object oriented design, interfaces are designed at the highest
possible level of abstraction to obtain high flexibility and code
reuse.

Here is a very simple example to illustrate the idea of polymorphism
through an interface: 

We want to create some Java programs that interacts with a user through
a textual interface. This could be written using System.in to receive
input from the user and System.out to show a text to the user. But
in a good object oriented design we would instead create a terminal
interface with a putString and a getString, that our programs would
use instead of the System.in and System.out. Then when we could create
an implementation of the terminal interface that uses the System.in
and System.out. Now we would have the exact same behavior of the program
as if we had used System.in and System.out.

At this point we have done some extra work, but without any real benefit
yet. But then one day we want to send the text messages to and from
a mobile phone or maybe even pass them through voice generation and
recognition to facilitate a blind user. All we have to do then is
create new implementations of the terminal interface, leaving the
original programs untouched. 

People that play with LEGO bricks often tries to make models of real-world
objects like trains, houses, persons, cars cities etc. Sometimes they
also try to model objects from fantasy worlds like dragons, goblins,
unicorns etc. Software developers also often try to model objects
and concepts from real or fantasy worlds (this is especially true
for game developers).

Imagine that you have spent an entire day building a large LEGO city.
Then you get tired and go to bed. Next morning when you wake up, the
city is still there exactly as you left it.

Unfortunately this does NOT work in a typical object oriented language.
When you turn off the computer, all objects disappear and you have
to start all over next time you start the computer. We would actually
like to have this as an optional feature for our LEGO bricks, so if
we pushed a button, all bricks would automatically be returned to
their starting position in the drawer.

With LEGO bricks persistence is build in as a standard, but it takes
quite some work to reset everything. In a typical object oriented
language persistence takes quite some work to get, but resetting is
easy.

In this thesis we will analyze various methods of abstraction that
could make software developing faster and even more like playing with
LEGO bricks.

We will analyze methods to \emph{shorten the path from an idea of
a model to a functional prototype}. We will use ideas from various
domains: Object oriented programming, model driven development, modular
programming, interface based programming, entity-relationships and
LEGO.
