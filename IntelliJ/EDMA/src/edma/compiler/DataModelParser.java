/* Generated By:JavaCC: Do not edit this line. DataModelParser.java */
package edma.compiler;
import java.util.ArrayList;
import edma.compiler.ast.*;
import edma.compiler.ast.IndexNode.IndexType;
import edma.compiler.ast.ActionViewNode;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.InputStream;
import edma.compiler.ast.ValueDomainSingle.VdSingleType;

public class DataModelParser implements DataModelParserConstants {
  static String fileName;
  public WorldNode newWorld(String fileName)
  {
    DataModelParser.fileName = fileName;
    return new WorldNode(fileName);
  }

  public static void main(String args []) throws ParseException, TokenMgrError
  {
    //System.out.println(System.getProperty("user.dir"));
    String file = "src/testDm.dm";
    InputStream is = System.in;
    try
    {
      is = new FileInputStream(file);
    }
    catch (FileNotFoundException fnfex)
    {
      is = System.in;
      System.out.println("Could not load file \u005c"" + file + "\u005c". " + "Reading from standard in.");
    }
    DataModelParser p = new DataModelParser(is);
    WorldNode world = p.newWorld(file);
    p.Input(world);
    world.print("");
  }

/** Productions */
  final public void Input(WorldNode world) throws ParseException {
  AValueDomainNode vd;
  DataModelNode dm;
    label_1:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case KEYWORD_VALUEDOMAIN:
        ;
        break;
      default:
        jj_la1[0] = jj_gen;
        break label_1;
      }
      vd = ValueDomain(null);
      world.addValueDomain(vd);
    }
    label_2:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case KEYWORD_DATAMODEL:
        ;
        break;
      default:
        jj_la1[1] = jj_gen;
        break label_2;
      }
      dm = DataModel();
      world.addDataModel(dm);
    }
    jj_consume_token(0);
  }

/*
ValueDomain Year Integer[0..MAX]
ValueDomain Month Integer[1..12]
ValueDomain Day Integer[1..31]

ValueDomain Date
{
  year : Year,
  month : Month,
  day : Day
}
*/
  final public AValueDomainNode ValueDomain(String scope) throws ParseException {
  Token t;
  AValueDomainNode e;
  String name;
  int lineNum;
  ArrayList<ConstraintNode > cList;
    t = jj_consume_token(KEYWORD_VALUEDOMAIN);
                                 lineNum = t.beginLine;
    t = jj_consume_token(IDENTIFIER);
    name = t.image;
    jj_consume_token(COLON);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case KEYWORD_ENUM:
      e = ValueDomainEnum(lineNum, name, scope);
      break;
    case KEYWORD_LISTOF:
      e = ValueDomainList(lineNum, name, scope);
      break;
    case KEYWORD_MAP:
      e = ValueDomainMap(lineNum, name, scope);
      break;
    case KEYWORD_STRUCT:
      e = ValueDomainStruct(lineNum, name, scope);
      break;
    case BOOLEAN_DOMAIN:
    case STRING_DOMAIN:
    case FLOAT_DOMAIN:
    case DOUBLE_DOMAIN:
    case INTEGER_DOMAIN:
    case LONG_DOMAIN:
      e = ValueDomainSingle(lineNum, name, scope);
      break;
    case KEYWORD_ONEOF:
      e = ValueDomainOneOf(lineNum, name, scope);
      break;
    default:
      jj_la1[2] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case KEYWORD_CONSTRAINTS:
      cList = ConstraintNodeList(name);
        for (ConstraintNode c : cList)
                {
                        e.addConstraint(c);
                }
      break;
    default:
      jj_la1[3] = jj_gen;
      ;
    }
    {if (true) return e;}
    throw new Error("Missing return statement in function");
  }

  final public ArrayList<ConstraintNode > ConstraintNodeList(String typeName) throws ParseException {
  Token t;
  ArrayList<ConstraintNode > list = new ArrayList<ConstraintNode >();
  ConstraintNode c;
    jj_consume_token(KEYWORD_CONSTRAINTS);
    jj_consume_token(L_SQBR);
    c = ConstraintNode(typeName);
    list.add(c);
    label_3:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[4] = jj_gen;
        break label_3;
      }
      jj_consume_token(COMMA);
      c = ConstraintNode(typeName);
          list.add(c);
    }
    jj_consume_token(R_SQBR);
    {if (true) return list;}
    throw new Error("Missing return statement in function");
  }

  final public ConstraintNode ConstraintNode(String typeName) throws ParseException {
  Token t;
  String constraintName, description="No description given";
  int line;
    t = jj_consume_token(CAMELCASE_WORD);
    constraintName = t.image;
    line = t.beginLine;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case Q_STRING:
      t = jj_consume_token(Q_STRING);
                    description=t.image;
      break;
    default:
      jj_la1[5] = jj_gen;
      ;
    }
    {if (true) return new ConstraintNode(fileName, line, typeName, constraintName, description);}
    throw new Error("Missing return statement in function");
  }

/*
ValueDomain Animal Enum [Cat, Dog, Horse]
                   ^^^^^^^^^^^^^^^^^^^^^^
*/
  final public AValueDomainNode ValueDomainEnum(int lineNum, String name, String scope) throws ParseException {
  Token t;
  ValueDomainEnum vd;
    jj_consume_token(KEYWORD_ENUM);
    jj_consume_token(L_SQBR);
    t = jj_consume_token(IDENTIFIER);
    vd = new ValueDomainEnum(fileName, lineNum, name, scope);
    vd.addElement(t.image);
    label_4:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[6] = jj_gen;
        break label_4;
      }
      jj_consume_token(COMMA);
      // OPTION: Comma between enum elements
          t = jj_consume_token(IDENTIFIER);
      vd.addElement(t.image);
    }
    jj_consume_token(R_SQBR);
    {if (true) return vd;}
    throw new Error("Missing return statement in function");
  }

  final public AValueDomainNode ValueDomainList(int lineNum, String name, String scope) throws ParseException {
  Token t;
  String type;
  String range[] = new String[] {null,null};
    jj_consume_token(KEYWORD_LISTOF);
    jj_consume_token(LT);
    t = jj_consume_token(IDENTIFIER);
    jj_consume_token(GT);
    type = t.image;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case L_SQBR:
      range = Range();
      break;
    default:
      jj_la1[7] = jj_gen;
      ;
    }
    {if (true) return new ValueDomainList(fileName, lineNum, name, type, range[0], range[1], scope);}
    throw new Error("Missing return statement in function");
  }

  final public String[] Range() throws ParseException {
  Token t;
  String min, max;
    jj_consume_token(L_SQBR);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case MIN:
      jj_consume_token(MIN);
              min="MIN";
      break;
    case DECIMAL:
    case NUMBER:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DECIMAL:
        t = jj_consume_token(DECIMAL);
                         min=t.image;
        break;
      case NUMBER:
        t = jj_consume_token(NUMBER);
                        min=t.image;
        break;
      default:
        jj_la1[8] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[9] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case R_SQBR:
      jj_consume_token(R_SQBR);
          max=min;
      break;
    case 71:
      jj_consume_token(71);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DECIMAL:
        t = jj_consume_token(DECIMAL);
        break;
      case NUMBER:
        t = jj_consume_token(NUMBER);
        break;
      case MAX:
        t = jj_consume_token(MAX);
        break;
      default:
        jj_la1[10] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      max = t.image;
      jj_consume_token(R_SQBR);
      break;
    default:
      jj_la1[11] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return new String[] { min,max };}
    throw new Error("Missing return statement in function");
  }

  final public AValueDomainNode ValueDomainMap(int lineNum, String name, String scope) throws ParseException {
  Token t;
  String key, value;
    jj_consume_token(KEYWORD_MAP);
    jj_consume_token(LT);
    t = jj_consume_token(IDENTIFIER);
    key = t.image;
    jj_consume_token(COMMA);
    t = jj_consume_token(IDENTIFIER);
    value = t.image;
    jj_consume_token(GT);
    {if (true) return new ValueDomainMap(fileName, lineNum, name, key, value, scope);}
    throw new Error("Missing return statement in function");
  }

/*
ValueDomain Date
{                    <
  year : Year,       <
  month : Month,     <
  day : Day          <
}                    <
*/
  final public AValueDomainNode ValueDomainStruct(int lineNum, String name, String scope) throws ParseException {
  Token t;
  ValueDomainStruct vd = new ValueDomainStruct(fileName, lineNum, name, scope);
  String attName,attType;
  boolean optional = false;
    jj_consume_token(KEYWORD_STRUCT);
    jj_consume_token(L_BR);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CAMELCASE_WORD:
      t = jj_consume_token(CAMELCASE_WORD);
                         attName = t.image;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case QUESTION_MARK:
        jj_consume_token(QUESTION_MARK);
      optional=true;
        break;
      default:
        jj_la1[12] = jj_gen;
        ;
      }
      jj_consume_token(COLON);
      t = jj_consume_token(IDENTIFIER);
    attType = t.image;
    vd.addElement(t.beginLine, attName, attType, optional);
      label_5:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[13] = jj_gen;
          break label_5;
        }
      optional = false;
        jj_consume_token(COMMA);
        t = jj_consume_token(CAMELCASE_WORD);
                           attName = t.image;
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case QUESTION_MARK:
          jj_consume_token(QUESTION_MARK);
        optional = true;
          break;
        default:
          jj_la1[14] = jj_gen;
          ;
        }
        jj_consume_token(COLON);
        t = jj_consume_token(IDENTIFIER);
      attType = t.image;
      vd.addElement(t.beginLine, attName, attType, optional);
      }
      break;
    default:
      jj_la1[15] = jj_gen;
      ;
    }
    jj_consume_token(R_BR);
    {if (true) return vd;}
    throw new Error("Missing return statement in function");
  }

/*
ValueDomain Name String[MIN..MAX]["regex"]
                 ^^^^^^^^^^^^^^^^^^^^^^^^^
*/
  final public AValueDomainNode ValueDomainSingle(int lineNum, String name, String scope) throws ParseException {
  Token t;
  String lims [ ] = new String[]{ null, null };
  String regex = null;
  VdSingleType sgType;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case BOOLEAN_DOMAIN:
      jj_consume_token(BOOLEAN_DOMAIN);
    {if (true) return new ValueDomainSingle(fileName, lineNum, name, ValueDomainSingle.VdSingleType.Boolean, null, null, null, scope);}
      break;
    case STRING_DOMAIN:
      jj_consume_token(STRING_DOMAIN);
      lims = Range();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case L_SQBR:
        regex = RegexRange();
        break;
      default:
        jj_la1[16] = jj_gen;
        ;
      }
    if (regex != null)
        regex = regex.substring(1, regex.length()-1); // cut off the "'s 
    {if (true) return new ValueDomainSingle(fileName, lineNum, name, ValueDomainSingle.VdSingleType.String, lims[0], lims[1], regex, scope);}
      break;
    case FLOAT_DOMAIN:
    case DOUBLE_DOMAIN:
    case INTEGER_DOMAIN:
    case LONG_DOMAIN:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case FLOAT_DOMAIN:
        jj_consume_token(FLOAT_DOMAIN);
                           sgType=ValueDomainSingle.VdSingleType.Float;
        break;
      case DOUBLE_DOMAIN:
        jj_consume_token(DOUBLE_DOMAIN);
                        sgType=ValueDomainSingle.VdSingleType.Double;
        break;
      case INTEGER_DOMAIN:
        jj_consume_token(INTEGER_DOMAIN);
                         sgType=ValueDomainSingle.VdSingleType.Integer;
        break;
      case LONG_DOMAIN:
        jj_consume_token(LONG_DOMAIN);
                      sgType=ValueDomainSingle.VdSingleType.Long;
        break;
      default:
        jj_la1[17] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      lims = Range();
    {if (true) return new ValueDomainSingle(fileName, lineNum, name, sgType, lims[0], lims[1], null, scope);}
      break;
    default:
      jj_la1[18] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public String RegexRange() throws ParseException {
  Token t;
    jj_consume_token(L_SQBR);
    t = jj_consume_token(Q_STRING);
    jj_consume_token(R_SQBR);
    {if (true) return t.image;}
    throw new Error("Missing return statement in function");
  }

  final public AValueDomainNode ValueDomainOneOf(int lineNum, String name, String scope) throws ParseException {
  Token t;
  ValueDomainOneOf vd = new ValueDomainOneOf(fileName, lineNum, name, scope);
    jj_consume_token(KEYWORD_ONEOF);
    jj_consume_token(LT);
    t = jj_consume_token(IDENTIFIER);
    vd.addType(t.image, t.beginLine);
    label_6:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[19] = jj_gen;
        break label_6;
      }
      jj_consume_token(COMMA);
      t = jj_consume_token(IDENTIFIER);
      vd.addType(t.image, t.beginLine);
    }
    jj_consume_token(GT);
    {if (true) return vd;}
    throw new Error("Missing return statement in function");
  }

  final public DataModelNode DataModel() throws ParseException {
  String dmName;
  DataModelNode dm;
  KindNode k;
  RelationNode r;
  SingletonNode s;
  ActionViewNode a;
  AValueDomainNode vd;
  InterfaceNode i;
  Token t;
  ArrayList<ConstraintNode > cList;
    jj_consume_token(KEYWORD_DATAMODEL);
    t = jj_consume_token(IDENTIFIER);
    dmName = t.image;
    dm = new DataModelNode(fileName, t.beginLine, dmName);
    jj_consume_token(L_BR);
    label_7:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case KEYWORD_VALUEDOMAIN:
      case KEYWORD_KIND:
      case KEYWORD_RELATION:
      case KEYWORD_SINGLETON:
      case KEYWORD_ACTION:
      case KEYWORD_INTERFACE:
      case KEYWORD_VIEW:
        ;
        break;
      default:
        jj_la1[20] = jj_gen;
        break label_7;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case KEYWORD_KIND:
        k = Kind();
      dm.addKind(k);
        break;
      case KEYWORD_RELATION:
        r = Relation();
      dm.addRelation(r);
        break;
      case KEYWORD_SINGLETON:
        s = Singleton();
      dm.addSingleton(s);
        break;
      case KEYWORD_ACTION:
      case KEYWORD_VIEW:
        a = ActionView();
      if (a.getType()==ActionViewNode.Type.Action)
        dm.addAction(a);
      else
        dm.addView(a);
        break;
      case KEYWORD_INTERFACE:
        i = Interface();
          dm.addInterface(i);
        break;
      case KEYWORD_VALUEDOMAIN:
        vd = ValueDomain(dmName);
      dm.addValueDomain(vd);
        break;
      default:
        jj_la1[21] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case KEYWORD_CONSTRAINTS:
      cList = ConstraintNodeList(dmName);
                for (ConstraintNode c : cList)
                {
                        dm.addConstraint(c);
                }
      break;
    default:
      jj_la1[22] = jj_gen;
      ;
    }
    jj_consume_token(R_BR);
    {if (true) return dm;}
    throw new Error("Missing return statement in function");
  }

  final public IndexNode Index(String kind) throws ParseException {
  Token t;
  IndexNode idx;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case KEYWORD_UNIQUE:
      t = jj_consume_token(KEYWORD_UNIQUE);
      idx = new IndexNode(fileName, t.beginLine, IndexType.Unique, kind, null);
      break;
    case KEYWORD_EQUALS:
      t = jj_consume_token(KEYWORD_EQUALS);
      idx = new IndexNode(fileName, t.beginLine, IndexType.Equals, kind, null);
      break;
    case KEYWORD_COMPARE:
      t = jj_consume_token(KEYWORD_COMPARE);
      idx = new IndexNode(fileName, t.beginLine, IndexType.Compare, kind, null);
      break;
    default:
      jj_la1[23] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    jj_consume_token(L_PAR);
    t = jj_consume_token(CAMELCASE_WORD);
    idx.addAttribute(t.image);
    label_8:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CAMELCASE_WORD:
      case COMMA:
        ;
        break;
      default:
        jj_la1[24] = jj_gen;
        break label_8;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        jj_consume_token(COMMA);
        break;
      default:
        jj_la1[25] = jj_gen;
        ;
      }
      t = jj_consume_token(CAMELCASE_WORD);
      idx.addAttribute(t.image);
    }
    jj_consume_token(R_PAR);
    {if (true) return idx;}
    throw new Error("Missing return statement in function");
  }

  final public IndexNode RelationIndex() throws ParseException {
  Token t;
  IndexNode idx;
  String kind="";
  String role="";
  IndexType type = IndexType.Unique;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case KEYWORD_UNIQUE:
      t = jj_consume_token(KEYWORD_UNIQUE);
            type = IndexType.Unique;
      break;
    case KEYWORD_EQUALS:
      t = jj_consume_token(KEYWORD_EQUALS);
            type = IndexType.Equals;
      break;
    case KEYWORD_COMPARE:
      t = jj_consume_token(KEYWORD_COMPARE);
            type = IndexType.Compare;
      break;
    default:
      jj_la1[26] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    jj_consume_token(KEYWORD_ON);
    t = jj_consume_token(IDENTIFIER);
    kind=t.image;
    role=t.image.substring(0,1).toLowerCase()+t.image.substring(1);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case COLON:
      jj_consume_token(COLON);
      t = jj_consume_token(CAMELCASE_WORD);
          role=t.image;
      break;
    default:
      jj_la1[27] = jj_gen;
      ;
    }
        idx = new IndexNode(fileName, t.beginLine, type, kind, role);
    jj_consume_token(L_PAR);
    t = jj_consume_token(CAMELCASE_WORD);
    idx.addAttribute(t.image);
    label_9:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CAMELCASE_WORD:
      case COMMA:
        ;
        break;
      default:
        jj_la1[28] = jj_gen;
        break label_9;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        jj_consume_token(COMMA);
        break;
      default:
        jj_la1[29] = jj_gen;
        ;
      }
      t = jj_consume_token(CAMELCASE_WORD);
      idx.addAttribute(t.image);
    }
    jj_consume_token(R_PAR);
    {if (true) return idx;}
    throw new Error("Missing return statement in function");
  }

  final public KindNode Kind() throws ParseException {
  Token t;
  KindNode kind;
  AttributeNode att;
  IndexNode idx;
  String kindName;
  String baseType = null;
  String valueDomain = null;
  boolean publish = false;
  ArrayList<ConstraintNode > cList;
    jj_consume_token(KEYWORD_KIND);
    t = jj_consume_token(IDENTIFIER);
                                        kindName = t.image; valueDomain = kindName;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case KEYWORD_EXTENDS:
      jj_consume_token(KEYWORD_EXTENDS);
      t = jj_consume_token(IDENTIFIER);
                                             baseType = t.image;
      break;
    default:
      jj_la1[30] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case KEYWORD_PUBLISH:
      jj_consume_token(KEYWORD_PUBLISH);
                         publish = true;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case KEYWORD_AS:
        jj_consume_token(KEYWORD_AS);
        t = jj_consume_token(IDENTIFIER);
                                           valueDomain = t.image;
        break;
      default:
        jj_la1[31] = jj_gen;
        ;
      }
      break;
    default:
      jj_la1[32] = jj_gen;
      ;
    }
    kind = new KindNode(fileName, t.beginLine, kindName, baseType, (publish?valueDomain:null));
    jj_consume_token(L_BR);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case KEYWORD_UNIQUE:
    case KEYWORD_COMPARE:
    case KEYWORD_EQUALS:
    case KEYWORD_CONSTRAINTS:
    case CAMELCASE_WORD:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CAMELCASE_WORD:
        att = Attribute();
                               kind.addAttribute(att);
        break;
      case KEYWORD_UNIQUE:
      case KEYWORD_COMPARE:
      case KEYWORD_EQUALS:
        idx = Index(kindName);
                                   kind.addIndex(idx);
        break;
      case KEYWORD_CONSTRAINTS:
        cList = ConstraintNodeList(kindName);
                                                  for(ConstraintNode c : cList) kind.addConstraint(c);
        break;
      default:
        jj_la1[33] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      label_10:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[34] = jj_gen;
          break label_10;
        }
        jj_consume_token(COMMA);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case CAMELCASE_WORD:
          att = Attribute();
                                   kind.addAttribute(att);
          break;
        case KEYWORD_UNIQUE:
        case KEYWORD_COMPARE:
        case KEYWORD_EQUALS:
          idx = Index(kindName);
                                       kind.addIndex(idx);
          break;
        case KEYWORD_CONSTRAINTS:
          cList = ConstraintNodeList(kindName);
                                                      for(ConstraintNode c : cList) kind.addConstraint(c);
          break;
        default:
          jj_la1[35] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      break;
    default:
      jj_la1[36] = jj_gen;
      ;
    }
    jj_consume_token(R_BR);
    {if (true) return kind;}
    throw new Error("Missing return statement in function");
  }

  final public AttributeNode Attribute() throws ParseException {
  Token t;
  String name;
  String valueDomain;
  String defaultValue=null;
  boolean optional = false;
  boolean modifiable = false;
    t = jj_consume_token(CAMELCASE_WORD);
    name = t.image;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case QUESTION_MARK:
    case PLUS:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case QUESTION_MARK:
        jj_consume_token(QUESTION_MARK);
                        optional = true;
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case PLUS:
          jj_consume_token(PLUS);
                modifiable = true;
          break;
        default:
          jj_la1[37] = jj_gen;
          ;
        }
        break;
      case PLUS:
        jj_consume_token(PLUS);
              modifiable = true;
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case QUESTION_MARK:
          jj_consume_token(QUESTION_MARK);
                         optional = true;
          break;
        default:
          jj_la1[38] = jj_gen;
          ;
        }
        break;
      default:
        jj_la1[39] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[40] = jj_gen;
      ;
    }
    jj_consume_token(COLON);
    t = jj_consume_token(IDENTIFIER);
    valueDomain = t.image;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case KEYWORD_DEFAULT:
      jj_consume_token(KEYWORD_DEFAULT);
      jj_consume_token(L_SQBR);
      defaultValue = BasicValue();
      jj_consume_token(R_SQBR);
      break;
    default:
      jj_la1[41] = jj_gen;
      ;
    }
    {if (true) return new AttributeNode(fileName, t.beginLine, name, valueDomain, optional, modifiable, defaultValue);}
    throw new Error("Missing return statement in function");
  }

  final public String BasicValue() throws ParseException {
  Token t;
  String result;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case Q_STRING:
      t = jj_consume_token(Q_STRING);
                      {if (true) return t.image;}
      break;
    case MIN:
      t = jj_consume_token(MIN);
                {if (true) return t.image;}
      break;
    case MAX:
      t = jj_consume_token(MAX);
                {if (true) return t.image;}
      break;
    case NUMBER:
      t = jj_consume_token(NUMBER);
                   {if (true) return t.image;}
      break;
    case DECIMAL:
      t = jj_consume_token(DECIMAL);
                    {if (true) return t.image;}
      break;
    case KEYWORD_TRUE:
      t = jj_consume_token(KEYWORD_TRUE);
                         {if (true) return t.image;}
      break;
    case KEYWORD_FALSE:
      t = jj_consume_token(KEYWORD_FALSE);
                          {if (true) return t.image;}
      break;
    case IDENTIFIER:
      t = jj_consume_token(IDENTIFIER);
                       {if (true) return t.image;}
      break;
    case KEYWORD_NULL:
      t = jj_consume_token(KEYWORD_NULL);
                          {if (true) return "null";}
      break;
    case L_PAR:
      result = ListOfBasicValues();
                                 {if (true) return result;}
   {if (true) return null;}
      break;
    default:
      jj_la1[42] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public String ListOfBasicValues() throws ParseException {
  String s = "";
  String result = "";
    jj_consume_token(L_PAR);
    s = BasicValue();
    result = s;
    label_11:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[43] = jj_gen;
        break label_11;
      }
      jj_consume_token(COMMA);
      s = BasicValue();
      result += ", "+s;
    }
    jj_consume_token(R_PAR);
    {if (true) return "(" + result + ")";}
    throw new Error("Missing return statement in function");
  }

  final public RelationNode Relation() throws ParseException {
  Token t;
  String kindA, roleA = "", kindB, roleB = "";
  String relName;
  int type;
  RelationNode relation;
  ArrayList<ConstraintNode > cList;
  IndexNode in;
    jj_consume_token(KEYWORD_RELATION);
    t = jj_consume_token(IDENTIFIER);
    relName = t.image;
    t = jj_consume_token(IDENTIFIER);
    kindA = t.image;
    roleA = t.image.substring(0,1).toLowerCase()+t.image.substring(1);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case COLON:
      jj_consume_token(COLON);
      t = jj_consume_token(CAMELCASE_WORD);
      roleA = t.image;
      break;
    default:
      jj_la1[44] = jj_gen;
      ;
    }
    type = RelationType();
    t = jj_consume_token(IDENTIFIER);
    kindB = t.image;
    roleB = t.image.substring(0,1).toLowerCase()+t.image.substring(1);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case COLON:
      jj_consume_token(COLON);
      t = jj_consume_token(CAMELCASE_WORD);
      roleB = t.image;
      break;
    default:
      jj_la1[45] = jj_gen;
      ;
    }
    relation = new RelationNode(fileName, t.beginLine, relName, kindA, roleA, kindB, roleB, type);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case L_BR:
      jj_consume_token(L_BR);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case KEYWORD_UNIQUE:
      case KEYWORD_COMPARE:
      case KEYWORD_EQUALS:
        // Indexes
                  in = RelationIndex();
                                 relation.addIndex(in);
        break;
      case KEYWORD_CONSTRAINTS:
        // Constraints
                  cList = ConstraintNodeList(relName);
                                                for (ConstraintNode c : cList) relation.addConstraint(c);
        break;
      default:
        jj_la1[46] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      label_12:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[47] = jj_gen;
          break label_12;
        }
        jj_consume_token(COMMA);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case KEYWORD_UNIQUE:
        case KEYWORD_COMPARE:
        case KEYWORD_EQUALS:
          // Indexes
                          in = RelationIndex();
                                       relation.addIndex(in);
          break;
        case KEYWORD_CONSTRAINTS:
          // Constraints
                          cList = ConstraintNodeList(relName);
                                                      for (ConstraintNode c : cList) relation.addConstraint(c);
          break;
        default:
          jj_la1[48] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      jj_consume_token(R_BR);
      break;
    default:
      jj_la1[49] = jj_gen;
      ;
    }
    {if (true) return relation;}
    throw new Error("Missing return statement in function");
  }

  final public int RelationType() throws ParseException {
  Token t;
  String r;
    t = jj_consume_token(RELATION_SYMBOL);
    r = t.image;
    if (r.equals("---")) {if (true) return 0;}
    else if (r.equals(">--")) {if (true) return 1;}
    else if (r.equals(">-<")) {if (true) return 2;}
    throw new Error("Missing return statement in function");
  }

  final public SingletonNode Singleton() throws ParseException {
  Token t;
  SingletonNode singleton;
  String singletonName;
  String valueDomain=null;
  AttributeNode att;
  boolean publish = false;
  ArrayList<ConstraintNode > cList;
    jj_consume_token(KEYWORD_SINGLETON);
    t = jj_consume_token(IDENTIFIER);
                                             singletonName = t.image; valueDomain = singletonName;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case KEYWORD_PUBLISH:
      jj_consume_token(KEYWORD_PUBLISH);
                         publish = true;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case KEYWORD_AS:
        jj_consume_token(KEYWORD_AS);
        t = jj_consume_token(IDENTIFIER);
                                            valueDomain = t.image;
        break;
      default:
        jj_la1[50] = jj_gen;
        ;
      }
      break;
    default:
      jj_la1[51] = jj_gen;
      ;
    }
    singleton = new SingletonNode(fileName, t.beginLine, singletonName, (publish?valueDomain:null));
    jj_consume_token(L_BR);
    att = Attribute();
                         singleton.addAttribute(att);
    label_13:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[52] = jj_gen;
        break label_13;
      }
      jj_consume_token(COMMA);
      att = Attribute();
                                  singleton.addAttribute(att);
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case KEYWORD_CONSTRAINTS:
      cList = ConstraintNodeList(singletonName);
                for (ConstraintNode c : cList)
                {
                        singleton.addConstraint(c);
                }
      break;
    default:
      jj_la1[53] = jj_gen;
      ;
    }
    jj_consume_token(R_BR);
    {if (true) return singleton;}
    throw new Error("Missing return statement in function");
  }

  final public ActionViewNode ActionViewOld() throws ParseException {
  Token t;
  ActionViewNode.Type type;
  String name;
  ArrayList<NameAndTypeNode > inputs = null, outputs = null;
  String description="";
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case Q_STRING:
      t = jj_consume_token(Q_STRING);
      description = t.image;
      break;
    default:
      jj_la1[54] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case KEYWORD_ACTION:
      jj_consume_token(KEYWORD_ACTION);
      type = ActionViewNode.Type.Action;
      break;
    case KEYWORD_VIEW:
      jj_consume_token(KEYWORD_VIEW);
      type = ActionViewNode.Type.View;
      break;
    default:
      jj_la1[55] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    t = jj_consume_token(CAMELCASE_WORD);
    name = t.image;
    jj_consume_token(L_PAR);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CAMELCASE_WORD:
      inputs = NameAndTypeList();
      break;
    default:
      jj_la1[56] = jj_gen;
      ;
    }
    jj_consume_token(R_PAR);
    jj_consume_token(ARROW);
    jj_consume_token(L_PAR);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CAMELCASE_WORD:
      outputs = NameAndTypeList();
      break;
    default:
      jj_la1[57] = jj_gen;
      ;
    }
    jj_consume_token(R_PAR);
    {if (true) return new ActionViewNode(fileName, t.beginLine, name, inputs, outputs, description, type, null);}
    throw new Error("Missing return statement in function");
  }

  final public ActionViewNode ActionView() throws ParseException {
  Token t;
  ActionViewNode.Type type;
  String name;
  ArrayList<NameAndTypeNode > inputs = null, outputs = null;
  ArrayList<ErrorCode > errorCodes = null;
  String description="";
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case KEYWORD_ACTION:
      jj_consume_token(KEYWORD_ACTION);
                         type = ActionViewNode.Type.Action;
      break;
    case KEYWORD_VIEW:
      jj_consume_token(KEYWORD_VIEW);
                       type = ActionViewNode.Type.View;
      break;
    default:
      jj_la1[58] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    t = jj_consume_token(CAMELCASE_WORD);
                           name = t.image;
    jj_consume_token(L_BR);
    label_14:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case KEYWORD_INPUT:
      case KEYWORD_OUTPUT:
      case KEYWORD_ERRORCODES:
      case KEYWORD_DESCRIPTION:
        ;
        break;
      default:
        jj_la1[59] = jj_gen;
        break label_14;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case KEYWORD_INPUT:
        jj_consume_token(KEYWORD_INPUT);
        jj_consume_token(COLON);
        inputs = NameAndTypeList();
        break;
      case KEYWORD_OUTPUT:
        jj_consume_token(KEYWORD_OUTPUT);
        jj_consume_token(COLON);
        outputs = NameAndTypeList();
        break;
      case KEYWORD_ERRORCODES:
        jj_consume_token(KEYWORD_ERRORCODES);
        jj_consume_token(COLON);
        errorCodes = ErrorCodeList();
        break;
      case KEYWORD_DESCRIPTION:
        jj_consume_token(KEYWORD_DESCRIPTION);
        jj_consume_token(COLON);
        t = jj_consume_token(Q_STRING);
                                                         description = t.image.substring(1, t.image.length()-1);
        break;
      default:
        jj_la1[60] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    jj_consume_token(R_BR);
    {if (true) return new ActionViewNode(fileName, t.beginLine, name, inputs, outputs, description, type, errorCodes);}
    throw new Error("Missing return statement in function");
  }

  final public ArrayList<ErrorCode > ErrorCodeList() throws ParseException {
  ArrayList<ErrorCode > errorCodes = new ArrayList<ErrorCode >();
  ErrorCode c = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NUMBER:
    case DIGITS:
      c = ErrorCode();
                      errorCodes.add(c);
      label_15:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[61] = jj_gen;
          break label_15;
        }
        jj_consume_token(COMMA);
        c = ErrorCode();
                           errorCodes.add(c);
      }
      break;
    default:
      jj_la1[62] = jj_gen;
      ;
    }
    {if (true) return errorCodes;}
    throw new Error("Missing return statement in function");
  }

  final public ErrorCode ErrorCode() throws ParseException {
  Token t;
  int i;
  String s;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DIGITS:
      t = jj_consume_token(DIGITS);
      break;
    case NUMBER:
      t = jj_consume_token(NUMBER);
      break;
    default:
      jj_la1[63] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    i = Integer.parseInt(t.image);
    jj_consume_token(MINUS);
    t = jj_consume_token(Q_STRING);
                                                              s = t.image.substring(1, t.image.length()-1);
    {if (true) return new ErrorCode(fileName, t.beginLine, i, s);}
    throw new Error("Missing return statement in function");
  }

  final public ArrayList<NameAndTypeNode > NameAndTypeList() throws ParseException {
  ArrayList<NameAndTypeNode > list = new ArrayList<NameAndTypeNode >();
  NameAndTypeNode node;
    node = NameAndType();
    list.add(node);
    label_16:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[64] = jj_gen;
        break label_16;
      }
      jj_consume_token(COMMA);
      node = NameAndType();
      list.add(node);
    }
    {if (true) return list;}
    throw new Error("Missing return statement in function");
  }

  final public NameAndTypeNode NameAndType() throws ParseException {
  Token t;
  String name, type;
  boolean canBeNull = false;
    t = jj_consume_token(CAMELCASE_WORD);
    name = t.image;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case QUESTION_MARK:
      jj_consume_token(QUESTION_MARK);
                     canBeNull = true;
      break;
    default:
      jj_la1[65] = jj_gen;
      ;
    }
    jj_consume_token(COLON);
    t = jj_consume_token(IDENTIFIER);
    type = t.image;
    {if (true) return new NameAndTypeNode(fileName, t.beginLine, name, type, canBeNull);}
    throw new Error("Missing return statement in function");
  }

  final public InterfaceNode Interface() throws ParseException {
  Token t;
  InterfaceNode iNode;
  String name;
  ArrayList<String > methods = new ArrayList<String >();
    jj_consume_token(KEYWORD_INTERFACE);
    t = jj_consume_token(CAMELCASE_WORD);
    name = t.image;
    jj_consume_token(L_BR);
    t = jj_consume_token(CAMELCASE_WORD);
                          methods.add(t.image);
    label_17:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[66] = jj_gen;
        break label_17;
      }
      jj_consume_token(COMMA);
      t = jj_consume_token(CAMELCASE_WORD);
                               methods.add(t.image);
    }
    jj_consume_token(R_BR);
    iNode = new InterfaceNode(fileName, t.beginLine, name);
    for (String m : methods)
        iNode.addActionViewNodeName(m);
    {if (true) return iNode;}
    throw new Error("Missing return statement in function");
  }

  /** Generated Token Manager. */
  public DataModelParserTokenManager token_source;
  SimpleCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private int jj_gen;
  final private int[] jj_la1 = new int[67];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static private int[] jj_la1_2;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
      jj_la1_init_2();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x8000,0x10000,0x80000000,0x0,0x0,0x0,0x0,0x0,0x600,0x1600,0x2600,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xe1a8000,0xe1a8000,0x0,0xe00000,0x0,0x0,0xe00000,0x0,0x0,0x0,0x40000,0x0,0x0,0xe00000,0x0,0xe00000,0xe00000,0x0,0x0,0x0,0x0,0x10000000,0x60007600,0x0,0x0,0x0,0xe00000,0x0,0xe00000,0x0,0x0,0x0,0x0,0x0,0x0,0xa000000,0x0,0x0,0xa000000,0x0,0x0,0x0,0xc00,0xc00,0x0,0x0,0x0,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0x0,0x0,0x7e00f,0x10,0x40000000,0x0,0x40000000,0x8000000,0x0,0x0,0x0,0x10000000,0x0,0x40000000,0x0,0x100000,0x8000000,0x78000,0x7e000,0x40000000,0x0,0x0,0x10,0x0,0x40100000,0x40000000,0x0,0x20000000,0x40100000,0x40000000,0x0,0x40,0x20,0x100010,0x40000000,0x100010,0x100010,0x0,0x0,0x0,0x0,0x0,0xa00000,0x40000000,0x20000000,0x20000000,0x10,0x40000000,0x10,0x2000000,0x40,0x20,0x40000000,0x10,0x0,0x0,0x100000,0x100000,0x0,0x1e00,0x1e00,0x40000000,0x0,0x0,0x40000000,0x0,0x40000000,};
   }
   private static void jj_la1_init_2() {
      jj_la1_2 = new int[] {0x0,0x0,0x0,0x0,0x0,0x20,0x0,0x0,0x0,0x0,0x0,0x80,0x1,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2,0x1,0x3,0x3,0x0,0x20,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,};
   }

  /** Constructor with InputStream. */
  public DataModelParser(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public DataModelParser(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new DataModelParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 67; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 67; i++) jj_la1[i] = -1;
  }

  /** Constructor. */
  public DataModelParser(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new DataModelParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 67; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 67; i++) jj_la1[i] = -1;
  }

  /** Constructor with generated Token Manager. */
  public DataModelParser(DataModelParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 67; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(DataModelParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 67; i++) jj_la1[i] = -1;
  }

  private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }


/** Get the next Token. */
  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;

  /** Generate ParseException. */
  public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[72];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 67; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
          if ((jj_la1_2[i] & (1<<j)) != 0) {
            la1tokens[64+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 72; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  final public void enable_tracing() {
  }

  /** Disable tracing. */
  final public void disable_tracing() {
  }

}
