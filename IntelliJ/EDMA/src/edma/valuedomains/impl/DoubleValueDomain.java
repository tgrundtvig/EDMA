package edma.valuedomains.impl;

import java.io.DataInput;
import java.io.DataOutput;
import java.io.IOException;

import edma.valuedomains.IDoubleValueDomain;
import edma.valuedomains.IExternalConstraints;
import edma.valuedomains.exceptions.InvalidValueException;
import edma.valuedomains.impl.parser.ValueToken;
import edma.valuedomains.impl.parser.ValueToken.TokenType;
import edma.valuedomains.impl.parser.ValueTokenizer;

public class DoubleValueDomain extends AMetaValueDomain implements
		IDoubleValueDomain
{
	private final Double minValue, maxValue;

	public DoubleValueDomain(	String name,
								String scope,
								int index,
								Double minValue,
								Double maxValue,
								Constraint[] constraints,
								boolean autoGenerated)
	{
		super(name, scope, index, constraints, autoGenerated);
		this.minValue = minValue;
		this.maxValue = maxValue;
	}

	@Override
	public EMetaType getEMetaType()
	{
		return EMetaType.Double;
	}

	@Override
	public Double getMin()
	{
		return minValue;
	}

	@Override
	public Double getMax()
	{
		return maxValue;
	}

	@Override
	public IDoubleValueDomain asDouble()
	{
		return this;
	}

	@Override
	public boolean contains(Object o)
	{
		if(!(o instanceof Double)) return false;
		Double d = (Double) o;
		if(minValue != null && d < minValue) return false;
		if(maxValue != null && d > maxValue) return false;
		return true;
	}

	@Override
	protected boolean needNativeValidate()
	{
		return (minValue != null || maxValue != null);
	}

	@Override
	public void nativeValidate(Object o) throws InvalidValueException
	{
		Double d = (Double) o;
		if(minValue != null && d < minValue) throw new InvalidValueException(	this,
																				new Constraint(	"Double_minValue",
																								"Check min value"),
																				"The value "
																						+ d
																						+ " is smaller than the required minimum value "
																						+ minValue
																						+ " in the Double value domain "
																						+ getName());
		if(maxValue != null && d > maxValue) throw new InvalidValueException(	this,
																				new Constraint(	"Double_maxValue",
																								"Check max value"),
																				"The value "
																						+ d
																						+ " is larger than the required maximum value "
																						+ maxValue
																						+ " in the Double value domain "
																						+ getName());
	}

	@Override
	public void notNullValueToString(Object o, StringBuilder res)
	{
		if(o == null) res.append("null");
		else res.append((Double) o);
	}

	@Override
	protected Object valueFromTokenizer(ValueTokenizer tokenizer,
										IExternalConstraints external) throws InvalidValueException
	{
		ValueToken token = tokenizer.getNextToken();
		if(token.getType() != TokenType.Value) throw new InvalidValueException(	this,
																				parseConstraint,
																				"Error parsing Double");
		if("null".equals(token.getValue())) return null;
		Object res = null;
		try
		{
			res = Double.parseDouble(token.getValue());
		}
		catch(Exception e)
		{
			throw new InvalidValueException(this,
											parseConstraint,
											"Error parsing Double");
		}
		validate(res, external);
		return res;
	}

	@Override
	public boolean notNullValueEqual(Object o1, Object o2)
	{
		return o1.equals(o2);
	}

	@Override
	public int notNullValueCompare(Object o1, Object o2)
	{
		return ((Double) o1).compareTo((Double) o2);
	}

	@Override
	public int notNullValueHashCode(Object o)
	{
		return o.hashCode();
	}

	@Override
	public String getBasicType()
	{
		return "Double";
	}

	@Override
	public void writeValue(Object value, DataOutput out) throws IOException
	{
		out.writeDouble((Double) value);
	}

	@Override
	protected Object doReadValue(DataInput in, IExternalConstraints external)	throws IOException,
																				InvalidValueException
	{
		Double res = in.readDouble();
		validate(res, external);
		return res;
	}
}
