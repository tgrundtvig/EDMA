package edma.valuedomains.impl;

import java.io.DataInput;
import java.io.IOException;
import java.util.Set;

import edma.util.Pair;
import edma.valuedomains.IBooleanValueDomain;
import edma.valuedomains.IDoubleValueDomain;
import edma.valuedomains.IEnumValueDomain;
import edma.valuedomains.IExternalConstraints;
import edma.valuedomains.IFloatValueDomain;
import edma.valuedomains.IIntegerValueDomain;
import edma.valuedomains.IListValueDomain;
import edma.valuedomains.ILongValueDomain;
import edma.valuedomains.IMapValueDomain;
import edma.valuedomains.IMetaValueDomain;
import edma.valuedomains.IOneOfValueDomain;
import edma.valuedomains.IStringValueDomain;
import edma.valuedomains.IStructValueDomain;
import edma.valuedomains.IValueDomainBuilder;
import edma.valuedomains.exceptions.InvalidValueException;
import edma.valuedomains.impl.parser.ValueTokenizer;

public abstract class AMetaValueDomain implements IMetaValueDomain
{
	//private final CachedValues values;
	private final String name;
	private final String scope;
	private final int index;
	private final boolean isAutoGenerated;
	private final Constraint[] constraints;
	protected final Constraint parseConstraint;

	protected AMetaValueDomain(	String name,
								String scope,
								int index,
								Constraint[] constraints,
								boolean autoGenerated)
	{
		this.name = name;
		this.scope = scope;
		this.index = index;
		this.constraints = constraints;
		this.parseConstraint = new Constraint(	"ParseError",
												"Error parsing string");
		this.isAutoGenerated = autoGenerated;
		//this.values = new CachedValues(this);
	}

	@Override
	public Object newValue(Object value)
	{
		//return values.get(value);
		return value;
	}

	@Override
	public String getName()
	{
		return name;
	}

	@Override
	public String getScope()
	{
		return scope;
	}

	@Override
	public int getIndex()
	{
		return index;
	}

	@Override
	public boolean isAutoGenerated()
	{
		return isAutoGenerated;
	}

	@Override
	public Constraint[] getConstraints()
	{
		return constraints;
	}

	public void validate(Object o, IExternalConstraints external) throws InvalidValueException
	{
		if(external == null) return;
		nativeValidate(o);
		if(constraints == null) return;
		Pair<Integer, String> violated = external.checkConstraints(o, index);
		if(violated == null) return;
		throw new InvalidValueException(this,
										constraints[violated.getFirst()],
										violated.getLast());
	}

	@Override
	public String valueToString(Object o)
	{
		StringBuilder res = new StringBuilder();
		valueToString(o, res);
		return res.toString();
	}

	protected void valueToString(Object o, StringBuilder res)
	{
		if(o == null) res.append("null");
		else notNullValueToString(o, res);
	}

	@Override
	public Object valueFromString(String s, IExternalConstraints external) throws InvalidValueException
	{
		Object res = valueFromTokenizer(new ValueTokenizer(s), external);
		return newValue(res);
	}

	@Override
	public boolean valueEqual(Object o1, Object o2)
	{
		if(o1 == o2) return true;
		if(o1 == null || o2 == null) return false;
		return notNullValueEqual(o1, o2);
	}

	@Override
	public int valueCompare(Object o1, Object o2)
	{
		if(o1 == null)
		{
			if(o2 == null) return 0;
			return -1;
		}
		if(o2 == null){ return 1; }
		return notNullValueCompare(o1, o2);
	}

	@Override
	public int valueHashCode(Object o)
	{
		if(o == null) return 0;
		return notNullValueHashCode(o);
	}

	@Override
	public boolean needValidate()
	{
		if(constraints != null && constraints.length > 0) return true;
		return needNativeValidate();
	}

	public void replaceDummies(IValueDomainBuilder vdb)
	{}

	public boolean isPossible(Set<String> parents)
	{
		return true;
	}

	protected abstract int notNullValueHashCode(Object o);

	protected abstract int notNullValueCompare(Object o1, Object o2);

	protected abstract boolean notNullValueEqual(Object o1, Object o2);

	protected abstract void notNullValueToString(Object o, StringBuilder res);

	protected abstract Object valueFromTokenizer(	ValueTokenizer tokenizer,
													IExternalConstraints external) throws InvalidValueException;

	protected abstract boolean needNativeValidate();

	protected abstract void nativeValidate(Object o) throws InvalidValueException;

	protected abstract Object doReadValue(	DataInput in,
											IExternalConstraints external)	throws IOException,
																			InvalidValueException;

	@Override
	public IStringValueDomain asString()
	{
		throw new UnsupportedOperationException();
	}

	@Override
	public IIntegerValueDomain asInteger()
	{
		throw new UnsupportedOperationException();
	}

	@Override
	public ILongValueDomain asLong()
	{
		throw new UnsupportedOperationException();
	}

	@Override
	public IFloatValueDomain asFloat()
	{
		throw new UnsupportedOperationException();
	}

	@Override
	public IDoubleValueDomain asDouble()
	{
		throw new UnsupportedOperationException();
	}

	@Override
	public IBooleanValueDomain asBoolean()
	{
		throw new UnsupportedOperationException();
	}

	@Override
	public IEnumValueDomain asEnum()
	{
		throw new UnsupportedOperationException();
	}

	@Override
	public IStructValueDomain asStruct()
	{
		throw new UnsupportedOperationException();
	}

	@Override
	public IListValueDomain asList()
	{
		throw new UnsupportedOperationException();
	}

	@Override
	public IMapValueDomain asMap()
	{
		throw new UnsupportedOperationException();
	}

	@Override
	public IOneOfValueDomain asOneOf()
	{
		throw new UnsupportedOperationException();
	}

	@Override
	public Object readValueNoValidate(DataInput in) throws IOException
	{
		try
		{
			return readValue(in, null);
		}
		catch(InvalidValueException e)
		{
			throw new RuntimeException("Should never happen!");
		}
	}

	@Override
	public Object readValue(DataInput in, IExternalConstraints external) throws IOException,
																		InvalidValueException
	{
		Object res = doReadValue(in, external);
		return newValue(res);
	}
}
