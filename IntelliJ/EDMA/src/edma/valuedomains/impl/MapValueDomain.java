package edma.valuedomains.impl;

import java.io.DataInput;
import java.io.DataOutput;
import java.io.IOException;
import java.util.ArrayList;

import edma.valuedomains.IExternalConstraints;
import edma.valuedomains.IMapValueDomain;
import edma.valuedomains.IMetaValueDomain;
import edma.valuedomains.IValueDomainBuilder;
import edma.valuedomains.exceptions.InvalidValueException;
import edma.valuedomains.impl.parser.ValueToken;
import edma.valuedomains.impl.parser.ValueToken.TokenType;
import edma.valuedomains.impl.parser.ValueTokenizer;

public class MapValueDomain extends AMetaValueDomain implements IMapValueDomain
{
	private AMetaValueDomain keyDomain;
	private AMetaValueDomain valueDomain;

	public MapValueDomain(	String name,
								String scope,
								int index,
								String keyDomainName,
								String valueDomainName,
								Constraint[] constraints,
								boolean autoGenerated)
	{
		super(name, scope, index, constraints, autoGenerated);
		this.keyDomain = new DummyValueDomain(keyDomainName);
		this.valueDomain = new DummyValueDomain(valueDomainName);
	}

	@Override
	public void replaceDummies(IValueDomainBuilder vdb)
	{
		AMetaValueDomain keyVD = vdb.get(keyDomain.getName(), getScope());
		AMetaValueDomain valueVD = vdb.get(	valueDomain.getName(),
											getScope());
		if(keyVD == null) throw new RuntimeException("The value domain "
				+ keyDomain.getName()
				+ " could not be found. Used in value domain " + getName());
		if(valueVD == null) throw new RuntimeException("The value domain "
				+ valueDomain.getName()
				+ " could not be found. Used in value domain " + getName());
		keyDomain = keyVD;
		valueDomain = valueVD;
	}

	@Override
	public IMapValueDomain asMap()
	{
		return this;
	}

	@Override
	public EMetaType getEMetaType()
	{
		return EMetaType.Map;
	}

	@Override
	public String getBasicType()
	{
		return null;
	}

	@Override
	public boolean contains(Object o)
	{
		if(!(o instanceof Object[])) return false;
		Object[] array = (Object[]) o;
		for(Object obj : array)
		{
			if(!(obj instanceof Object[])) return false;
			Object[] entry = (Object[]) obj;
			if(entry.length != 2) return false;
			if(!keyDomain.contains(entry[0])) return false;
			if(!valueDomain.contains(entry[1])) return false;
		}
		return true;
	}

	@Override
	protected boolean needNativeValidate()
	{
		return false;
	}

	@Override
	public void nativeValidate(Object o) throws InvalidValueException
	{
		// We do nothing here, since there is no native constraints on a map
		// value
	}

	@Override
	public boolean notNullValueEqual(Object o1, Object o2)
	{
		Object[] a1 = (Object[]) o1;
		Object[] a2 = (Object[]) o2;
		if(a1.length != a2.length) return false;
		for(int i = 0; i < a1.length; ++i)
		{
			Object[] entry1 = (Object[]) a1[i];
			Object[] entry2 = (Object[]) a2[i];
			if(!keyDomain.valueEqual(entry1[0], entry2[0])) return false;
			if(!valueDomain.valueEqual(entry1[1], entry2[1])) return false;
		}
		return true;
	}

	@Override
	public int notNullValueCompare(Object o1, Object o2)
	{
		Object[] a1 = (Object[]) o1;
		Object[] a2 = (Object[]) o2;
		int minLength = Math.min(a1.length, a2.length);
		for(int i = 0; i < minLength; ++i)
		{
			Object[] entry1 = (Object[]) a1;
			Object[] entry2 = (Object[]) a2;
			int c = keyDomain.valueCompare(entry1[0], entry2[0]);
			if(c != 0) return c;
			c = valueDomain.valueCompare(entry1[1], entry2[1]);
			if(c != 0) return c;
		}
		return a2.length - a1.length;
	}

	@Override
	public int notNullValueHashCode(Object o)
	{
		Object[] a = (Object[]) o;
		int res = 17;
		for(int i = 0; i < a.length; ++i)
		{
			Object[] entry = (Object[]) a[i];
			res = 31 * res + keyDomain.valueHashCode(entry[0]);
			res = 31 * res + valueDomain.valueHashCode(entry[1]);
		}
		return res;
	}

	@Override
	public IMetaValueDomain getKeyDomain()
	{
		return keyDomain;
	}

	@Override
	public IMetaValueDomain getValueDomain()
	{
		return valueDomain;
	}

	@Override
	protected void notNullValueToString(Object o, StringBuilder res)
	{
		Object[] array = (Object[]) o;
		res.append(ValueTokenizer.BEGIN);
		boolean first = true;
		for(Object obj : array)
		{
			if(first) first = false;
			else res.append(ValueTokenizer.SEPERATOR + " ");
			Object[] entry = (Object[]) obj;
			res.append(ValueTokenizer.BEGIN);
			keyDomain.notNullValueToString(entry[0], res);
			res.append(ValueTokenizer.SEPERATOR + " ");
			valueDomain.notNullValueToString(entry[1], res);
			res.append(ValueTokenizer.END);
		}
		res.append(ValueTokenizer.END);
	}

	@Override
	protected Object valueFromTokenizer(ValueTokenizer tokenizer,
										IExternalConstraints external) throws InvalidValueException
	{
		ValueToken token = tokenizer.getNextToken();
		if(token.getType() == TokenType.Value
				&& "null".equals(token.getValue())) return null;
		if(token.getType() != TokenType.Begin) throw new InvalidValueException(this, parseConstraint, "Error parsing Map");
		ArrayList<Object> array = new ArrayList<Object>();
		boolean first = true;
		while(true)
		{
			token = tokenizer.getNextToken();
			if(token.getType() == TokenType.End)
			{
				Object[] res = array.toArray();
				validate(res, external);
				return res;
			}
			else
			{
				if(first) first = false;
				else
				{
					if(!(token.getType() == TokenType.Seperator)) throw new InvalidValueException(this, parseConstraint, "Error parsing Map");
					token = tokenizer.getNextToken();
				}
				if(token.getType() == TokenType.Begin)
				{
					Object[] entry = new Object[2];
					entry[0] = keyDomain.valueFromTokenizer(tokenizer, external);
					token = tokenizer.getNextToken();
					if(!(token.getType() == TokenType.Seperator)) throw new InvalidValueException(this, parseConstraint, "Error parsing Map");
					entry[1] = valueDomain.valueFromTokenizer(tokenizer, external);
					token = tokenizer.getNextToken();
					if(!(token.getType() == TokenType.End)) throw new InvalidValueException(this, parseConstraint, "Error parsing Map");
					array.add(entry);
				}
				else
				{
					throw new InvalidValueException(this, parseConstraint, "Error parsing Map");
				}
			}
		}
	}

	@Override
	public void writeValue(Object value, DataOutput out) throws IOException
	{
		Object[] map = (Object[]) value;
		out.writeInt(map.length);
		for(Object obj : map)
		{
			Object[] entry = (Object[]) obj;
			keyDomain.writeValue(entry[0], out);
			valueDomain.writeValue(entry[1], out);
		}
	}

	@Override
	protected Object doReadValue(DataInput in, IExternalConstraints external) throws IOException,
																		InvalidValueException
	{
		int size = in.readInt();
		Object[] res = new Object[size];
		for(int i = 0; i < size; ++i)
		{
			Object[] entry = new Object[2];
			entry[0] = keyDomain.readValue(in, external);
			entry[1] = valueDomain.readValue(in, external);
			res[i] = entry;
		}
		validate(res, external);
		return res;
	}
}
