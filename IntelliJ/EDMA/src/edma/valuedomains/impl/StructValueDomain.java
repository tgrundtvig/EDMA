package edma.valuedomains.impl;

import java.io.DataInput;
import java.io.DataOutput;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Set;

import edma.valuedomains.IExternalConstraints;
import edma.valuedomains.IStructField;
import edma.valuedomains.IStructValueDomain;
import edma.valuedomains.IValueDomainBuilder;
import edma.valuedomains.exceptions.InvalidValueException;
import edma.valuedomains.impl.parser.ValueToken;
import edma.valuedomains.impl.parser.ValueToken.TokenType;
import edma.valuedomains.impl.parser.ValueTokenizer;

public class StructValueDomain extends AMetaValueDomain implements
		IStructValueDomain
{
	private final ArrayList<StructValueDomainField> fields;

	public StructValueDomain(String name,
								String scope,
								int index,
								Constraint[] constraints,
								boolean autoGenerated)
	{
		super(name, scope, index, constraints, autoGenerated);
		fields = new ArrayList<StructValueDomainField>();
	}

	@Override
	public void replaceDummies(IValueDomainBuilder vdb)
	{
		for(StructValueDomainField field : fields)
		{
			field.replaceDummies(vdb, getScope(), getName());
		}
	}

	@Override
	public boolean isPossible(Set<String> parents)
	{
		if(parents.contains(getName())) return false;
		parents.add(getName());
		for(StructValueDomainField f : fields)
		{
			if(!f.canBeNull())
			{
				if(!f.getValueDomain().isPossible(parents))
				{
					parents.remove(getName());
					return false;
				}
			}
		}
		parents.remove(getName());
		return true;
	}

	public void addField(StructValueDomainField field)
	{
		for(StructValueDomainField f : fields)
		{
			if(field.getName().equals(f.getName())) throw new RuntimeException("The struct already has a field named "
					+ field.getName());
		}
		fields.add(field);
	}

	public void trim()
	{
		fields.trimToSize();
	}

	@Override
	public EMetaType getEMetaType()
	{
		return EMetaType.Struct;
	}

	@Override
	public IStructValueDomain asStruct()
	{
		return this;
	}

	@Override
	public int getNumberOfFields()
	{
		return fields.size();
	}

	@Override
	public IStructField getField(int i)
	{
		return fields.get(i);
	}

	@Override
	public boolean contains(Object o)
	{
		if(!(o instanceof Object[])) return false;
		Object[] array = (Object[]) o;
		if(array.length != fields.size()) return false;
		int i = 0;
		for(IStructField field : fields)
		{
			Object obj = array[i++];
			if(obj == null)
			{
				if(!field.canBeNull()) return false;
			}
			else
			{
				if(!field.getValueDomain().contains(obj)) return false;
			}
		}
		return true;
	}

	@Override
	protected boolean needNativeValidate()
	{
		return false;
	}

	@Override
	public void nativeValidate(Object o) throws InvalidValueException
	{
		// We do nothing here, since there is no natural invariants on a Struct
		// value
	}

	@Override
	public void notNullValueToString(Object o, StringBuilder res)
	{
		Object[] array = (Object[]) o;
		res.append(ValueTokenizer.BEGIN);
		int i = 0;
		for(IStructField field : fields)
		{
			if(i > 0) res.append(ValueTokenizer.SEPERATOR + " ");
			((AMetaValueDomain) field.getValueDomain()).valueToString(	array[i++],
																		res);
		}
		res.append(ValueTokenizer.END);
	}

	@Override
	public Object valueFromTokenizer(	ValueTokenizer tokenizer,
										IExternalConstraints external) throws InvalidValueException
	{
		ValueToken token = tokenizer.getNextToken();
		if(token.getType() == TokenType.Value
				&& "null".equals(token.getValue())) return null;
		if(token.getType() != TokenType.Begin) throw new InvalidValueException(	this,
																				parseConstraint,
																				"Error parsing Struct");
		Object[] res = new Object[fields.size()];
		int i = 0;
		for(IStructField field : fields)
		{
			if(i > 0)
			{
				token = tokenizer.getNextToken();
				if(token.getType() != TokenType.Seperator) throw new InvalidValueException(	this,
																							parseConstraint,
																							"Error parsing Struct");
			}
			Object obj = ((AMetaValueDomain) field.getValueDomain()).valueFromTokenizer(tokenizer,
																						external);
			if(obj == null && !field.canBeNull()) throw new RuntimeException(field.getName()
					+ " may not be null!");
			res[i++] = obj;
		}
		token = tokenizer.getNextToken();
		if(token.getType() != TokenType.End) throw new InvalidValueException(	this,
																				parseConstraint,
																				"Error parsing Struct");
		validate(res, external);
		return res;
	}

	@Override
	public boolean notNullValueEqual(Object o1, Object o2)
	{
		Object[] a1 = (Object[]) o1;
		Object[] a2 = (Object[]) o2;
		for(int i = 0; i < fields.size(); ++i)
		{
			if(!fields.get(i).getValueDomain().valueEqual(a1[i], a2[i])) return false;
		}
		return true;
	}

	@Override
	public int notNullValueCompare(Object o1, Object o2)
	{
		Object[] a1 = (Object[]) o1;
		Object[] a2 = (Object[]) o2;
		for(int i = 0; i < fields.size(); ++i)
		{
			int c = fields.get(i).getValueDomain().valueCompare(a1[i], a2[i]);
			if(c != 0) return c;
		}
		return 0;
	}

	@Override
	public int notNullValueHashCode(Object o)
	{
		Object[] a = (Object[]) o;
		int res = 17;
		for(int i = 0; i < fields.size(); ++i)
		{
			res = 31 * res + fields.get(i).getValueDomain().valueHashCode(a[i]);
		}
		return res;
	}

	@Override
	public String getBasicType()
	{
		return null;
	}

	@Override
	public void writeValue(Object value, DataOutput out) throws IOException
	{
		Object[] struct = (Object[]) value;
		for(int i = 0; i < struct.length; ++i)
		{
			StructValueDomainField field = fields.get(i);
			if(field.canBeNull())
			{
				if(struct[i] == null)
				{
					out.writeBoolean(false);
				}
				else
				{
					out.writeBoolean(true);
					field.getValueDomain().writeValue(struct[i], out);
				}
			}
			else
			{
				field.getValueDomain().writeValue(struct[i], out);
			}
		}

	}

	@Override
	protected Object doReadValue(DataInput in, IExternalConstraints external)	throws IOException,
																				InvalidValueException
	{
		Object[] res = new Object[fields.size()];
		for(int i = 0; i < res.length; ++i)
		{
			StructValueDomainField field = fields.get(i);
			if(field.canBeNull())
			{
				if(in.readBoolean())
				{
					res[i] = field.getValueDomain().readValue(in, external);
				}
			}
			else
			{
				res[i] = field.getValueDomain().readValue(in, external);
			}
		}
		validate(res, external);
		return res;
	}
}
