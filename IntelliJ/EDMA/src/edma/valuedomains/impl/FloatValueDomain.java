package edma.valuedomains.impl;

import java.io.DataInput;
import java.io.DataOutput;
import java.io.IOException;

import edma.valuedomains.IExternalConstraints;
import edma.valuedomains.IFloatValueDomain;
import edma.valuedomains.exceptions.InvalidValueException;
import edma.valuedomains.impl.parser.ValueToken;
import edma.valuedomains.impl.parser.ValueToken.TokenType;
import edma.valuedomains.impl.parser.ValueTokenizer;

public class FloatValueDomain extends AMetaValueDomain implements
		IFloatValueDomain
{
	private final Float minValue, maxValue;

	public FloatValueDomain(String name,
							String scope,
							int index,
							Float minValue,
							Float maxValue,
							Constraint[] constraints,
							boolean autoGenerated)
	{
		super(name, scope, index, constraints, autoGenerated);
		this.minValue = minValue;
		this.maxValue = maxValue;
	}

	@Override
	public Float getMin()
	{
		return minValue;
	}

	@Override
	public Float getMax()
	{
		return maxValue;
	}

	@Override
	public EMetaType getEMetaType()
	{
		return EMetaType.Float;
	}

	@Override
	public IFloatValueDomain asFloat()
	{
		return this;
	}

	@Override
	public boolean contains(Object o)
	{
		if(!(o instanceof Float)) return false;
		Float f = (Float) o;
		if(minValue != null && f < minValue) return false;
		if(maxValue != null && f > maxValue) return false;
		return true;
	}

	@Override
	protected boolean needNativeValidate()
	{
		return (minValue != null || maxValue != null);
	}

	@Override
	public void nativeValidate(Object o) throws InvalidValueException
	{
		Float f = (Float) o;
		if(minValue != null && f < minValue) throw new InvalidValueException(	this,
																				new Constraint(	"Float_minValue",
																								"Check min value"),
																				"The value "
																						+ f
																						+ " is smaller than the required minimum value "
																						+ minValue
																						+ " in the Float value domain "
																						+ getName());
		if(maxValue != null && f > maxValue) throw new InvalidValueException(	this,
																				new Constraint(	"Float_maxValue",
																								"Check max value"),
																				"The value "
																						+ f
																						+ " is larger than the required maximum value "
																						+ maxValue
																						+ " in the Float value domain "
																						+ getName());
	}

	@Override
	public void notNullValueToString(Object o, StringBuilder res)
	{
		if(o == null) res.append("null");
		else res.append((Float) o);
	}

	@Override
	protected Object valueFromTokenizer(ValueTokenizer tokenizer,
										IExternalConstraints external) throws InvalidValueException
	{
		ValueToken token = tokenizer.getNextToken();
		if(token.getType() != TokenType.Value) throw new InvalidValueException(	this,
																				parseConstraint,
																				"Error parsing Float");
		if("null".equals(token.getValue())) return null;
		Object res = null;
		try
		{
			res = Float.parseFloat(token.getValue());
		}
		catch(Exception e)
		{
			throw new InvalidValueException(this,
											parseConstraint,
											"Error parsing Float");
		}
		validate(res, external);
		return res;
	}

	@Override
	public boolean notNullValueEqual(Object o1, Object o2)
	{
		return o1.equals(o2);
	}

	@Override
	public int notNullValueCompare(Object o1, Object o2)
	{
		return ((Float) o1).compareTo((Float) o2);
	}

	@Override
	public int notNullValueHashCode(Object o)
	{
		return o.hashCode();
	}

	@Override
	public String getBasicType()
	{
		return "Float";
	}

	@Override
	public void writeValue(Object value, DataOutput out) throws IOException
	{
		out.writeFloat((Float) value);

	}

	@Override
	protected Object doReadValue(DataInput in, IExternalConstraints external)	throws IOException,
																				InvalidValueException
	{
		Float res = in.readFloat();
		validate(res, external);
		return res;
	}
}
