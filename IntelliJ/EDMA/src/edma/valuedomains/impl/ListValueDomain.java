package edma.valuedomains.impl;

import java.io.DataInput;
import java.io.DataOutput;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Set;

import edma.valuedomains.IExternalConstraints;
import edma.valuedomains.IListValueDomain;
import edma.valuedomains.IMetaValueDomain;
import edma.valuedomains.IValueDomainBuilder;
import edma.valuedomains.exceptions.InvalidValueException;
import edma.valuedomains.impl.parser.ValueToken;
import edma.valuedomains.impl.parser.ValueToken.TokenType;
import edma.valuedomains.impl.parser.ValueTokenizer;

public class ListValueDomain extends AMetaValueDomain implements
		IListValueDomain
{
	private final Integer minSize, maxSize;
	private AMetaValueDomain elementValueDomain;

	public ListValueDomain(	String name,
							String scope,
							int index,
							Integer minSize,
							Integer maxSize,
							String elementValueDomainName,
							Constraint[] constraints,
							boolean autoGenerated)
	{
		super(name, scope, index, constraints, autoGenerated);
		this.minSize = minSize;
		this.maxSize = maxSize;
		this.elementValueDomain = new DummyValueDomain(elementValueDomainName);
	}

	@Override
	public void replaceDummies(IValueDomainBuilder vdb)
	{
		AMetaValueDomain vd = vdb.get(elementValueDomain.getName(), getScope());
		if(vd == null) throw new RuntimeException("The value domain "
				+ elementValueDomain.getName()
				+ " could not be found. Used in value domain " + getName()
				+ " in model: " + getScope());
		elementValueDomain = vd;
	}

	@Override
	public boolean isPossible(Set<String> parents)
	{
		if(minSize == null || minSize < 1) return true;
		else
		{
			if(parents.contains(getName())) return false;
			parents.add(getName());
			boolean res = elementValueDomain.isPossible(parents);
			parents.remove(getName());
			return res;
		}
	}

	@Override
	public EMetaType getEMetaType()
	{
		return EMetaType.List;
	}

	@Override
	public IListValueDomain asList()
	{
		return this;
	}

	@Override
	public IMetaValueDomain getElementValueDomain()
	{
		return elementValueDomain;
	}

	@Override
	public Integer getMinSize()
	{
		return minSize;
	}

	@Override
	public Integer getMaxSize()
	{
		return maxSize;
	}

	@Override
	public boolean contains(Object o)
	{
		if(!(o instanceof Object[])) return false;
		Object[] array = (Object[]) o;
		if(minSize != null && array.length < minSize) return false;
		if(maxSize != null && array.length > maxSize) return false;
		for(Object obj : array)
		{
			if(!elementValueDomain.contains(obj)) return false;
		}
		return true;
	}

	@Override
	protected boolean needNativeValidate()
	{
		return (minSize != null || maxSize != null);
	}

	@Override
	public void nativeValidate(Object o) throws InvalidValueException
	{
		Object[] array = (Object[]) o;
		if(minSize != null && array.length < minSize) throw new InvalidValueException(	this,
																						new Constraint(	"List_minSize",
																										"Check min size"),
																						"The list has size "
																								+ array.length
																								+ " which is smaller than the required minimum size "
																								+ minSize
																								+ " in the List value domain "
																								+ getName());
		if(maxSize != null && array.length > maxSize) throw new InvalidValueException(	this,
																						new Constraint(	"List_maxSize",
																										"Check max size"),
																						"The list has size "
																								+ array.length
																								+ " which is larger than the required maximum size "
																								+ maxSize
																								+ " in the List value domain "
																								+ getName());
	}

	@Override
	public void notNullValueToString(Object o, StringBuilder res)
	{
		Object[] array = (Object[]) o;
		res.append(ValueTokenizer.BEGIN);
		boolean first = true;
		for(Object obj : array)
		{
			if(first) first = false;
			else res.append(ValueTokenizer.SEPERATOR + " ");
			elementValueDomain.notNullValueToString(obj, res);
		}
		res.append(ValueTokenizer.END);
	}

	@Override
	public Object valueFromTokenizer(	ValueTokenizer tokenizer,
										IExternalConstraints external) throws InvalidValueException
	{
		ValueToken token = tokenizer.getNextToken();
		if(token.getType() == TokenType.Value
				&& "null".equals(token.getValue())) return null;
		if(token.getType() != TokenType.Begin) throw new InvalidValueException(	this,
																				parseConstraint,
																				"Error parsing List");
		ArrayList<Object> array = new ArrayList<Object>();
		boolean first = true;
		while(true)
		{
			token = tokenizer.getNextToken();
			if(token.getType() == TokenType.End)
			{
				Object[] res = array.toArray();
				validate(res, external);
				return res;
			}
			if(first)
			{
				first = false;
				tokenizer.takeBack(token);
			}
			else if(token.getType() != TokenType.Seperator) throw new InvalidValueException(this,
																							parseConstraint,
																							"Error parsing List");
			array.add(elementValueDomain.valueFromTokenizer(tokenizer, external));
		}
	}

	@Override
	public boolean notNullValueEqual(Object o1, Object o2)
	{
		Object[] a1 = (Object[]) o1;
		Object[] a2 = (Object[]) o2;
		if(a1.length != a2.length) return false;
		for(int i = 0; i < a1.length; ++i)
		{
			if(!elementValueDomain.notNullValueEqual(a1[i], a2[i])) return false;
		}
		return true;
	}

	@Override
	public int notNullValueCompare(Object o1, Object o2)
	{
		Object[] a1 = (Object[]) o1;
		Object[] a2 = (Object[]) o2;
		int minLength = Math.min(a1.length, a2.length);
		for(int i = 0; i < minLength; ++i)
		{
			int c = elementValueDomain.notNullValueCompare(a1[i], a2[i]);
			if(c != 0) return c;
		}
		return a2.length - a1.length;
	}

	@Override
	public int notNullValueHashCode(Object o)
	{
		Object[] a = (Object[]) o;
		int res = 17;
		for(int i = 0; i < a.length; ++i)
		{
			res = 31 * res + elementValueDomain.notNullValueHashCode(a[i]);
		}
		return res;
	}

	@Override
	public String getBasicType()
	{
		return null;
	}

	@Override
	public void writeValue(Object value, DataOutput out) throws IOException
	{
		Object[] array = (Object[]) value;
		out.writeInt(array.length);
		for(Object o : array)
		{
			elementValueDomain.writeValue(o, out);
		}

	}

	@Override
	protected Object doReadValue(DataInput in, IExternalConstraints external)	throws IOException,
																				InvalidValueException
	{
		int size = in.readInt();
		Object[] res = new Object[size];
		for(int i = 0; i < size; ++i)
		{
			res[i] = elementValueDomain.readValue(in, external);
		}
		validate(res, external);
		return res;
	}
}
