package edma.metamodel.impl;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

import edma.metamodel.IMetaAttribute;
import edma.valuedomains.IMetaValueDomain;
import edma.valuedomains.IValueDomainBuilder;
import edma.valuedomains.IValueDomainDefinitions;
import edma.valuedomains.impl.AMetaValueDomain;
import edma.valuedomains.impl.BooleanValueDomain;
import edma.valuedomains.impl.Constraint;
import edma.valuedomains.impl.DoubleValueDomain;
import edma.valuedomains.impl.EnumValueDomain;
import edma.valuedomains.impl.FloatValueDomain;
import edma.valuedomains.impl.IntegerValueDomain;
import edma.valuedomains.impl.ListValueDomain;
import edma.valuedomains.impl.LongValueDomain;
import edma.valuedomains.impl.MapValueDomain;
import edma.valuedomains.impl.OneOfValueDomain;
import edma.valuedomains.impl.StringValueDomain;
import edma.valuedomains.impl.StructValueDomain;
import edma.valuedomains.impl.StructValueDomainField;
import edma.valuedomains.impl.ValueDomainDefinitions;

/**
 * 1. Add value domains from system and then add environment. 2. Run replace
 * dummies, which connects the internal names to value domains 3. Hook value
 * domains to environment 4. build.
 * 
 */
public class ValueDomainBuilder implements IValueDomainBuilder
{
	private ArrayList<AMetaValueDomain> valueDomains;
	private Map<String, AMetaValueDomain> systemMap;
	private Map<String, Map<String, AMetaValueDomain>> modelMaps;

	public ValueDomainBuilder()
	{
		valueDomains = new ArrayList<AMetaValueDomain>();
		systemMap = new HashMap<String, AMetaValueDomain>();
		modelMaps = new HashMap<String, Map<String, AMetaValueDomain>>();
	}

	private IMetaValueDomain add(AMetaValueDomain domain)
	{
		String modelName = domain.getScope();
		if(modelName == null)
		{
			// Look for duplicate in systemMap
			if(systemMap.get(domain.getName()) != null) throw new RuntimeException(domain.getName()
					+ " has already been defined in system space");
			systemMap.put(domain.getName(), domain);
		}
		else
		{
			// Look for duplicate in modelMap
			Map<String, AMetaValueDomain> modelMap = modelMaps.get(modelName);
			if(modelMap == null)
			{
				modelMap = new HashMap<String, AMetaValueDomain>();
				modelMaps.put(modelName, modelMap);
			}
			else
			{
				if(modelMap.get(domain.getName()) != null) throw new RuntimeException(domain.getName()
						+ " has already been defined in model " + modelName);
			}
			modelMap.put(domain.getName(), domain);
		}
		valueDomains.add(domain);
		return domain;
	}

	public AMetaValueDomain get(String name, String modelName)
	{
		if(modelName != null)
		{
			Map<String, AMetaValueDomain> modelMap = modelMaps.get(modelName);
			if(modelMap != null)
			{
				AMetaValueDomain res = modelMap.get(name);
				if(res != null) return res;
			}
		}
		return systemMap.get(name);
	}

	private int index()
	{
		return valueDomains.size();
	}

	private Constraint[] getConstraints(Collection<Constraint> constraints)
	{
		Constraint[] cons = null;
		if(constraints != null && constraints.size() > 0)
		{
			cons = new Constraint[constraints.size()];
			int i = 0;
			for(Constraint c : constraints)
			{
				cons[i++] = c;
			}
		}
		return cons;
	}

	public IMetaValueDomain newBooleanDomain(	String name,
												String scope,
												Collection<Constraint> constraints,
												boolean autoGenerated)
	{

		return add(new BooleanValueDomain(	name,
											scope,
											index(),
											getConstraints(constraints),
											autoGenerated));
	}

	public IMetaValueDomain newIntegerDomain(	String name,
												String scope,
												Integer minValue,
												Integer maxValue,
												Collection<Constraint> constraints,
												boolean autoGenerated)
	{
		return add(new IntegerValueDomain(	name,
											scope,
											index(),
											minValue,
											maxValue,
											getConstraints(constraints),
											autoGenerated));
	}

	public IMetaValueDomain newLongDomain(	String name,
											String scope,
											Long minValue,
											Long maxValue,
											Collection<Constraint> constraints,
											boolean autoGenerated)
	{
		return add(new LongValueDomain(	name,
										scope,
										index(),
										minValue,
										maxValue,
										getConstraints(constraints),
										autoGenerated));
	}

	public IMetaValueDomain newFloatDomain(	String name,
											String scope,
											Float minValue,
											Float maxValue,
											Collection<Constraint> constraints,
											boolean autoGenerated)
	{
		return add(new FloatValueDomain(name,
										scope,
										index(),
										minValue,
										maxValue,
										getConstraints(constraints),
										autoGenerated));
	}

	public IMetaValueDomain newDoubleDomain(String name,
											String scope,
											Double minValue,
											Double maxValue,
											Collection<Constraint> constraints,
											boolean autoGenerated)
	{
		return add(new DoubleValueDomain(	name,
											scope,
											index(),
											minValue,
											maxValue,
											getConstraints(constraints),
											autoGenerated));
	}

	public IMetaValueDomain newStringDomain(String name,
											String scope,
											Integer minLength,
											Integer maxLength,
											String regexp,
											Collection<Constraint> constraints,
											boolean autoGenerated)
	{
		return add(new StringValueDomain(	name,
											scope,
											index(),
											minLength,
											maxLength,
											regexp,
											getConstraints(constraints),
											autoGenerated));
	}

	public IMetaValueDomain newEnumDomain(	String name,
											String scope,
											Collection<String> values,
											Collection<Constraint> constraints,
											boolean autoGenerated)
	{
		EnumValueDomain res = new EnumValueDomain(	name,
													scope,
													index(),
													getConstraints(constraints),
													autoGenerated);
		for(String s : values)
		{
			res.addElement(s);
		}
		res.trim();
		return add(res);
	}

	public IMetaValueDomain newListDomain(	String name,
											String scope,
											String elementDomain,
											Integer minSize,
											Integer maxSize,
											Collection<Constraint> constraints,
											boolean autoGenerated)
	{
		return add(new ListValueDomain(	name,
										scope,
										index(),
										minSize,
										maxSize,
										elementDomain,
										getConstraints(constraints),
										autoGenerated));
	}

	public IMetaValueDomain newMapDomain(	String name,
											String scope,
											String keyDomain,
											String valueDomain,
											Collection<Constraint> constraints,
											boolean autoGenerated)
	{
		return add(new MapValueDomain(	name,
										scope,
										index(),
										keyDomain,
										valueDomain,
										getConstraints(constraints),
										autoGenerated));
	}

	public IMetaValueDomain newOneOfDomain(	String name,
											String scope,
											Collection<String> optionDomains,
											Collection<Constraint> constraints,
											boolean autoGenerated)
	{
		return add(new OneOfValueDomain(name,
										scope,
										index(),
										optionDomains,
										getConstraints(constraints),
										autoGenerated));
	}

	public Field newStructField(String name,
								String valueDomain,
								boolean canBeNull)
	{
		return new Field(name, valueDomain, canBeNull);
	}

	public IMetaValueDomain newStructDomain(String name,
											String scope,
											Collection<Field> fields,
											Collection<Constraint> constraints,
											boolean autoGenerated)
	{
		StructValueDomain res = new StructValueDomain(	name,
														scope,
														index(),
														getConstraints(constraints),
														autoGenerated);
		for(Field field : fields)
		{
			StructValueDomainField sf = new StructValueDomainField(	field.name,
																	field.valueDomain,
																	scope,
																	field.canBeNull);
			res.addField(sf);
		}
		res.trim();
		return add(res);
	}

	public IValueDomainDefinitions buildStandaloneValueDomains()
	{
		IMetaValueDomain[] res = buildArrayAndReplaceDummies();
		checkForImpossibleValues();
		return new ValueDomainDefinitions(res);
	}

	public void buildWithEnvironment(MetaEnvironment env)
	{
		int size = env.getNumberOfDataModels();
		for(int i = 0; i < size; ++i)
		{
			MetaDataModel model = env.getMetaDataModel(i);
			addMetaDataModel(model);
		}

		// Create the final array and replace dummies
		IMetaValueDomain[] res = buildArrayAndReplaceDummies();
		checkForImpossibleValues();

		// Hook up model attributes with value domains
		env.hookValueDomains(this);
		env.setValueDomainDefinitions(new ValueDomainDefinitions(res));
	}

	private void addMetaDataModel(MetaDataModel model)
	{
		int size = model.getNumberOfSingletons();
		for(int i = 0; i < size; ++i)
		{
			MetaSingleton singleton = (MetaSingleton) model.getSingleton(i);
			addSingleton(singleton, model.getName());
		}

		size = model.getNumberOfKinds();
		for(int i = 0; i < size; ++i)
		{
			MetaKind kind = model.getKind(i);
			addKind(kind, model.getName());
		}
	}

	private void addSingleton(MetaSingleton singleton, String modelName)
	{
		ArrayList<Field> fields = new ArrayList<Field>();
		int size = singleton.getNumberOfAttributes();
		for(int i = 0; i < size; ++i)
		{
			IMetaAttribute att = singleton.getAttribute(i);
			Field field = new Field(att.getName(),
									att.getValueDomainName(),
									att.isOptional());
			fields.add(field);
		}
		if(singleton.publishAs() == null)
		{
			singleton.setValueDomain(newStructDomain(	singleton.getName(),
														modelName,
														fields,
														null,
														true));
		}
		else
		{
			singleton.setValueDomain(newStructDomain(	singleton.publishAs(),
														null,
														fields,
														null,
														true));
		}
	}

	private void addKind(MetaKind kind, String modelName)
	{
		ArrayList<Field> fields = new ArrayList<Field>();
		String name = kind.getName();
		String scope = modelName;
		if(kind.publishAs() != null)
		{
			name = kind.publishAs();
			scope = null;
		}
		kind.setIdValueDomain(newLongDomain(name + "ID", scope, 1L, null, null, true));
		kind.setListValueDomain(newListDomain(	name + "List",
												scope,
												name,
												null,
												null,
												null,
												true));
		fields.add(new Field("ID", name + "ID", true));
		int size = kind.getNumberOfAttributes();
		for(int i = 0; i < size; ++i)
		{
			IMetaAttribute att = kind.getAttribute(i);
			Field field = new Field(att.getName(),
									att.getValueDomainName(),
									att.isOptional());
			fields.add(field);
		}
		kind.setValueDomain(newStructDomain(name, scope, fields, null, true));
	}

	private IMetaValueDomain[] buildArrayAndReplaceDummies()
	{
		// Build result and replace dummies
		IMetaValueDomain[] res = new IMetaValueDomain[valueDomains.size()];
		int i = 0;
		for(AMetaValueDomain vd : valueDomains)
		{
			vd.replaceDummies(this);
			res[i++] = vd;
		}
		return res;
	}

	private void checkForImpossibleValues()
	{
		// Check for impossible values
		Set<String> set = new HashSet<String>();
		for(AMetaValueDomain vd : valueDomains)
		{
			if(!vd.isPossible(set)){ throw new RuntimeException("It is not possible to create values of the value domain "
					+ vd.getName()
					+ " because it contains illegal reference loops."); }
		}
	}

	public class Field
	{
		public final String name;
		public final String valueDomain;
		public final boolean canBeNull;

		private Field(	String name,
						String valueDomain,
						boolean canBeNull)
		{
			this.name = name;
			this.valueDomain = valueDomain;
			this.canBeNull = canBeNull;
		}
	}

}
