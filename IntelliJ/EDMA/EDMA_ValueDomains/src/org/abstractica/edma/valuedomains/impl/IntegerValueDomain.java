package org.abstractica.edma.valuedomains.impl;

import java.io.DataInput;
import java.io.DataOutput;
import java.io.IOException;

import org.abstractica.edma.valuedomains.IExternalConstraints;
import org.abstractica.edma.valuedomains.IIntegerValueDomain;
import org.abstractica.edma.valuedomains.exceptions.InvalidValueException;
import org.abstractica.edma.valuedomains.impl.parser.ValueToken;
import org.abstractica.edma.valuedomains.impl.parser.ValueToken.TokenType;
import org.abstractica.edma.valuedomains.impl.parser.ValueTokenizer;

public class IntegerValueDomain extends AMetaValueDomain implements
		IIntegerValueDomain
{
	private final Integer minValue, maxValue;

	public IntegerValueDomain(	String name,
								String scope,
								int index,
								Integer minValue,
								Integer maxValue,
								Constraint[] constraints,
								boolean autoGenerated)
	{
		super(name, scope, index, constraints, autoGenerated);
		this.minValue = minValue;
		this.maxValue = maxValue;
	}

	@Override
	public EMetaType getEMetaType()
	{
		return EMetaType.Integer;
	}

	@Override
	public Integer getMin()
	{
		return minValue;
	}

	@Override
	public Integer getMax()
	{
		return maxValue;
	}

	@Override
	public IIntegerValueDomain asInteger()
	{
		return this;
	}

	@Override
	public boolean contains(Object o)
	{
		if(!(o instanceof Integer)) return false;
		Integer i = (Integer) o;
		if(minValue != null && i < minValue) return false;
		if(maxValue != null && i > maxValue) return false;
		return true;
	}

	@Override
	protected boolean needNativeValidate()
	{
		return (minValue != null || maxValue != null);
	}

	@Override
	public void nativeValidate(Object o) throws InvalidValueException
	{
		Integer i = (Integer) o;
		if(minValue != null && i < minValue) throw new InvalidValueException(	this,
																				new Constraint(	"Integer_minValue",
																								"Check min value"),
																				"The value "
																						+ i
																						+ " is smaller than the required minimum value "
																						+ minValue
																						+ " in the Integer value domain "
																						+ getName());
		if(maxValue != null && i > maxValue) throw new InvalidValueException(	this,
																				new Constraint(	"Integer_maxValue",
																								"Check max value"),
																				"The value "
																						+ i
																						+ " is larger than the required maximum value "
																						+ maxValue
																						+ " in the Integer value domain "
																						+ getName());
	}

	@Override
	public void notNullValueToString(Object o, StringBuilder res)
	{
		if(o == null) res.append("null");
		else res.append((Integer) o);
	}

	@Override
	protected Object valueFromTokenizer(ValueTokenizer tokenizer,
										IExternalConstraints external) throws InvalidValueException
	{
		ValueToken token = tokenizer.getNextToken();
		if(token.getType() != TokenType.Value) throw new InvalidValueException(	this,
																				parseConstraint,
																				"Error parsing Integer");
		if("null".equals(token.getValue())) return null;
		Object res = null;
		try
		{
			res = Integer.parseInt(token.getValue());
		}
		catch(Exception e)
		{
			throw new InvalidValueException(this,
											parseConstraint,
											"Error parsing Integer");
		}
		validate(res, external);
		return res;
	}

	@Override
	public boolean notNullValueEqual(Object o1, Object o2)
	{
		return o1.equals(o2);
	}

	@Override
	public int notNullValueCompare(Object o1, Object o2)
	{
		return ((Integer) o1).compareTo((Integer) o2);
	}

	@Override
	public int notNullValueHashCode(Object o)
	{
		return o.hashCode();
	}

	@Override
	public String getBasicType()
	{
		return "Integer";
	}

	@Override
	public void writeValue(Object value, DataOutput out) throws IOException
	{
		out.writeInt((Integer) value);
	}

	@Override
	protected Object doReadValue(DataInput in, IExternalConstraints external)	throws IOException,
																				InvalidValueException
	{
		Integer res = in.readInt();
		validate(res, external);
		return res;
	}
}
