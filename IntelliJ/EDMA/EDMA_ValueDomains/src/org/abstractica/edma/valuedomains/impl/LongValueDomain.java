package org.abstractica.edma.valuedomains.impl;

import java.io.DataInput;
import java.io.DataOutput;
import java.io.IOException;

import org.abstractica.edma.valuedomains.IExternalConstraints;
import org.abstractica.edma.valuedomains.ILongValueDomain;
import org.abstractica.edma.valuedomains.exceptions.InvalidValueException;
import org.abstractica.edma.valuedomains.impl.parser.ValueToken;
import org.abstractica.edma.valuedomains.impl.parser.ValueToken.TokenType;
import org.abstractica.edma.valuedomains.impl.parser.ValueTokenizer;

public class LongValueDomain extends AMetaValueDomain implements
		ILongValueDomain
{
	private final Long minValue, maxValue;

	public LongValueDomain(	String name,
							String scope,
							int index,
							Long minValue,
							Long maxValue,
							Constraint[] constraints,
							boolean autoGenerated)
	{
		super(name, scope, index, constraints, autoGenerated);
		this.minValue = minValue;
		this.maxValue = maxValue;
	}

	@Override
	public EMetaType getEMetaType()
	{
		return EMetaType.Long;
	}

	@Override
	public Long getMin()
	{
		return minValue;
	}

	@Override
	public Long getMax()
	{
		return maxValue;
	}

	@Override
	public ILongValueDomain asLong()
	{
		return this;
	}

	@Override
	public boolean contains(Object o)
	{
		if(!(o instanceof Long)) return false;
		Long l = (Long) o;
		if(minValue != null && l < minValue) return false;
		if(maxValue != null && l > maxValue) return false;
		return true;
	}

	@Override
	protected boolean needNativeValidate()
	{
		return (minValue != null || maxValue != null);
	}

	@Override
	public void nativeValidate(Object o) throws InvalidValueException
	{
		Long l = (Long) o;
		if(minValue != null && l < minValue) throw new InvalidValueException(	this,
																				new Constraint(	"Long_minValue",
																								"Check max value"),
																				"The value "
																						+ l
																						+ " is smaller than the required minimum value "
																						+ minValue
																						+ " in the Long value domain "
																						+ getName());
		if(maxValue != null && l > maxValue) throw new InvalidValueException(	this,
																				new Constraint(	"Long_maxValue",
																								"Check min value"),
																				"The value "
																						+ l
																						+ " is larger than the required maximum value "
																						+ maxValue
																						+ " in the Long value domain "
																						+ getName());
	}

	@Override
	public void notNullValueToString(Object o, StringBuilder res)
	{
		if(o == null) res.append("null");
		else res.append((Long) o);
	}

	@Override
	protected Object valueFromTokenizer(ValueTokenizer tokenizer,
										IExternalConstraints external) throws InvalidValueException
	{
		ValueToken token = tokenizer.getNextToken();
		if(token.getType() != TokenType.Value) throw new InvalidValueException(	this,
																				parseConstraint,
																				"Error parsing Long");
		if("null".equals(token.getValue())) return null;
		Object res = null;
		try
		{
			res = Long.parseLong(token.getValue());
		}
		catch(Exception e)
		{
			throw new InvalidValueException(this,
											parseConstraint,
											"Error parsing Long");
		}
		validate(res, external);
		return res;
	}

	@Override
	public boolean notNullValueEqual(Object o1, Object o2)
	{
		return o1.equals(o2);
	}

	@Override
	public int notNullValueCompare(Object o1, Object o2)
	{
		return ((Long) o1).compareTo((Long) o2);
	}

	@Override
	public int notNullValueHashCode(Object o)
	{
		return o.hashCode();
	}

	@Override
	public String getBasicType()
	{
		return "Long";
	}

	@Override
	public void writeValue(Object value, DataOutput out) throws IOException
	{
		out.writeLong((Long) value);
	}

	@Override
	protected Object doReadValue(DataInput in, IExternalConstraints external)	throws IOException,
																				InvalidValueException
	{
		Long res = in.readLong();
		validate(res, external);
		return res;
	}
}
